// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ClientNamenodeProtocol.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    offset: ::std::option::Option<u64>,
    length: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockLocationsRequestProto {
    fn default() -> &'a GetBlockLocationsRequestProto {
        <GetBlockLocationsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockLocationsRequestProto {
    pub fn new() -> GetBlockLocationsRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetBlockLocationsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockLocationsRequestProto {
        GetBlockLocationsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &GetBlockLocationsRequestProto| { &m.src },
                    |m: &mut GetBlockLocationsRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    |m: &GetBlockLocationsRequestProto| { &m.offset },
                    |m: &mut GetBlockLocationsRequestProto| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &GetBlockLocationsRequestProto| { &m.length },
                    |m: &mut GetBlockLocationsRequestProto| { &mut m.length },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsRequestProto>(
                    "GetBlockLocationsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockLocationsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsRequestProto,
        };
        unsafe {
            instance.get(GetBlockLocationsRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.offset = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBlockLocationsResponseProto {
    // message fields
    locations: ::protobuf::SingularPtrField<super::hdfs::LocatedBlocksProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBlockLocationsResponseProto {
    fn default() -> &'a GetBlockLocationsResponseProto {
        <GetBlockLocationsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetBlockLocationsResponseProto {
    pub fn new() -> GetBlockLocationsResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 1;


    pub fn get_locations(&self) -> &super::hdfs::LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::default_instance())
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: super::hdfs::LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut super::hdfs::LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> super::hdfs::LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| super::hdfs::LocatedBlocksProto::new())
    }
}

impl ::protobuf::Message for GetBlockLocationsResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBlockLocationsResponseProto {
        GetBlockLocationsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlocksProto>>(
                    "locations",
                    |m: &GetBlockLocationsResponseProto| { &m.locations },
                    |m: &mut GetBlockLocationsResponseProto| { &mut m.locations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBlockLocationsResponseProto>(
                    "GetBlockLocationsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBlockLocationsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetBlockLocationsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBlockLocationsResponseProto,
        };
        unsafe {
            instance.get(GetBlockLocationsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetBlockLocationsResponseProto {
    fn clear(&mut self) {
        self.locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBlockLocationsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBlockLocationsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServerDefaultsRequestProto {
    fn default() -> &'a GetServerDefaultsRequestProto {
        <GetServerDefaultsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetServerDefaultsRequestProto {
    pub fn new() -> GetServerDefaultsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetServerDefaultsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServerDefaultsRequestProto {
        GetServerDefaultsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsRequestProto>(
                    "GetServerDefaultsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetServerDefaultsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsRequestProto,
        };
        unsafe {
            instance.get(GetServerDefaultsRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerDefaultsResponseProto {
    // message fields
    serverDefaults: ::protobuf::SingularPtrField<super::hdfs::FsServerDefaultsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServerDefaultsResponseProto {
    fn default() -> &'a GetServerDefaultsResponseProto {
        <GetServerDefaultsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetServerDefaultsResponseProto {
    pub fn new() -> GetServerDefaultsResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.FsServerDefaultsProto serverDefaults = 1;


    pub fn get_serverDefaults(&self) -> &super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.as_ref().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::default_instance())
    }
    pub fn clear_serverDefaults(&mut self) {
        self.serverDefaults.clear();
    }

    pub fn has_serverDefaults(&self) -> bool {
        self.serverDefaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverDefaults(&mut self, v: super::hdfs::FsServerDefaultsProto) {
        self.serverDefaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverDefaults(&mut self) -> &mut super::hdfs::FsServerDefaultsProto {
        if self.serverDefaults.is_none() {
            self.serverDefaults.set_default();
        }
        self.serverDefaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverDefaults(&mut self) -> super::hdfs::FsServerDefaultsProto {
        self.serverDefaults.take().unwrap_or_else(|| super::hdfs::FsServerDefaultsProto::new())
    }
}

impl ::protobuf::Message for GetServerDefaultsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.serverDefaults.is_none() {
            return false;
        }
        for v in &self.serverDefaults {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverDefaults)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.serverDefaults.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.serverDefaults.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServerDefaultsResponseProto {
        GetServerDefaultsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsServerDefaultsProto>>(
                    "serverDefaults",
                    |m: &GetServerDefaultsResponseProto| { &m.serverDefaults },
                    |m: &mut GetServerDefaultsResponseProto| { &mut m.serverDefaults },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetServerDefaultsResponseProto>(
                    "GetServerDefaultsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetServerDefaultsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetServerDefaultsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetServerDefaultsResponseProto,
        };
        unsafe {
            instance.get(GetServerDefaultsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetServerDefaultsResponseProto {
    fn clear(&mut self) {
        self.serverDefaults.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerDefaultsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerDefaultsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    createFlag: ::std::option::Option<u32>,
    createParent: ::std::option::Option<bool>,
    replication: ::std::option::Option<u32>,
    blockSize: ::std::option::Option<u64>,
    cryptoProtocolVersion: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequestProto {
    fn default() -> &'a CreateRequestProto {
        <CreateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequestProto {
    pub fn new() -> CreateRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;


    pub fn get_masked(&self) -> &super::hdfs::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }
    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::hdfs::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::hdfs::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    // required string clientName = 3;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 createFlag = 4;


    pub fn get_createFlag(&self) -> u32 {
        self.createFlag.unwrap_or(0)
    }
    pub fn clear_createFlag(&mut self) {
        self.createFlag = ::std::option::Option::None;
    }

    pub fn has_createFlag(&self) -> bool {
        self.createFlag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createFlag(&mut self, v: u32) {
        self.createFlag = ::std::option::Option::Some(v);
    }

    // required bool createParent = 5;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }

    // required uint32 replication = 6;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // required uint64 blockSize = 7;


    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 8;


    pub fn get_cryptoProtocolVersion(&self) -> &[super::hdfs::CryptoProtocolVersionProto] {
        &self.cryptoProtocolVersion
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto>) {
        self.cryptoProtocolVersion = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoProtocolVersion(&mut self) -> &mut ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        &mut self.cryptoProtocolVersion
    }

    // Take field
    pub fn take_cryptoProtocolVersion(&mut self) -> ::std::vec::Vec<super::hdfs::CryptoProtocolVersionProto> {
        ::std::mem::replace(&mut self.cryptoProtocolVersion, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        if self.createFlag.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.blockSize.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.createFlag = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.createFlag {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.createFlag {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.blockSize {
            os.write_uint64(7, v)?;
        }
        for v in &self.cryptoProtocolVersion {
            os.write_enum(8, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequestProto {
        CreateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &CreateRequestProto| { &m.src },
                    |m: &mut CreateRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "masked",
                    |m: &CreateRequestProto| { &m.masked },
                    |m: &mut CreateRequestProto| { &mut m.masked },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &CreateRequestProto| { &m.clientName },
                    |m: &mut CreateRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "createFlag",
                    |m: &CreateRequestProto| { &m.createFlag },
                    |m: &mut CreateRequestProto| { &mut m.createFlag },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    |m: &CreateRequestProto| { &m.createParent },
                    |m: &mut CreateRequestProto| { &mut m.createParent },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    |m: &CreateRequestProto| { &m.replication },
                    |m: &mut CreateRequestProto| { &mut m.replication },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockSize",
                    |m: &CreateRequestProto| { &m.blockSize },
                    |m: &mut CreateRequestProto| { &mut m.blockSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::CryptoProtocolVersionProto>>(
                    "cryptoProtocolVersion",
                    |m: &CreateRequestProto| { &m.cryptoProtocolVersion },
                    |m: &mut CreateRequestProto| { &mut m.cryptoProtocolVersion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRequestProto>(
                    "CreateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRequestProto,
        };
        unsafe {
            instance.get(CreateRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.masked.clear();
        self.clientName.clear();
        self.createFlag = ::std::option::Option::None;
        self.createParent = ::std::option::Option::None;
        self.replication = ::std::option::Option::None;
        self.blockSize = ::std::option::Option::None;
        self.cryptoProtocolVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateResponseProto {
    fn default() -> &'a CreateResponseProto {
        <CreateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateResponseProto {
    pub fn new() -> CreateResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for CreateResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResponseProto {
        CreateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    |m: &CreateResponseProto| { &m.fs },
                    |m: &mut CreateResponseProto| { &mut m.fs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResponseProto>(
                    "CreateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResponseProto,
        };
        unsafe {
            instance.get(CreateResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    flag: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendRequestProto {
    fn default() -> &'a AppendRequestProto {
        <AppendRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AppendRequestProto {
    pub fn new() -> AppendRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flag = 3;


    pub fn get_flag(&self) -> u32 {
        self.flag.unwrap_or(0)
    }
    pub fn clear_flag(&mut self) {
        self.flag = ::std::option::Option::None;
    }

    pub fn has_flag(&self) -> bool {
        self.flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: u32) {
        self.flag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AppendRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.flag {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.flag {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendRequestProto {
        AppendRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &AppendRequestProto| { &m.src },
                    |m: &mut AppendRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &AppendRequestProto| { &m.clientName },
                    |m: &mut AppendRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flag",
                    |m: &AppendRequestProto| { &m.flag },
                    |m: &mut AppendRequestProto| { &mut m.flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendRequestProto>(
                    "AppendRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppendRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendRequestProto,
        };
        unsafe {
            instance.get(AppendRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AppendRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.flag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AppendResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    stat: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AppendResponseProto {
    fn default() -> &'a AppendResponseProto {
        <AppendResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AppendResponseProto {
    pub fn new() -> AppendResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto stat = 2;


    pub fn get_stat(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.stat.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }
    pub fn clear_stat(&mut self) {
        self.stat.clear();
    }

    pub fn has_stat(&self) -> bool {
        self.stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.stat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.stat.is_none() {
            self.stat.set_default();
        }
        self.stat.as_mut().unwrap()
    }

    // Take field
    pub fn take_stat(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.stat.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for AppendResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stat {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stat)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stat.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AppendResponseProto {
        AppendResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    |m: &AppendResponseProto| { &m.block },
                    |m: &mut AppendResponseProto| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "stat",
                    |m: &AppendResponseProto| { &m.stat },
                    |m: &mut AppendResponseProto| { &mut m.stat },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AppendResponseProto>(
                    "AppendResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AppendResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AppendResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AppendResponseProto,
        };
        unsafe {
            instance.get(AppendResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AppendResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.stat.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AppendResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReplicationRequestProto {
    fn default() -> &'a SetReplicationRequestProto {
        <SetReplicationRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetReplicationRequestProto {
    pub fn new() -> SetReplicationRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 replication = 2;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetReplicationRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReplicationRequestProto {
        SetReplicationRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &SetReplicationRequestProto| { &m.src },
                    |m: &mut SetReplicationRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    |m: &SetReplicationRequestProto| { &m.replication },
                    |m: &mut SetReplicationRequestProto| { &mut m.replication },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationRequestProto>(
                    "SetReplicationRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetReplicationRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationRequestProto,
        };
        unsafe {
            instance.get(SetReplicationRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetReplicationRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.replication = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReplicationResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReplicationResponseProto {
    fn default() -> &'a SetReplicationResponseProto {
        <SetReplicationResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetReplicationResponseProto {
    pub fn new() -> SetReplicationResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetReplicationResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReplicationResponseProto {
        SetReplicationResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &SetReplicationResponseProto| { &m.result },
                    |m: &mut SetReplicationResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReplicationResponseProto>(
                    "SetReplicationResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetReplicationResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetReplicationResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReplicationResponseProto,
        };
        unsafe {
            instance.get(SetReplicationResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetReplicationResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReplicationResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReplicationResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    policyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetStoragePolicyRequestProto {
    fn default() -> &'a SetStoragePolicyRequestProto {
        <SetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetStoragePolicyRequestProto {
    pub fn new() -> SetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string policyName = 2;


    pub fn get_policyName(&self) -> &str {
        match self.policyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_policyName(&mut self) {
        self.policyName.clear();
    }

    pub fn has_policyName(&self) -> bool {
        self.policyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyName(&mut self, v: ::std::string::String) {
        self.policyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policyName(&mut self) -> &mut ::std::string::String {
        if self.policyName.is_none() {
            self.policyName.set_default();
        }
        self.policyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_policyName(&mut self) -> ::std::string::String {
        self.policyName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.policyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.policyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.policyName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.policyName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetStoragePolicyRequestProto {
        SetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &SetStoragePolicyRequestProto| { &m.src },
                    |m: &mut SetStoragePolicyRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "policyName",
                    |m: &SetStoragePolicyRequestProto| { &m.policyName },
                    |m: &mut SetStoragePolicyRequestProto| { &mut m.policyName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyRequestProto>(
                    "SetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(SetStoragePolicyRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.policyName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetStoragePolicyResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetStoragePolicyResponseProto {
    fn default() -> &'a SetStoragePolicyResponseProto {
        <SetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetStoragePolicyResponseProto {
    pub fn new() -> SetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetStoragePolicyResponseProto {
        SetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetStoragePolicyResponseProto>(
                    "SetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(SetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePolicyRequestProto {
    fn default() -> &'a GetStoragePolicyRequestProto {
        <GetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePolicyRequestProto {
    pub fn new() -> GetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePolicyRequestProto {
        GetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &GetStoragePolicyRequestProto| { &m.path },
                    |m: &mut GetStoragePolicyRequestProto| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePolicyRequestProto>(
                    "GetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(GetStoragePolicyRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePolicyResponseProto {
    // message fields
    storagePolicy: ::protobuf::SingularPtrField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePolicyResponseProto {
    fn default() -> &'a GetStoragePolicyResponseProto {
        <GetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePolicyResponseProto {
    pub fn new() -> GetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockStoragePolicyProto storagePolicy = 1;


    pub fn get_storagePolicy(&self) -> &super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.as_ref().unwrap_or_else(|| super::hdfs::BlockStoragePolicyProto::default_instance())
    }
    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy.clear();
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: super::hdfs::BlockStoragePolicyProto) {
        self.storagePolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicy(&mut self) -> &mut super::hdfs::BlockStoragePolicyProto {
        if self.storagePolicy.is_none() {
            self.storagePolicy.set_default();
        }
        self.storagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicy(&mut self) -> super::hdfs::BlockStoragePolicyProto {
        self.storagePolicy.take().unwrap_or_else(|| super::hdfs::BlockStoragePolicyProto::new())
    }
}

impl ::protobuf::Message for GetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        if self.storagePolicy.is_none() {
            return false;
        }
        for v in &self.storagePolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storagePolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storagePolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storagePolicy.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePolicyResponseProto {
        GetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                    "storagePolicy",
                    |m: &GetStoragePolicyResponseProto| { &m.storagePolicy },
                    |m: &mut GetStoragePolicyResponseProto| { &mut m.storagePolicy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePolicyResponseProto>(
                    "GetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(GetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.storagePolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsetStoragePolicyRequestProto {
    fn default() -> &'a UnsetStoragePolicyRequestProto {
        <UnsetStoragePolicyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UnsetStoragePolicyRequestProto {
    pub fn new() -> UnsetStoragePolicyRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnsetStoragePolicyRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsetStoragePolicyRequestProto {
        UnsetStoragePolicyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &UnsetStoragePolicyRequestProto| { &m.src },
                    |m: &mut UnsetStoragePolicyRequestProto| { &mut m.src },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnsetStoragePolicyRequestProto>(
                    "UnsetStoragePolicyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnsetStoragePolicyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UnsetStoragePolicyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsetStoragePolicyRequestProto,
        };
        unsafe {
            instance.get(UnsetStoragePolicyRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnsetStoragePolicyResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnsetStoragePolicyResponseProto {
    fn default() -> &'a UnsetStoragePolicyResponseProto {
        <UnsetStoragePolicyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UnsetStoragePolicyResponseProto {
    pub fn new() -> UnsetStoragePolicyResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnsetStoragePolicyResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnsetStoragePolicyResponseProto {
        UnsetStoragePolicyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UnsetStoragePolicyResponseProto>(
                    "UnsetStoragePolicyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnsetStoragePolicyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UnsetStoragePolicyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnsetStoragePolicyResponseProto,
        };
        unsafe {
            instance.get(UnsetStoragePolicyResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for UnsetStoragePolicyResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnsetStoragePolicyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsetStoragePolicyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePoliciesRequestProto {
    fn default() -> &'a GetStoragePoliciesRequestProto {
        <GetStoragePoliciesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePoliciesRequestProto {
    pub fn new() -> GetStoragePoliciesRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetStoragePoliciesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePoliciesRequestProto {
        GetStoragePoliciesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesRequestProto>(
                    "GetStoragePoliciesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetStoragePoliciesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesRequestProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStoragePoliciesResponseProto {
    // message fields
    policies: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStoragePoliciesResponseProto {
    fn default() -> &'a GetStoragePoliciesResponseProto {
        <GetStoragePoliciesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetStoragePoliciesResponseProto {
    pub fn new() -> GetStoragePoliciesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.BlockStoragePolicyProto policies = 1;


    pub fn get_policies(&self) -> &[super::hdfs::BlockStoragePolicyProto] {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::protobuf::RepeatedField<super::hdfs::BlockStoragePolicyProto> {
        ::std::mem::replace(&mut self.policies, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetStoragePoliciesResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.policies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.policies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.policies {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStoragePoliciesResponseProto {
        GetStoragePoliciesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::BlockStoragePolicyProto>>(
                    "policies",
                    |m: &GetStoragePoliciesResponseProto| { &m.policies },
                    |m: &mut GetStoragePoliciesResponseProto| { &mut m.policies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetStoragePoliciesResponseProto>(
                    "GetStoragePoliciesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetStoragePoliciesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetStoragePoliciesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetStoragePoliciesResponseProto,
        };
        unsafe {
            instance.get(GetStoragePoliciesResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetStoragePoliciesResponseProto {
    fn clear(&mut self) {
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStoragePoliciesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStoragePoliciesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    permission: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPermissionRequestProto {
    fn default() -> &'a SetPermissionRequestProto {
        <SetPermissionRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionRequestProto {
    pub fn new() -> SetPermissionRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 2;


    pub fn get_permission(&self) -> &super::hdfs::FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: super::hdfs::FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> super::hdfs::FsPermissionProto {
        self.permission.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }
}

impl ::protobuf::Message for SetPermissionRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPermissionRequestProto {
        SetPermissionRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &SetPermissionRequestProto| { &m.src },
                    |m: &mut SetPermissionRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "permission",
                    |m: &SetPermissionRequestProto| { &m.permission },
                    |m: &mut SetPermissionRequestProto| { &mut m.permission },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionRequestProto>(
                    "SetPermissionRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPermissionRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionRequestProto,
        };
        unsafe {
            instance.get(SetPermissionRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetPermissionRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.permission.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPermissionResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPermissionResponseProto {
    fn default() -> &'a SetPermissionResponseProto {
        <SetPermissionResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetPermissionResponseProto {
    pub fn new() -> SetPermissionResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetPermissionResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPermissionResponseProto {
        SetPermissionResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetPermissionResponseProto>(
                    "SetPermissionResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPermissionResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetPermissionResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPermissionResponseProto,
        };
        unsafe {
            instance.get(SetPermissionResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetPermissionResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPermissionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPermissionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    username: ::protobuf::SingularField<::std::string::String>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetOwnerRequestProto {
    fn default() -> &'a SetOwnerRequestProto {
        <SetOwnerRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetOwnerRequestProto {
    pub fn new() -> SetOwnerRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string username = 2;


    pub fn get_username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username.set_default();
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupname = 3;


    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetOwnerRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.username.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.username.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetOwnerRequestProto {
        SetOwnerRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &SetOwnerRequestProto| { &m.src },
                    |m: &mut SetOwnerRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &SetOwnerRequestProto| { &m.username },
                    |m: &mut SetOwnerRequestProto| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupname",
                    |m: &SetOwnerRequestProto| { &m.groupname },
                    |m: &mut SetOwnerRequestProto| { &mut m.groupname },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerRequestProto>(
                    "SetOwnerRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetOwnerRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerRequestProto,
        };
        unsafe {
            instance.get(SetOwnerRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetOwnerRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.username.clear();
        self.groupname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetOwnerResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetOwnerResponseProto {
    fn default() -> &'a SetOwnerResponseProto {
        <SetOwnerResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetOwnerResponseProto {
    pub fn new() -> SetOwnerResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetOwnerResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetOwnerResponseProto {
        SetOwnerResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetOwnerResponseProto>(
                    "SetOwnerResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetOwnerResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetOwnerResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetOwnerResponseProto,
        };
        unsafe {
            instance.get(SetOwnerResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetOwnerResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetOwnerResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetOwnerResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockRequestProto {
    // message fields
    b: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    src: ::protobuf::SingularField<::std::string::String>,
    holder: ::protobuf::SingularField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonBlockRequestProto {
    fn default() -> &'a AbandonBlockRequestProto {
        <AbandonBlockRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AbandonBlockRequestProto {
    pub fn new() -> AbandonBlockRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;


    pub fn get_b(&self) -> &super::hdfs::ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required string src = 2;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string holder = 3;


    pub fn get_holder(&self) -> &str {
        match self.holder.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_holder(&mut self) {
        self.holder.clear();
    }

    pub fn has_holder(&self) -> bool {
        self.holder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holder(&mut self, v: ::std::string::String) {
        self.holder = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_holder(&mut self) -> &mut ::std::string::String {
        if self.holder.is_none() {
            self.holder.set_default();
        }
        self.holder.as_mut().unwrap()
    }

    // Take field
    pub fn take_holder(&mut self) -> ::std::string::String {
        self.holder.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AbandonBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.src.is_none() {
            return false;
        }
        if self.holder.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.holder)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.holder.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.holder.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonBlockRequestProto {
        AbandonBlockRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "b",
                    |m: &AbandonBlockRequestProto| { &m.b },
                    |m: &mut AbandonBlockRequestProto| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &AbandonBlockRequestProto| { &m.src },
                    |m: &mut AbandonBlockRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "holder",
                    |m: &AbandonBlockRequestProto| { &m.holder },
                    |m: &mut AbandonBlockRequestProto| { &mut m.holder },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &AbandonBlockRequestProto| { &m.fileId },
                    |m: &mut AbandonBlockRequestProto| { &mut m.fileId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockRequestProto>(
                    "AbandonBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockRequestProto,
        };
        unsafe {
            instance.get(AbandonBlockRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AbandonBlockRequestProto {
    fn clear(&mut self) {
        self.b.clear();
        self.src.clear();
        self.holder.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbandonBlockResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbandonBlockResponseProto {
    fn default() -> &'a AbandonBlockResponseProto {
        <AbandonBlockResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AbandonBlockResponseProto {
    pub fn new() -> AbandonBlockResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbandonBlockResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbandonBlockResponseProto {
        AbandonBlockResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AbandonBlockResponseProto>(
                    "AbandonBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AbandonBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AbandonBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AbandonBlockResponseProto,
        };
        unsafe {
            instance.get(AbandonBlockResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AbandonBlockResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbandonBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbandonBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    previous: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    excludeNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    fileId: ::std::option::Option<u64>,
    favoredNodes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddBlockRequestProto {
    fn default() -> &'a AddBlockRequestProto {
        <AddBlockRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddBlockRequestProto {
    pub fn new() -> AddBlockRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ExtendedBlockProto previous = 3;


    pub fn get_previous(&self) -> &super::hdfs::ExtendedBlockProto {
        self.previous.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.previous.is_none() {
            self.previous.set_default();
        }
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.previous.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludeNodes = 4;


    pub fn get_excludeNodes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludeNodes
    }
    pub fn clear_excludeNodes(&mut self) {
        self.excludeNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludeNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludeNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludeNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludeNodes
    }

    // Take field
    pub fn take_excludeNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludeNodes, ::protobuf::RepeatedField::new())
    }

    // optional uint64 fileId = 5;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    // repeated string favoredNodes = 6;


    pub fn get_favoredNodes(&self) -> &[::std::string::String] {
        &self.favoredNodes
    }
    pub fn clear_favoredNodes(&mut self) {
        self.favoredNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_favoredNodes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.favoredNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_favoredNodes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.favoredNodes
    }

    // Take field
    pub fn take_favoredNodes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.favoredNodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddBlockRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.previous {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludeNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.previous)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludeNodes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.favoredNodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.previous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.excludeNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.favoredNodes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.previous.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.excludeNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(5, v)?;
        }
        for v in &self.favoredNodes {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddBlockRequestProto {
        AddBlockRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &AddBlockRequestProto| { &m.src },
                    |m: &mut AddBlockRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &AddBlockRequestProto| { &m.clientName },
                    |m: &mut AddBlockRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "previous",
                    |m: &AddBlockRequestProto| { &m.previous },
                    |m: &mut AddBlockRequestProto| { &mut m.previous },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludeNodes",
                    |m: &AddBlockRequestProto| { &m.excludeNodes },
                    |m: &mut AddBlockRequestProto| { &mut m.excludeNodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &AddBlockRequestProto| { &m.fileId },
                    |m: &mut AddBlockRequestProto| { &mut m.fileId },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "favoredNodes",
                    |m: &AddBlockRequestProto| { &m.favoredNodes },
                    |m: &mut AddBlockRequestProto| { &mut m.favoredNodes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockRequestProto>(
                    "AddBlockRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddBlockRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockRequestProto,
        };
        unsafe {
            instance.get(AddBlockRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AddBlockRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.previous.clear();
        self.excludeNodes.clear();
        self.fileId = ::std::option::Option::None;
        self.favoredNodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddBlockResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddBlockResponseProto {
    fn default() -> &'a AddBlockResponseProto {
        <AddBlockResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddBlockResponseProto {
    pub fn new() -> AddBlockResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for AddBlockResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddBlockResponseProto {
        AddBlockResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    |m: &AddBlockResponseProto| { &m.block },
                    |m: &mut AddBlockResponseProto| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddBlockResponseProto>(
                    "AddBlockResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddBlockResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddBlockResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddBlockResponseProto,
        };
        unsafe {
            instance.get(AddBlockResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AddBlockResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddBlockResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddBlockResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    blk: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    existings: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    excludes: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    numAdditionalNodes: ::std::option::Option<u32>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    existingStorageUuids: ::protobuf::RepeatedField<::std::string::String>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAdditionalDatanodeRequestProto {
    fn default() -> &'a GetAdditionalDatanodeRequestProto {
        <GetAdditionalDatanodeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAdditionalDatanodeRequestProto {
    pub fn new() -> GetAdditionalDatanodeRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto blk = 2;


    pub fn get_blk(&self) -> &super::hdfs::ExtendedBlockProto {
        self.blk.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_blk(&mut self) {
        self.blk.clear();
    }

    pub fn has_blk(&self) -> bool {
        self.blk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blk(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.blk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blk(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.blk.is_none() {
            self.blk.set_default();
        }
        self.blk.as_mut().unwrap()
    }

    // Take field
    pub fn take_blk(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.blk.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto existings = 3;


    pub fn get_existings(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.existings
    }
    pub fn clear_existings(&mut self) {
        self.existings.clear();
    }

    // Param is passed by value, moved
    pub fn set_existings(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.existings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existings(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.existings
    }

    // Take field
    pub fn take_existings(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.existings, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto excludes = 4;


    pub fn get_excludes(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.excludes
    }
    pub fn clear_excludes(&mut self) {
        self.excludes.clear();
    }

    // Param is passed by value, moved
    pub fn set_excludes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.excludes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_excludes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.excludes
    }

    // Take field
    pub fn take_excludes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.excludes, ::protobuf::RepeatedField::new())
    }

    // required uint32 numAdditionalNodes = 5;


    pub fn get_numAdditionalNodes(&self) -> u32 {
        self.numAdditionalNodes.unwrap_or(0)
    }
    pub fn clear_numAdditionalNodes(&mut self) {
        self.numAdditionalNodes = ::std::option::Option::None;
    }

    pub fn has_numAdditionalNodes(&self) -> bool {
        self.numAdditionalNodes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numAdditionalNodes(&mut self, v: u32) {
        self.numAdditionalNodes = ::std::option::Option::Some(v);
    }

    // required string clientName = 6;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string existingStorageUuids = 7;


    pub fn get_existingStorageUuids(&self) -> &[::std::string::String] {
        &self.existingStorageUuids
    }
    pub fn clear_existingStorageUuids(&mut self) {
        self.existingStorageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_existingStorageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.existingStorageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_existingStorageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.existingStorageUuids
    }

    // Take field
    pub fn take_existingStorageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.existingStorageUuids, ::protobuf::RepeatedField::new())
    }

    // optional uint64 fileId = 8;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.blk.is_none() {
            return false;
        }
        if self.numAdditionalNodes.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.blk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.existings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.excludes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blk)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.existings)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.excludes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.numAdditionalNodes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.existingStorageUuids)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.blk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.existings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.excludes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.numAdditionalNodes {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.existingStorageUuids {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.blk.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.existings {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.excludes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.numAdditionalNodes {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.existingStorageUuids {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.fileId {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAdditionalDatanodeRequestProto {
        GetAdditionalDatanodeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.src },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "blk",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.blk },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.blk },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "existings",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.existings },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.existings },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "excludes",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.excludes },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.excludes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "numAdditionalNodes",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.numAdditionalNodes },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.numAdditionalNodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.clientName },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "existingStorageUuids",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.existingStorageUuids },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.existingStorageUuids },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &GetAdditionalDatanodeRequestProto| { &m.fileId },
                    |m: &mut GetAdditionalDatanodeRequestProto| { &mut m.fileId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeRequestProto>(
                    "GetAdditionalDatanodeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAdditionalDatanodeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeRequestProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.blk.clear();
        self.existings.clear();
        self.excludes.clear();
        self.numAdditionalNodes = ::std::option::Option::None;
        self.clientName.clear();
        self.existingStorageUuids.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAdditionalDatanodeResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAdditionalDatanodeResponseProto {
    fn default() -> &'a GetAdditionalDatanodeResponseProto {
        <GetAdditionalDatanodeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetAdditionalDatanodeResponseProto {
    pub fn new() -> GetAdditionalDatanodeResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for GetAdditionalDatanodeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAdditionalDatanodeResponseProto {
        GetAdditionalDatanodeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    |m: &GetAdditionalDatanodeResponseProto| { &m.block },
                    |m: &mut GetAdditionalDatanodeResponseProto| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAdditionalDatanodeResponseProto>(
                    "GetAdditionalDatanodeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAdditionalDatanodeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetAdditionalDatanodeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAdditionalDatanodeResponseProto,
        };
        unsafe {
            instance.get(GetAdditionalDatanodeResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetAdditionalDatanodeResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAdditionalDatanodeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAdditionalDatanodeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    last: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteRequestProto {
    fn default() -> &'a CompleteRequestProto {
        <CompleteRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CompleteRequestProto {
    pub fn new() -> CompleteRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ExtendedBlockProto last = 3;


    pub fn get_last(&self) -> &super::hdfs::ExtendedBlockProto {
        self.last.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_last(&mut self) {
        self.last.clear();
    }

    pub fn has_last(&self) -> bool {
        self.last.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.last = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.last.is_none() {
            self.last.set_default();
        }
        self.last.as_mut().unwrap()
    }

    // Take field
    pub fn take_last(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.last.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CompleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.last {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.last.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.last.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteRequestProto {
        CompleteRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &CompleteRequestProto| { &m.src },
                    |m: &mut CompleteRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &CompleteRequestProto| { &m.clientName },
                    |m: &mut CompleteRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "last",
                    |m: &CompleteRequestProto| { &m.last },
                    |m: &mut CompleteRequestProto| { &mut m.last },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &CompleteRequestProto| { &m.fileId },
                    |m: &mut CompleteRequestProto| { &mut m.fileId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteRequestProto>(
                    "CompleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteRequestProto,
        };
        unsafe {
            instance.get(CompleteRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for CompleteRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.last.clear();
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteResponseProto {
    fn default() -> &'a CompleteResponseProto {
        <CompleteResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CompleteResponseProto {
    pub fn new() -> CompleteResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CompleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteResponseProto {
        CompleteResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &CompleteResponseProto| { &m.result },
                    |m: &mut CompleteResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteResponseProto>(
                    "CompleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CompleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteResponseProto,
        };
        unsafe {
            instance.get(CompleteResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for CompleteResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksRequestProto {
    // message fields
    blocks: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksRequestProto {
    fn default() -> &'a ReportBadBlocksRequestProto {
        <ReportBadBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksRequestProto {
    pub fn new() -> ReportBadBlocksRequestProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 1;


    pub fn get_blocks(&self) -> &[super::hdfs::LocatedBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<super::hdfs::LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReportBadBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksRequestProto {
        ReportBadBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "blocks",
                    |m: &ReportBadBlocksRequestProto| { &m.blocks },
                    |m: &mut ReportBadBlocksRequestProto| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksRequestProto>(
                    "ReportBadBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReportBadBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksRequestProto,
        };
        unsafe {
            instance.get(ReportBadBlocksRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksRequestProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReportBadBlocksResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReportBadBlocksResponseProto {
    fn default() -> &'a ReportBadBlocksResponseProto {
        <ReportBadBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReportBadBlocksResponseProto {
    pub fn new() -> ReportBadBlocksResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ReportBadBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReportBadBlocksResponseProto {
        ReportBadBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ReportBadBlocksResponseProto>(
                    "ReportBadBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReportBadBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ReportBadBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReportBadBlocksResponseProto,
        };
        unsafe {
            instance.get(ReportBadBlocksResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ReportBadBlocksResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReportBadBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReportBadBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatRequestProto {
    // message fields
    trg: ::protobuf::SingularField<::std::string::String>,
    srcs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcatRequestProto {
    fn default() -> &'a ConcatRequestProto {
        <ConcatRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ConcatRequestProto {
    pub fn new() -> ConcatRequestProto {
        ::std::default::Default::default()
    }

    // required string trg = 1;


    pub fn get_trg(&self) -> &str {
        match self.trg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_trg(&mut self) {
        self.trg.clear();
    }

    pub fn has_trg(&self) -> bool {
        self.trg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trg(&mut self, v: ::std::string::String) {
        self.trg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trg(&mut self) -> &mut ::std::string::String {
        if self.trg.is_none() {
            self.trg.set_default();
        }
        self.trg.as_mut().unwrap()
    }

    // Take field
    pub fn take_trg(&mut self) -> ::std::string::String {
        self.trg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string srcs = 2;


    pub fn get_srcs(&self) -> &[::std::string::String] {
        &self.srcs
    }
    pub fn clear_srcs(&mut self) {
        self.srcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_srcs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.srcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_srcs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.srcs
    }

    // Take field
    pub fn take_srcs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.srcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConcatRequestProto {
    fn is_initialized(&self) -> bool {
        if self.trg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.trg)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.srcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.srcs {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trg.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.srcs {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcatRequestProto {
        ConcatRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "trg",
                    |m: &ConcatRequestProto| { &m.trg },
                    |m: &mut ConcatRequestProto| { &mut m.trg },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "srcs",
                    |m: &ConcatRequestProto| { &m.srcs },
                    |m: &mut ConcatRequestProto| { &mut m.srcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConcatRequestProto>(
                    "ConcatRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConcatRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatRequestProto,
        };
        unsafe {
            instance.get(ConcatRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ConcatRequestProto {
    fn clear(&mut self) {
        self.trg.clear();
        self.srcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConcatResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConcatResponseProto {
    fn default() -> &'a ConcatResponseProto {
        <ConcatResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ConcatResponseProto {
    pub fn new() -> ConcatResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConcatResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConcatResponseProto {
        ConcatResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConcatResponseProto>(
                    "ConcatResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConcatResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ConcatResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConcatResponseProto,
        };
        unsafe {
            instance.get(ConcatResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ConcatResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConcatResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConcatResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    newLength: ::std::option::Option<u64>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncateRequestProto {
    fn default() -> &'a TruncateRequestProto {
        <TruncateRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl TruncateRequestProto {
    pub fn new() -> TruncateRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 newLength = 2;


    pub fn get_newLength(&self) -> u64 {
        self.newLength.unwrap_or(0)
    }
    pub fn clear_newLength(&mut self) {
        self.newLength = ::std::option::Option::None;
    }

    pub fn has_newLength(&self) -> bool {
        self.newLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newLength(&mut self, v: u64) {
        self.newLength = ::std::option::Option::Some(v);
    }

    // required string clientName = 3;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TruncateRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.newLength.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newLength = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.newLength {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.newLength {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncateRequestProto {
        TruncateRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &TruncateRequestProto| { &m.src },
                    |m: &mut TruncateRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newLength",
                    |m: &TruncateRequestProto| { &m.newLength },
                    |m: &mut TruncateRequestProto| { &mut m.newLength },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &TruncateRequestProto| { &m.clientName },
                    |m: &mut TruncateRequestProto| { &mut m.clientName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateRequestProto>(
                    "TruncateRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TruncateRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateRequestProto,
        };
        unsafe {
            instance.get(TruncateRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for TruncateRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.newLength = ::std::option::Option::None;
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncateResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncateResponseProto {
    fn default() -> &'a TruncateResponseProto {
        <TruncateResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl TruncateResponseProto {
    pub fn new() -> TruncateResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TruncateResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncateResponseProto {
        TruncateResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &TruncateResponseProto| { &m.result },
                    |m: &mut TruncateResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TruncateResponseProto>(
                    "TruncateResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TruncateResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<TruncateResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TruncateResponseProto,
        };
        unsafe {
            instance.get(TruncateResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for TruncateResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncateResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncateResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameRequestProto {
    fn default() -> &'a RenameRequestProto {
        <RenameRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameRequestProto {
    pub fn new() -> RenameRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string dst = 2;


    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenameRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameRequestProto {
        RenameRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &RenameRequestProto| { &m.src },
                    |m: &mut RenameRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    |m: &RenameRequestProto| { &m.dst },
                    |m: &mut RenameRequestProto| { &mut m.dst },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameRequestProto>(
                    "RenameRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenameRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameRequestProto,
        };
        unsafe {
            instance.get(RenameRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RenameRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.dst.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameResponseProto {
    fn default() -> &'a RenameResponseProto {
        <RenameResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameResponseProto {
    pub fn new() -> RenameResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RenameResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameResponseProto {
        RenameResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &RenameResponseProto| { &m.result },
                    |m: &mut RenameResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameResponseProto>(
                    "RenameResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenameResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameResponseProto,
        };
        unsafe {
            instance.get(RenameResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RenameResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2RequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    dst: ::protobuf::SingularField<::std::string::String>,
    overwriteDest: ::std::option::Option<bool>,
    moveToTrash: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rename2RequestProto {
    fn default() -> &'a Rename2RequestProto {
        <Rename2RequestProto as ::protobuf::Message>::default_instance()
    }
}

impl Rename2RequestProto {
    pub fn new() -> Rename2RequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string dst = 2;


    pub fn get_dst(&self) -> &str {
        match self.dst.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: ::std::string::String) {
        self.dst = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut ::std::string::String {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> ::std::string::String {
        self.dst.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool overwriteDest = 3;


    pub fn get_overwriteDest(&self) -> bool {
        self.overwriteDest.unwrap_or(false)
    }
    pub fn clear_overwriteDest(&mut self) {
        self.overwriteDest = ::std::option::Option::None;
    }

    pub fn has_overwriteDest(&self) -> bool {
        self.overwriteDest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwriteDest(&mut self, v: bool) {
        self.overwriteDest = ::std::option::Option::Some(v);
    }

    // optional bool moveToTrash = 4;


    pub fn get_moveToTrash(&self) -> bool {
        self.moveToTrash.unwrap_or(false)
    }
    pub fn clear_moveToTrash(&mut self) {
        self.moveToTrash = ::std::option::Option::None;
    }

    pub fn has_moveToTrash(&self) -> bool {
        self.moveToTrash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moveToTrash(&mut self, v: bool) {
        self.moveToTrash = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Rename2RequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.dst.is_none() {
            return false;
        }
        if self.overwriteDest.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dst)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.overwriteDest = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.moveToTrash = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.dst.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.overwriteDest {
            my_size += 2;
        }
        if let Some(v) = self.moveToTrash {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.overwriteDest {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.moveToTrash {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rename2RequestProto {
        Rename2RequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &Rename2RequestProto| { &m.src },
                    |m: &mut Rename2RequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst",
                    |m: &Rename2RequestProto| { &m.dst },
                    |m: &mut Rename2RequestProto| { &mut m.dst },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "overwriteDest",
                    |m: &Rename2RequestProto| { &m.overwriteDest },
                    |m: &mut Rename2RequestProto| { &mut m.overwriteDest },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "moveToTrash",
                    |m: &Rename2RequestProto| { &m.moveToTrash },
                    |m: &mut Rename2RequestProto| { &mut m.moveToTrash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Rename2RequestProto>(
                    "Rename2RequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rename2RequestProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2RequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2RequestProto,
        };
        unsafe {
            instance.get(Rename2RequestProto::new)
        }
    }
}

impl ::protobuf::Clear for Rename2RequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.dst.clear();
        self.overwriteDest = ::std::option::Option::None;
        self.moveToTrash = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2RequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2RequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Rename2ResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Rename2ResponseProto {
    fn default() -> &'a Rename2ResponseProto {
        <Rename2ResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl Rename2ResponseProto {
    pub fn new() -> Rename2ResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Rename2ResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Rename2ResponseProto {
        Rename2ResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Rename2ResponseProto>(
                    "Rename2ResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Rename2ResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<Rename2ResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Rename2ResponseProto,
        };
        unsafe {
            instance.get(Rename2ResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for Rename2ResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Rename2ResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Rename2ResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    recursive: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRequestProto {
    fn default() -> &'a DeleteRequestProto {
        <DeleteRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRequestProto {
    pub fn new() -> DeleteRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool recursive = 2;


    pub fn get_recursive(&self) -> bool {
        self.recursive.unwrap_or(false)
    }
    pub fn clear_recursive(&mut self) {
        self.recursive = ::std::option::Option::None;
    }

    pub fn has_recursive(&self) -> bool {
        self.recursive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recursive(&mut self, v: bool) {
        self.recursive = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.recursive.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recursive = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.recursive {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.recursive {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRequestProto {
        DeleteRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &DeleteRequestProto| { &m.src },
                    |m: &mut DeleteRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "recursive",
                    |m: &DeleteRequestProto| { &m.recursive },
                    |m: &mut DeleteRequestProto| { &mut m.recursive },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteRequestProto>(
                    "DeleteRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteRequestProto,
        };
        unsafe {
            instance.get(DeleteRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for DeleteRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.recursive = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteResponseProto {
    fn default() -> &'a DeleteResponseProto {
        <DeleteResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResponseProto {
    pub fn new() -> DeleteResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DeleteResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteResponseProto {
        DeleteResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &DeleteResponseProto| { &m.result },
                    |m: &mut DeleteResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteResponseProto>(
                    "DeleteResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteResponseProto,
        };
        unsafe {
            instance.get(DeleteResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for DeleteResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    masked: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MkdirsRequestProto {
    fn default() -> &'a MkdirsRequestProto {
        <MkdirsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl MkdirsRequestProto {
    pub fn new() -> MkdirsRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto masked = 2;


    pub fn get_masked(&self) -> &super::hdfs::FsPermissionProto {
        self.masked.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }
    pub fn clear_masked(&mut self) {
        self.masked.clear();
    }

    pub fn has_masked(&self) -> bool {
        self.masked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masked(&mut self, v: super::hdfs::FsPermissionProto) {
        self.masked = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masked(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.masked.is_none() {
            self.masked.set_default();
        }
        self.masked.as_mut().unwrap()
    }

    // Take field
    pub fn take_masked(&mut self) -> super::hdfs::FsPermissionProto {
        self.masked.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    // required bool createParent = 3;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MkdirsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.masked.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.masked {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.masked)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.masked.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.masked.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MkdirsRequestProto {
        MkdirsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &MkdirsRequestProto| { &m.src },
                    |m: &mut MkdirsRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "masked",
                    |m: &MkdirsRequestProto| { &m.masked },
                    |m: &mut MkdirsRequestProto| { &mut m.masked },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    |m: &MkdirsRequestProto| { &m.createParent },
                    |m: &mut MkdirsRequestProto| { &mut m.createParent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsRequestProto>(
                    "MkdirsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MkdirsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsRequestProto,
        };
        unsafe {
            instance.get(MkdirsRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for MkdirsRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.masked.clear();
        self.createParent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MkdirsResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MkdirsResponseProto {
    fn default() -> &'a MkdirsResponseProto {
        <MkdirsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl MkdirsResponseProto {
    pub fn new() -> MkdirsResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MkdirsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MkdirsResponseProto {
        MkdirsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &MkdirsResponseProto| { &m.result },
                    |m: &mut MkdirsResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MkdirsResponseProto>(
                    "MkdirsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MkdirsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MkdirsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MkdirsResponseProto,
        };
        unsafe {
            instance.get(MkdirsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for MkdirsResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MkdirsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MkdirsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    startAfter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    needLocation: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListingRequestProto {
    fn default() -> &'a GetListingRequestProto {
        <GetListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetListingRequestProto {
    pub fn new() -> GetListingRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes startAfter = 2;


    pub fn get_startAfter(&self) -> &[u8] {
        match self.startAfter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_startAfter(&mut self) {
        self.startAfter.clear();
    }

    pub fn has_startAfter(&self) -> bool {
        self.startAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startAfter(&mut self, v: ::std::vec::Vec<u8>) {
        self.startAfter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startAfter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.startAfter.is_none() {
            self.startAfter.set_default();
        }
        self.startAfter.as_mut().unwrap()
    }

    // Take field
    pub fn take_startAfter(&mut self) -> ::std::vec::Vec<u8> {
        self.startAfter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool needLocation = 3;


    pub fn get_needLocation(&self) -> bool {
        self.needLocation.unwrap_or(false)
    }
    pub fn clear_needLocation(&mut self) {
        self.needLocation = ::std::option::Option::None;
    }

    pub fn has_needLocation(&self) -> bool {
        self.needLocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needLocation(&mut self, v: bool) {
        self.needLocation = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetListingRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.startAfter.is_none() {
            return false;
        }
        if self.needLocation.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.startAfter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLocation = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.needLocation {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.startAfter.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.needLocation {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListingRequestProto {
        GetListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &GetListingRequestProto| { &m.src },
                    |m: &mut GetListingRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "startAfter",
                    |m: &GetListingRequestProto| { &m.startAfter },
                    |m: &mut GetListingRequestProto| { &mut m.startAfter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needLocation",
                    |m: &GetListingRequestProto| { &m.needLocation },
                    |m: &mut GetListingRequestProto| { &mut m.needLocation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingRequestProto>(
                    "GetListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingRequestProto,
        };
        unsafe {
            instance.get(GetListingRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetListingRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.startAfter.clear();
        self.needLocation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetListingResponseProto {
    // message fields
    dirList: ::protobuf::SingularPtrField<super::hdfs::DirectoryListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetListingResponseProto {
    fn default() -> &'a GetListingResponseProto {
        <GetListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetListingResponseProto {
    pub fn new() -> GetListingResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DirectoryListingProto dirList = 1;


    pub fn get_dirList(&self) -> &super::hdfs::DirectoryListingProto {
        self.dirList.as_ref().unwrap_or_else(|| super::hdfs::DirectoryListingProto::default_instance())
    }
    pub fn clear_dirList(&mut self) {
        self.dirList.clear();
    }

    pub fn has_dirList(&self) -> bool {
        self.dirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirList(&mut self, v: super::hdfs::DirectoryListingProto) {
        self.dirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirList(&mut self) -> &mut super::hdfs::DirectoryListingProto {
        if self.dirList.is_none() {
            self.dirList.set_default();
        }
        self.dirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirList(&mut self) -> super::hdfs::DirectoryListingProto {
        self.dirList.take().unwrap_or_else(|| super::hdfs::DirectoryListingProto::new())
    }
}

impl ::protobuf::Message for GetListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetListingResponseProto {
        GetListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DirectoryListingProto>>(
                    "dirList",
                    |m: &GetListingResponseProto| { &m.dirList },
                    |m: &mut GetListingResponseProto| { &mut m.dirList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetListingResponseProto>(
                    "GetListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetListingResponseProto,
        };
        unsafe {
            instance.get(GetListingResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetListingResponseProto {
    fn clear(&mut self) {
        self.dirList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshottableDirListingRequestProto {
    fn default() -> &'a GetSnapshottableDirListingRequestProto {
        <GetSnapshottableDirListingRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshottableDirListingRequestProto {
    pub fn new() -> GetSnapshottableDirListingRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshottableDirListingRequestProto {
        GetSnapshottableDirListingRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingRequestProto>(
                    "GetSnapshottableDirListingRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSnapshottableDirListingRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingRequestProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshottableDirListingResponseProto {
    // message fields
    snapshottableDirList: ::protobuf::SingularPtrField<super::hdfs::SnapshottableDirectoryListingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshottableDirListingResponseProto {
    fn default() -> &'a GetSnapshottableDirListingResponseProto {
        <GetSnapshottableDirListingResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshottableDirListingResponseProto {
    pub fn new() -> GetSnapshottableDirListingResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.SnapshottableDirectoryListingProto snapshottableDirList = 1;


    pub fn get_snapshottableDirList(&self) -> &super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.as_ref().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::default_instance())
    }
    pub fn clear_snapshottableDirList(&mut self) {
        self.snapshottableDirList.clear();
    }

    pub fn has_snapshottableDirList(&self) -> bool {
        self.snapshottableDirList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirList(&mut self, v: super::hdfs::SnapshottableDirectoryListingProto) {
        self.snapshottableDirList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshottableDirList(&mut self) -> &mut super::hdfs::SnapshottableDirectoryListingProto {
        if self.snapshottableDirList.is_none() {
            self.snapshottableDirList.set_default();
        }
        self.snapshottableDirList.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshottableDirList(&mut self) -> super::hdfs::SnapshottableDirectoryListingProto {
        self.snapshottableDirList.take().unwrap_or_else(|| super::hdfs::SnapshottableDirectoryListingProto::new())
    }
}

impl ::protobuf::Message for GetSnapshottableDirListingResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.snapshottableDirList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshottableDirList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshottableDirListingResponseProto {
        GetSnapshottableDirListingResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshottableDirectoryListingProto>>(
                    "snapshottableDirList",
                    |m: &GetSnapshottableDirListingResponseProto| { &m.snapshottableDirList },
                    |m: &mut GetSnapshottableDirListingResponseProto| { &mut m.snapshottableDirList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshottableDirListingResponseProto>(
                    "GetSnapshottableDirListingResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSnapshottableDirListingResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshottableDirListingResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshottableDirListingResponseProto,
        };
        unsafe {
            instance.get(GetSnapshottableDirListingResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetSnapshottableDirListingResponseProto {
    fn clear(&mut self) {
        self.snapshottableDirList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshottableDirListingResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshottableDirListingResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportRequestProto {
    fn default() -> &'a GetSnapshotDiffReportRequestProto {
        <GetSnapshotDiffReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportRequestProto {
    pub fn new() -> GetSnapshotDiffReportRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fromSnapshot = 2;


    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string toSnapshot = 3;


    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportRequestProto {
        GetSnapshotDiffReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &GetSnapshotDiffReportRequestProto| { &m.snapshotRoot },
                    |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fromSnapshot",
                    |m: &GetSnapshotDiffReportRequestProto| { &m.fromSnapshot },
                    |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.fromSnapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "toSnapshot",
                    |m: &GetSnapshotDiffReportRequestProto| { &m.toSnapshot },
                    |m: &mut GetSnapshotDiffReportRequestProto| { &mut m.toSnapshot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportRequestProto>(
                    "GetSnapshotDiffReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSnapshotDiffReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportRequestProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.fromSnapshot.clear();
        self.toSnapshot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSnapshotDiffReportResponseProto {
    // message fields
    diffReport: ::protobuf::SingularPtrField<super::hdfs::SnapshotDiffReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSnapshotDiffReportResponseProto {
    fn default() -> &'a GetSnapshotDiffReportResponseProto {
        <GetSnapshotDiffReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetSnapshotDiffReportResponseProto {
    pub fn new() -> GetSnapshotDiffReportResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SnapshotDiffReportProto diffReport = 1;


    pub fn get_diffReport(&self) -> &super::hdfs::SnapshotDiffReportProto {
        self.diffReport.as_ref().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::default_instance())
    }
    pub fn clear_diffReport(&mut self) {
        self.diffReport.clear();
    }

    pub fn has_diffReport(&self) -> bool {
        self.diffReport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diffReport(&mut self, v: super::hdfs::SnapshotDiffReportProto) {
        self.diffReport = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diffReport(&mut self) -> &mut super::hdfs::SnapshotDiffReportProto {
        if self.diffReport.is_none() {
            self.diffReport.set_default();
        }
        self.diffReport.as_mut().unwrap()
    }

    // Take field
    pub fn take_diffReport(&mut self) -> super::hdfs::SnapshotDiffReportProto {
        self.diffReport.take().unwrap_or_else(|| super::hdfs::SnapshotDiffReportProto::new())
    }
}

impl ::protobuf::Message for GetSnapshotDiffReportResponseProto {
    fn is_initialized(&self) -> bool {
        if self.diffReport.is_none() {
            return false;
        }
        for v in &self.diffReport {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.diffReport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diffReport.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diffReport.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSnapshotDiffReportResponseProto {
        GetSnapshotDiffReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::SnapshotDiffReportProto>>(
                    "diffReport",
                    |m: &GetSnapshotDiffReportResponseProto| { &m.diffReport },
                    |m: &mut GetSnapshotDiffReportResponseProto| { &mut m.diffReport },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSnapshotDiffReportResponseProto>(
                    "GetSnapshotDiffReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSnapshotDiffReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetSnapshotDiffReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSnapshotDiffReportResponseProto,
        };
        unsafe {
            instance.get(GetSnapshotDiffReportResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetSnapshotDiffReportResponseProto {
    fn clear(&mut self) {
        self.diffReport.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSnapshotDiffReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSnapshotDiffReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenewLeaseRequestProto {
    fn default() -> &'a RenewLeaseRequestProto {
        <RenewLeaseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenewLeaseRequestProto {
    pub fn new() -> RenewLeaseRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenewLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenewLeaseRequestProto {
        RenewLeaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &RenewLeaseRequestProto| { &m.clientName },
                    |m: &mut RenewLeaseRequestProto| { &mut m.clientName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseRequestProto>(
                    "RenewLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenewLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseRequestProto,
        };
        unsafe {
            instance.get(RenewLeaseRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RenewLeaseRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenewLeaseResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenewLeaseResponseProto {
    fn default() -> &'a RenewLeaseResponseProto {
        <RenewLeaseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenewLeaseResponseProto {
    pub fn new() -> RenewLeaseResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RenewLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenewLeaseResponseProto {
        RenewLeaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenewLeaseResponseProto>(
                    "RenewLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenewLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenewLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenewLeaseResponseProto,
        };
        unsafe {
            instance.get(RenewLeaseResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RenewLeaseResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenewLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenewLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoverLeaseRequestProto {
    fn default() -> &'a RecoverLeaseRequestProto {
        <RecoverLeaseRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RecoverLeaseRequestProto {
    pub fn new() -> RecoverLeaseRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RecoverLeaseRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoverLeaseRequestProto {
        RecoverLeaseRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &RecoverLeaseRequestProto| { &m.src },
                    |m: &mut RecoverLeaseRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &RecoverLeaseRequestProto| { &m.clientName },
                    |m: &mut RecoverLeaseRequestProto| { &mut m.clientName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseRequestProto>(
                    "RecoverLeaseRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RecoverLeaseRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseRequestProto,
        };
        unsafe {
            instance.get(RecoverLeaseRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoverLeaseResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoverLeaseResponseProto {
    fn default() -> &'a RecoverLeaseResponseProto {
        <RecoverLeaseResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RecoverLeaseResponseProto {
    pub fn new() -> RecoverLeaseResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RecoverLeaseResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoverLeaseResponseProto {
        RecoverLeaseResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &RecoverLeaseResponseProto| { &m.result },
                    |m: &mut RecoverLeaseResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoverLeaseResponseProto>(
                    "RecoverLeaseResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RecoverLeaseResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoverLeaseResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoverLeaseResponseProto,
        };
        unsafe {
            instance.get(RecoverLeaseResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RecoverLeaseResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoverLeaseResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoverLeaseResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatusRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsStatusRequestProto {
    fn default() -> &'a GetFsStatusRequestProto {
        <GetFsStatusRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsStatusRequestProto {
    pub fn new() -> GetFsStatusRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFsStatusRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsStatusRequestProto {
        GetFsStatusRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatusRequestProto>(
                    "GetFsStatusRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFsStatusRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatusRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatusRequestProto,
        };
        unsafe {
            instance.get(GetFsStatusRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFsStatusRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatusRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatusRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFsStatsResponseProto {
    // message fields
    capacity: ::std::option::Option<u64>,
    used: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    under_replicated: ::std::option::Option<u64>,
    corrupt_blocks: ::std::option::Option<u64>,
    missing_blocks: ::std::option::Option<u64>,
    missing_repl_one_blocks: ::std::option::Option<u64>,
    blocks_in_future: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFsStatsResponseProto {
    fn default() -> &'a GetFsStatsResponseProto {
        <GetFsStatsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFsStatsResponseProto {
    pub fn new() -> GetFsStatsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 capacity = 1;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // required uint64 used = 2;


    pub fn get_used(&self) -> u64 {
        self.used.unwrap_or(0)
    }
    pub fn clear_used(&mut self) {
        self.used = ::std::option::Option::None;
    }

    pub fn has_used(&self) -> bool {
        self.used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: u64) {
        self.used = ::std::option::Option::Some(v);
    }

    // required uint64 remaining = 3;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // required uint64 under_replicated = 4;


    pub fn get_under_replicated(&self) -> u64 {
        self.under_replicated.unwrap_or(0)
    }
    pub fn clear_under_replicated(&mut self) {
        self.under_replicated = ::std::option::Option::None;
    }

    pub fn has_under_replicated(&self) -> bool {
        self.under_replicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_under_replicated(&mut self, v: u64) {
        self.under_replicated = ::std::option::Option::Some(v);
    }

    // required uint64 corrupt_blocks = 5;


    pub fn get_corrupt_blocks(&self) -> u64 {
        self.corrupt_blocks.unwrap_or(0)
    }
    pub fn clear_corrupt_blocks(&mut self) {
        self.corrupt_blocks = ::std::option::Option::None;
    }

    pub fn has_corrupt_blocks(&self) -> bool {
        self.corrupt_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt_blocks(&mut self, v: u64) {
        self.corrupt_blocks = ::std::option::Option::Some(v);
    }

    // required uint64 missing_blocks = 6;


    pub fn get_missing_blocks(&self) -> u64 {
        self.missing_blocks.unwrap_or(0)
    }
    pub fn clear_missing_blocks(&mut self) {
        self.missing_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_blocks(&self) -> bool {
        self.missing_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_blocks(&mut self, v: u64) {
        self.missing_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 missing_repl_one_blocks = 7;


    pub fn get_missing_repl_one_blocks(&self) -> u64 {
        self.missing_repl_one_blocks.unwrap_or(0)
    }
    pub fn clear_missing_repl_one_blocks(&mut self) {
        self.missing_repl_one_blocks = ::std::option::Option::None;
    }

    pub fn has_missing_repl_one_blocks(&self) -> bool {
        self.missing_repl_one_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_repl_one_blocks(&mut self, v: u64) {
        self.missing_repl_one_blocks = ::std::option::Option::Some(v);
    }

    // optional uint64 blocks_in_future = 8;


    pub fn get_blocks_in_future(&self) -> u64 {
        self.blocks_in_future.unwrap_or(0)
    }
    pub fn clear_blocks_in_future(&mut self) {
        self.blocks_in_future = ::std::option::Option::None;
    }

    pub fn has_blocks_in_future(&self) -> bool {
        self.blocks_in_future.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocks_in_future(&mut self, v: u64) {
        self.blocks_in_future = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetFsStatsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.capacity.is_none() {
            return false;
        }
        if self.used.is_none() {
            return false;
        }
        if self.remaining.is_none() {
            return false;
        }
        if self.under_replicated.is_none() {
            return false;
        }
        if self.corrupt_blocks.is_none() {
            return false;
        }
        if self.missing_blocks.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.used = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.under_replicated = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.corrupt_blocks = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.missing_repl_one_blocks = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocks_in_future = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.used {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.under_replicated {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.corrupt_blocks {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_blocks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.missing_repl_one_blocks {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocks_in_future {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.capacity {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.used {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.under_replicated {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.corrupt_blocks {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.missing_blocks {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.missing_repl_one_blocks {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.blocks_in_future {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFsStatsResponseProto {
        GetFsStatsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    |m: &GetFsStatsResponseProto| { &m.capacity },
                    |m: &mut GetFsStatsResponseProto| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "used",
                    |m: &GetFsStatsResponseProto| { &m.used },
                    |m: &mut GetFsStatsResponseProto| { &mut m.used },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining",
                    |m: &GetFsStatsResponseProto| { &m.remaining },
                    |m: &mut GetFsStatsResponseProto| { &mut m.remaining },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "under_replicated",
                    |m: &GetFsStatsResponseProto| { &m.under_replicated },
                    |m: &mut GetFsStatsResponseProto| { &mut m.under_replicated },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "corrupt_blocks",
                    |m: &GetFsStatsResponseProto| { &m.corrupt_blocks },
                    |m: &mut GetFsStatsResponseProto| { &mut m.corrupt_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_blocks",
                    |m: &GetFsStatsResponseProto| { &m.missing_blocks },
                    |m: &mut GetFsStatsResponseProto| { &mut m.missing_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "missing_repl_one_blocks",
                    |m: &GetFsStatsResponseProto| { &m.missing_repl_one_blocks },
                    |m: &mut GetFsStatsResponseProto| { &mut m.missing_repl_one_blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocks_in_future",
                    |m: &GetFsStatsResponseProto| { &m.blocks_in_future },
                    |m: &mut GetFsStatsResponseProto| { &mut m.blocks_in_future },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFsStatsResponseProto>(
                    "GetFsStatsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFsStatsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFsStatsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFsStatsResponseProto,
        };
        unsafe {
            instance.get(GetFsStatsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFsStatsResponseProto {
    fn clear(&mut self) {
        self.capacity = ::std::option::Option::None;
        self.used = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.under_replicated = ::std::option::Option::None;
        self.corrupt_blocks = ::std::option::Option::None;
        self.missing_blocks = ::std::option::Option::None;
        self.missing_repl_one_blocks = ::std::option::Option::None;
        self.blocks_in_future = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFsStatsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFsStatsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeReportRequestProto {
    fn default() -> &'a GetDatanodeReportRequestProto {
        <GetDatanodeReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeReportRequestProto {
    pub fn new() -> GetDatanodeReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;


    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetDatanodeReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeReportRequestProto {
        GetDatanodeReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    |m: &GetDatanodeReportRequestProto| { &m.field_type },
                    |m: &mut GetDatanodeReportRequestProto| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportRequestProto>(
                    "GetDatanodeReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDatanodeReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeReportRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportRequestProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeReportResponseProto {
    // message fields
    di: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeReportResponseProto {
    fn default() -> &'a GetDatanodeReportResponseProto {
        <GetDatanodeReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeReportResponseProto {
    pub fn new() -> GetDatanodeReportResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto di = 1;


    pub fn get_di(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.di
    }
    pub fn clear_di(&mut self) {
        self.di.clear();
    }

    // Param is passed by value, moved
    pub fn set_di(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.di = v;
    }

    // Mutable pointer to the field.
    pub fn mut_di(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.di
    }

    // Take field
    pub fn take_di(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.di, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDatanodeReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.di {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.di)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.di {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.di {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeReportResponseProto {
        GetDatanodeReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "di",
                    |m: &GetDatanodeReportResponseProto| { &m.di },
                    |m: &mut GetDatanodeReportResponseProto| { &mut m.di },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeReportResponseProto>(
                    "GetDatanodeReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDatanodeReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeReportResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDatanodeReportResponseProto {
    fn clear(&mut self) {
        self.di.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportRequestProto {
    // message fields
    field_type: ::std::option::Option<DatanodeReportTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeStorageReportRequestProto {
    fn default() -> &'a GetDatanodeStorageReportRequestProto {
        <GetDatanodeStorageReportRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeStorageReportRequestProto {
    pub fn new() -> GetDatanodeStorageReportRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeReportTypeProto type = 1;


    pub fn get_field_type(&self) -> DatanodeReportTypeProto {
        self.field_type.unwrap_or(DatanodeReportTypeProto::ALL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DatanodeReportTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportRequestProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeStorageReportRequestProto {
        GetDatanodeStorageReportRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeReportTypeProto>>(
                    "type",
                    |m: &GetDatanodeStorageReportRequestProto| { &m.field_type },
                    |m: &mut GetDatanodeStorageReportRequestProto| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportRequestProto>(
                    "GetDatanodeStorageReportRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDatanodeStorageReportRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportRequestProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportRequestProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageReportProto {
    // message fields
    datanodeInfo: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    storageReports: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeStorageReportProto {
    fn default() -> &'a DatanodeStorageReportProto {
        <DatanodeStorageReportProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeStorageReportProto {
    pub fn new() -> DatanodeStorageReportProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeInfoProto datanodeInfo = 1;


    pub fn get_datanodeInfo(&self) -> &super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.as_ref().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::default_instance())
    }
    pub fn clear_datanodeInfo(&mut self) {
        self.datanodeInfo.clear();
    }

    pub fn has_datanodeInfo(&self) -> bool {
        self.datanodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeInfo(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.datanodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeInfo(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.datanodeInfo.is_none() {
            self.datanodeInfo.set_default();
        }
        self.datanodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeInfo(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.datanodeInfo.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // repeated .hadoop.hdfs.StorageReportProto storageReports = 2;


    pub fn get_storageReports(&self) -> &[super::hdfs::StorageReportProto] {
        &self.storageReports
    }
    pub fn clear_storageReports(&mut self) {
        self.storageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageReports(&mut self, v: ::protobuf::RepeatedField<super::hdfs::StorageReportProto>) {
        self.storageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageReports(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        &mut self.storageReports
    }

    // Take field
    pub fn take_storageReports(&mut self) -> ::protobuf::RepeatedField<super::hdfs::StorageReportProto> {
        ::std::mem::replace(&mut self.storageReports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatanodeStorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.datanodeInfo.is_none() {
            return false;
        }
        for v in &self.datanodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.datanodeInfo)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.storageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.storageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datanodeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.storageReports {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeStorageReportProto {
        DatanodeStorageReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "datanodeInfo",
                    |m: &DatanodeStorageReportProto| { &m.datanodeInfo },
                    |m: &mut DatanodeStorageReportProto| { &mut m.datanodeInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::StorageReportProto>>(
                    "storageReports",
                    |m: &DatanodeStorageReportProto| { &m.storageReports },
                    |m: &mut DatanodeStorageReportProto| { &mut m.storageReports },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeStorageReportProto>(
                    "DatanodeStorageReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeStorageReportProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeStorageReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeStorageReportProto,
        };
        unsafe {
            instance.get(DatanodeStorageReportProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeStorageReportProto {
    fn clear(&mut self) {
        self.datanodeInfo.clear();
        self.storageReports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDatanodeStorageReportResponseProto {
    // message fields
    datanodeStorageReports: ::protobuf::RepeatedField<DatanodeStorageReportProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDatanodeStorageReportResponseProto {
    fn default() -> &'a GetDatanodeStorageReportResponseProto {
        <GetDatanodeStorageReportResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDatanodeStorageReportResponseProto {
    pub fn new() -> GetDatanodeStorageReportResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeStorageReportProto datanodeStorageReports = 1;


    pub fn get_datanodeStorageReports(&self) -> &[DatanodeStorageReportProto] {
        &self.datanodeStorageReports
    }
    pub fn clear_datanodeStorageReports(&mut self) {
        self.datanodeStorageReports.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeStorageReports(&mut self, v: ::protobuf::RepeatedField<DatanodeStorageReportProto>) {
        self.datanodeStorageReports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeStorageReports(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        &mut self.datanodeStorageReports
    }

    // Take field
    pub fn take_datanodeStorageReports(&mut self) -> ::protobuf::RepeatedField<DatanodeStorageReportProto> {
        ::std::mem::replace(&mut self.datanodeStorageReports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDatanodeStorageReportResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodeStorageReports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodeStorageReports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodeStorageReports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodeStorageReports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDatanodeStorageReportResponseProto {
        GetDatanodeStorageReportResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageReportProto>>(
                    "datanodeStorageReports",
                    |m: &GetDatanodeStorageReportResponseProto| { &m.datanodeStorageReports },
                    |m: &mut GetDatanodeStorageReportResponseProto| { &mut m.datanodeStorageReports },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDatanodeStorageReportResponseProto>(
                    "GetDatanodeStorageReportResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDatanodeStorageReportResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDatanodeStorageReportResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDatanodeStorageReportResponseProto,
        };
        unsafe {
            instance.get(GetDatanodeStorageReportResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDatanodeStorageReportResponseProto {
    fn clear(&mut self) {
        self.datanodeStorageReports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDatanodeStorageReportResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDatanodeStorageReportResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPreferredBlockSizeRequestProto {
    fn default() -> &'a GetPreferredBlockSizeRequestProto {
        <GetPreferredBlockSizeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredBlockSizeRequestProto {
    pub fn new() -> GetPreferredBlockSizeRequestProto {
        ::std::default::Default::default()
    }

    // required string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPreferredBlockSizeRequestProto {
        GetPreferredBlockSizeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &GetPreferredBlockSizeRequestProto| { &m.filename },
                    |m: &mut GetPreferredBlockSizeRequestProto| { &mut m.filename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeRequestProto>(
                    "GetPreferredBlockSizeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPreferredBlockSizeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeRequestProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeRequestProto {
    fn clear(&mut self) {
        self.filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPreferredBlockSizeResponseProto {
    // message fields
    bsize: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPreferredBlockSizeResponseProto {
    fn default() -> &'a GetPreferredBlockSizeResponseProto {
        <GetPreferredBlockSizeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetPreferredBlockSizeResponseProto {
    pub fn new() -> GetPreferredBlockSizeResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 bsize = 1;


    pub fn get_bsize(&self) -> u64 {
        self.bsize.unwrap_or(0)
    }
    pub fn clear_bsize(&mut self) {
        self.bsize = ::std::option::Option::None;
    }

    pub fn has_bsize(&self) -> bool {
        self.bsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bsize(&mut self, v: u64) {
        self.bsize = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetPreferredBlockSizeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bsize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bsize = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bsize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bsize {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPreferredBlockSizeResponseProto {
        GetPreferredBlockSizeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bsize",
                    |m: &GetPreferredBlockSizeResponseProto| { &m.bsize },
                    |m: &mut GetPreferredBlockSizeResponseProto| { &mut m.bsize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPreferredBlockSizeResponseProto>(
                    "GetPreferredBlockSizeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPreferredBlockSizeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetPreferredBlockSizeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPreferredBlockSizeResponseProto,
        };
        unsafe {
            instance.get(GetPreferredBlockSizeResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetPreferredBlockSizeResponseProto {
    fn clear(&mut self) {
        self.bsize = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPreferredBlockSizeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPreferredBlockSizeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeRequestProto {
    // message fields
    action: ::std::option::Option<SafeModeActionProto>,
    checked: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSafeModeRequestProto {
    fn default() -> &'a SetSafeModeRequestProto {
        <SetSafeModeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetSafeModeRequestProto {
    pub fn new() -> SetSafeModeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.SafeModeActionProto action = 1;


    pub fn get_action(&self) -> SafeModeActionProto {
        self.action.unwrap_or(SafeModeActionProto::SAFEMODE_LEAVE)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SafeModeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }

    // optional bool checked = 2;


    pub fn get_checked(&self) -> bool {
        self.checked.unwrap_or(false)
    }
    pub fn clear_checked(&mut self) {
        self.checked = ::std::option::Option::None;
    }

    pub fn has_checked(&self) -> bool {
        self.checked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked(&mut self, v: bool) {
        self.checked = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetSafeModeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.checked = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.checked {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.checked {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSafeModeRequestProto {
        SetSafeModeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SafeModeActionProto>>(
                    "action",
                    |m: &SetSafeModeRequestProto| { &m.action },
                    |m: &mut SetSafeModeRequestProto| { &mut m.action },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "checked",
                    |m: &SetSafeModeRequestProto| { &m.checked },
                    |m: &mut SetSafeModeRequestProto| { &mut m.checked },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeRequestProto>(
                    "SetSafeModeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetSafeModeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeRequestProto,
        };
        unsafe {
            instance.get(SetSafeModeRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetSafeModeRequestProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.checked = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSafeModeResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSafeModeResponseProto {
    fn default() -> &'a SetSafeModeResponseProto {
        <SetSafeModeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetSafeModeResponseProto {
    pub fn new() -> SetSafeModeResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetSafeModeResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSafeModeResponseProto {
        SetSafeModeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &SetSafeModeResponseProto| { &m.result },
                    |m: &mut SetSafeModeResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSafeModeResponseProto>(
                    "SetSafeModeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetSafeModeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetSafeModeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSafeModeResponseProto,
        };
        unsafe {
            instance.get(SetSafeModeResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetSafeModeResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSafeModeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSafeModeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SaveNamespaceRequestProto {
    fn default() -> &'a SaveNamespaceRequestProto {
        <SaveNamespaceRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SaveNamespaceRequestProto {
    pub fn new() -> SaveNamespaceRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SaveNamespaceRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SaveNamespaceRequestProto {
        SaveNamespaceRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceRequestProto>(
                    "SaveNamespaceRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SaveNamespaceRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceRequestProto,
        };
        unsafe {
            instance.get(SaveNamespaceRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SaveNamespaceResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SaveNamespaceResponseProto {
    fn default() -> &'a SaveNamespaceResponseProto {
        <SaveNamespaceResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SaveNamespaceResponseProto {
    pub fn new() -> SaveNamespaceResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SaveNamespaceResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SaveNamespaceResponseProto {
        SaveNamespaceResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SaveNamespaceResponseProto>(
                    "SaveNamespaceResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SaveNamespaceResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SaveNamespaceResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SaveNamespaceResponseProto,
        };
        unsafe {
            instance.get(SaveNamespaceResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SaveNamespaceResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SaveNamespaceResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SaveNamespaceResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditsRequestProto {
    fn default() -> &'a RollEditsRequestProto {
        <RollEditsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditsRequestProto {
    pub fn new() -> RollEditsRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RollEditsRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditsRequestProto {
        RollEditsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsRequestProto>(
                    "RollEditsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollEditsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsRequestProto,
        };
        unsafe {
            instance.get(RollEditsRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RollEditsRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollEditsResponseProto {
    // message fields
    newSegmentTxId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollEditsResponseProto {
    fn default() -> &'a RollEditsResponseProto {
        <RollEditsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RollEditsResponseProto {
    pub fn new() -> RollEditsResponseProto {
        ::std::default::Default::default()
    }

    // required uint64 newSegmentTxId = 1;


    pub fn get_newSegmentTxId(&self) -> u64 {
        self.newSegmentTxId.unwrap_or(0)
    }
    pub fn clear_newSegmentTxId(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_newSegmentTxId(&self) -> bool {
        self.newSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newSegmentTxId(&mut self, v: u64) {
        self.newSegmentTxId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollEditsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.newSegmentTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newSegmentTxId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newSegmentTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newSegmentTxId {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollEditsResponseProto {
        RollEditsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newSegmentTxId",
                    |m: &RollEditsResponseProto| { &m.newSegmentTxId },
                    |m: &mut RollEditsResponseProto| { &mut m.newSegmentTxId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollEditsResponseProto>(
                    "RollEditsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollEditsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollEditsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollEditsResponseProto,
        };
        unsafe {
            instance.get(RollEditsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RollEditsResponseProto {
    fn clear(&mut self) {
        self.newSegmentTxId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollEditsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollEditsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageRequestProto {
    // message fields
    arg: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreFailedStorageRequestProto {
    fn default() -> &'a RestoreFailedStorageRequestProto {
        <RestoreFailedStorageRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreFailedStorageRequestProto {
    pub fn new() -> RestoreFailedStorageRequestProto {
        ::std::default::Default::default()
    }

    // required string arg = 1;


    pub fn get_arg(&self) -> &str {
        match self.arg.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    pub fn has_arg(&self) -> bool {
        self.arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::std::string::String) {
        self.arg = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_arg(&mut self) -> &mut ::std::string::String {
        if self.arg.is_none() {
            self.arg.set_default();
        }
        self.arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_arg(&mut self) -> ::std::string::String {
        self.arg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RestoreFailedStorageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.arg.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.arg.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.arg.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreFailedStorageRequestProto {
        RestoreFailedStorageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "arg",
                    |m: &RestoreFailedStorageRequestProto| { &m.arg },
                    |m: &mut RestoreFailedStorageRequestProto| { &mut m.arg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageRequestProto>(
                    "RestoreFailedStorageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestoreFailedStorageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageRequestProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageRequestProto {
    fn clear(&mut self) {
        self.arg.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RestoreFailedStorageResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RestoreFailedStorageResponseProto {
    fn default() -> &'a RestoreFailedStorageResponseProto {
        <RestoreFailedStorageResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RestoreFailedStorageResponseProto {
    pub fn new() -> RestoreFailedStorageResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RestoreFailedStorageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RestoreFailedStorageResponseProto {
        RestoreFailedStorageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &RestoreFailedStorageResponseProto| { &m.result },
                    |m: &mut RestoreFailedStorageResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RestoreFailedStorageResponseProto>(
                    "RestoreFailedStorageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RestoreFailedStorageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RestoreFailedStorageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RestoreFailedStorageResponseProto,
        };
        unsafe {
            instance.get(RestoreFailedStorageResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RestoreFailedStorageResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RestoreFailedStorageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RestoreFailedStorageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefreshNodesRequestProto {
    fn default() -> &'a RefreshNodesRequestProto {
        <RefreshNodesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RefreshNodesRequestProto {
    pub fn new() -> RefreshNodesRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RefreshNodesRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefreshNodesRequestProto {
        RefreshNodesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesRequestProto>(
                    "RefreshNodesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RefreshNodesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesRequestProto,
        };
        unsafe {
            instance.get(RefreshNodesRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RefreshNodesRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RefreshNodesResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RefreshNodesResponseProto {
    fn default() -> &'a RefreshNodesResponseProto {
        <RefreshNodesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RefreshNodesResponseProto {
    pub fn new() -> RefreshNodesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RefreshNodesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RefreshNodesResponseProto {
        RefreshNodesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RefreshNodesResponseProto>(
                    "RefreshNodesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RefreshNodesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RefreshNodesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RefreshNodesResponseProto,
        };
        unsafe {
            instance.get(RefreshNodesResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RefreshNodesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RefreshNodesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RefreshNodesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeUpgradeRequestProto {
    fn default() -> &'a FinalizeUpgradeRequestProto {
        <FinalizeUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeUpgradeRequestProto {
    pub fn new() -> FinalizeUpgradeRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FinalizeUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeUpgradeRequestProto {
        FinalizeUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeRequestProto>(
                    "FinalizeUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FinalizeUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeRequestProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinalizeUpgradeResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinalizeUpgradeResponseProto {
    fn default() -> &'a FinalizeUpgradeResponseProto {
        <FinalizeUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FinalizeUpgradeResponseProto {
    pub fn new() -> FinalizeUpgradeResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FinalizeUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinalizeUpgradeResponseProto {
        FinalizeUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FinalizeUpgradeResponseProto>(
                    "FinalizeUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FinalizeUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FinalizeUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FinalizeUpgradeResponseProto,
        };
        unsafe {
            instance.get(FinalizeUpgradeResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for FinalizeUpgradeResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinalizeUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinalizeUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeRequestProto {
    // message fields
    action: ::std::option::Option<RollingUpgradeActionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeRequestProto {
    fn default() -> &'a RollingUpgradeRequestProto {
        <RollingUpgradeRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeRequestProto {
    pub fn new() -> RollingUpgradeRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RollingUpgradeActionProto action = 1;


    pub fn get_action(&self) -> RollingUpgradeActionProto {
        self.action.unwrap_or(RollingUpgradeActionProto::QUERY)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RollingUpgradeActionProto) {
        self.action = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeRequestProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeRequestProto {
        RollingUpgradeRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RollingUpgradeActionProto>>(
                    "action",
                    |m: &RollingUpgradeRequestProto| { &m.action },
                    |m: &mut RollingUpgradeRequestProto| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeRequestProto>(
                    "RollingUpgradeRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollingUpgradeRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeRequestProto,
        };
        unsafe {
            instance.get(RollingUpgradeRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeRequestProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeInfoProto {
    // message fields
    status: ::protobuf::SingularPtrField<super::hdfs::RollingUpgradeStatusProto>,
    startTime: ::std::option::Option<u64>,
    finalizeTime: ::std::option::Option<u64>,
    createdRollbackImages: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeInfoProto {
    fn default() -> &'a RollingUpgradeInfoProto {
        <RollingUpgradeInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeInfoProto {
    pub fn new() -> RollingUpgradeInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.RollingUpgradeStatusProto status = 1;


    pub fn get_status(&self) -> &super::hdfs::RollingUpgradeStatusProto {
        self.status.as_ref().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::hdfs::RollingUpgradeStatusProto) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::hdfs::RollingUpgradeStatusProto {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::hdfs::RollingUpgradeStatusProto {
        self.status.take().unwrap_or_else(|| super::hdfs::RollingUpgradeStatusProto::new())
    }

    // required uint64 startTime = 2;


    pub fn get_startTime(&self) -> u64 {
        self.startTime.unwrap_or(0)
    }
    pub fn clear_startTime(&mut self) {
        self.startTime = ::std::option::Option::None;
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: u64) {
        self.startTime = ::std::option::Option::Some(v);
    }

    // required uint64 finalizeTime = 3;


    pub fn get_finalizeTime(&self) -> u64 {
        self.finalizeTime.unwrap_or(0)
    }
    pub fn clear_finalizeTime(&mut self) {
        self.finalizeTime = ::std::option::Option::None;
    }

    pub fn has_finalizeTime(&self) -> bool {
        self.finalizeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalizeTime(&mut self, v: u64) {
        self.finalizeTime = ::std::option::Option::Some(v);
    }

    // required bool createdRollbackImages = 4;


    pub fn get_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.unwrap_or(false)
    }
    pub fn clear_createdRollbackImages(&mut self) {
        self.createdRollbackImages = ::std::option::Option::None;
    }

    pub fn has_createdRollbackImages(&self) -> bool {
        self.createdRollbackImages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createdRollbackImages(&mut self, v: bool) {
        self.createdRollbackImages = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        if self.startTime.is_none() {
            return false;
        }
        if self.finalizeTime.is_none() {
            return false;
        }
        if self.createdRollbackImages.is_none() {
            return false;
        }
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.finalizeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createdRollbackImages = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.startTime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.finalizeTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.createdRollbackImages {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.startTime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.finalizeTime {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.createdRollbackImages {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeInfoProto {
        RollingUpgradeInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::RollingUpgradeStatusProto>>(
                    "status",
                    |m: &RollingUpgradeInfoProto| { &m.status },
                    |m: &mut RollingUpgradeInfoProto| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startTime",
                    |m: &RollingUpgradeInfoProto| { &m.startTime },
                    |m: &mut RollingUpgradeInfoProto| { &mut m.startTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "finalizeTime",
                    |m: &RollingUpgradeInfoProto| { &m.finalizeTime },
                    |m: &mut RollingUpgradeInfoProto| { &mut m.finalizeTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createdRollbackImages",
                    |m: &RollingUpgradeInfoProto| { &m.createdRollbackImages },
                    |m: &mut RollingUpgradeInfoProto| { &mut m.createdRollbackImages },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeInfoProto>(
                    "RollingUpgradeInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollingUpgradeInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeInfoProto,
        };
        unsafe {
            instance.get(RollingUpgradeInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeInfoProto {
    fn clear(&mut self) {
        self.status.clear();
        self.startTime = ::std::option::Option::None;
        self.finalizeTime = ::std::option::Option::None;
        self.createdRollbackImages = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeResponseProto {
    // message fields
    rollingUpgradeInfo: ::protobuf::SingularPtrField<RollingUpgradeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeResponseProto {
    fn default() -> &'a RollingUpgradeResponseProto {
        <RollingUpgradeResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeResponseProto {
    pub fn new() -> RollingUpgradeResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.RollingUpgradeInfoProto rollingUpgradeInfo = 1;


    pub fn get_rollingUpgradeInfo(&self) -> &RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.as_ref().unwrap_or_else(|| RollingUpgradeInfoProto::default_instance())
    }
    pub fn clear_rollingUpgradeInfo(&mut self) {
        self.rollingUpgradeInfo.clear();
    }

    pub fn has_rollingUpgradeInfo(&self) -> bool {
        self.rollingUpgradeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rollingUpgradeInfo(&mut self, v: RollingUpgradeInfoProto) {
        self.rollingUpgradeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rollingUpgradeInfo(&mut self) -> &mut RollingUpgradeInfoProto {
        if self.rollingUpgradeInfo.is_none() {
            self.rollingUpgradeInfo.set_default();
        }
        self.rollingUpgradeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_rollingUpgradeInfo(&mut self) -> RollingUpgradeInfoProto {
        self.rollingUpgradeInfo.take().unwrap_or_else(|| RollingUpgradeInfoProto::new())
    }
}

impl ::protobuf::Message for RollingUpgradeResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.rollingUpgradeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rollingUpgradeInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rollingUpgradeInfo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeResponseProto {
        RollingUpgradeResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RollingUpgradeInfoProto>>(
                    "rollingUpgradeInfo",
                    |m: &RollingUpgradeResponseProto| { &m.rollingUpgradeInfo },
                    |m: &mut RollingUpgradeResponseProto| { &mut m.rollingUpgradeInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeResponseProto>(
                    "RollingUpgradeResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollingUpgradeResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeResponseProto,
        };
        unsafe {
            instance.get(RollingUpgradeResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeResponseProto {
    fn clear(&mut self) {
        self.rollingUpgradeInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCorruptFileBlocksRequestProto {
    fn default() -> &'a ListCorruptFileBlocksRequestProto {
        <ListCorruptFileBlocksRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCorruptFileBlocksRequestProto {
    pub fn new() -> ListCorruptFileBlocksRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cookie = 2;


    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCorruptFileBlocksRequestProto {
        ListCorruptFileBlocksRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &ListCorruptFileBlocksRequestProto| { &m.path },
                    |m: &mut ListCorruptFileBlocksRequestProto| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cookie",
                    |m: &ListCorruptFileBlocksRequestProto| { &m.cookie },
                    |m: &mut ListCorruptFileBlocksRequestProto| { &mut m.cookie },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksRequestProto>(
                    "ListCorruptFileBlocksRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCorruptFileBlocksRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksRequestProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCorruptFileBlocksResponseProto {
    // message fields
    corrupt: ::protobuf::SingularPtrField<super::hdfs::CorruptFileBlocksProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCorruptFileBlocksResponseProto {
    fn default() -> &'a ListCorruptFileBlocksResponseProto {
        <ListCorruptFileBlocksResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCorruptFileBlocksResponseProto {
    pub fn new() -> ListCorruptFileBlocksResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CorruptFileBlocksProto corrupt = 1;


    pub fn get_corrupt(&self) -> &super::hdfs::CorruptFileBlocksProto {
        self.corrupt.as_ref().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::default_instance())
    }
    pub fn clear_corrupt(&mut self) {
        self.corrupt.clear();
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: super::hdfs::CorruptFileBlocksProto) {
        self.corrupt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_corrupt(&mut self) -> &mut super::hdfs::CorruptFileBlocksProto {
        if self.corrupt.is_none() {
            self.corrupt.set_default();
        }
        self.corrupt.as_mut().unwrap()
    }

    // Take field
    pub fn take_corrupt(&mut self) -> super::hdfs::CorruptFileBlocksProto {
        self.corrupt.take().unwrap_or_else(|| super::hdfs::CorruptFileBlocksProto::new())
    }
}

impl ::protobuf::Message for ListCorruptFileBlocksResponseProto {
    fn is_initialized(&self) -> bool {
        if self.corrupt.is_none() {
            return false;
        }
        for v in &self.corrupt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.corrupt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.corrupt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.corrupt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCorruptFileBlocksResponseProto {
        ListCorruptFileBlocksResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CorruptFileBlocksProto>>(
                    "corrupt",
                    |m: &ListCorruptFileBlocksResponseProto| { &m.corrupt },
                    |m: &mut ListCorruptFileBlocksResponseProto| { &mut m.corrupt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCorruptFileBlocksResponseProto>(
                    "ListCorruptFileBlocksResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCorruptFileBlocksResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCorruptFileBlocksResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCorruptFileBlocksResponseProto,
        };
        unsafe {
            instance.get(ListCorruptFileBlocksResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCorruptFileBlocksResponseProto {
    fn clear(&mut self) {
        self.corrupt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCorruptFileBlocksResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCorruptFileBlocksResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveRequestProto {
    // message fields
    filename: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaSaveRequestProto {
    fn default() -> &'a MetaSaveRequestProto {
        <MetaSaveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl MetaSaveRequestProto {
    pub fn new() -> MetaSaveRequestProto {
        ::std::default::Default::default()
    }

    // required string filename = 1;


    pub fn get_filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MetaSaveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.filename.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filename.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaSaveRequestProto {
        MetaSaveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "filename",
                    |m: &MetaSaveRequestProto| { &m.filename },
                    |m: &mut MetaSaveRequestProto| { &mut m.filename },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveRequestProto>(
                    "MetaSaveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaSaveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveRequestProto,
        };
        unsafe {
            instance.get(MetaSaveRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for MetaSaveRequestProto {
    fn clear(&mut self) {
        self.filename.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetaSaveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MetaSaveResponseProto {
    fn default() -> &'a MetaSaveResponseProto {
        <MetaSaveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl MetaSaveResponseProto {
    pub fn new() -> MetaSaveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MetaSaveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetaSaveResponseProto {
        MetaSaveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MetaSaveResponseProto>(
                    "MetaSaveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetaSaveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<MetaSaveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetaSaveResponseProto,
        };
        unsafe {
            instance.get(MetaSaveResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for MetaSaveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetaSaveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaSaveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileInfoRequestProto {
    fn default() -> &'a GetFileInfoRequestProto {
        <GetFileInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileInfoRequestProto {
    pub fn new() -> GetFileInfoRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFileInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileInfoRequestProto {
        GetFileInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &GetFileInfoRequestProto| { &m.src },
                    |m: &mut GetFileInfoRequestProto| { &mut m.src },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoRequestProto>(
                    "GetFileInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileInfoRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFileInfoRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileInfoResponseProto {
    fn default() -> &'a GetFileInfoResponseProto {
        <GetFileInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileInfoResponseProto {
    pub fn new() -> GetFileInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for GetFileInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileInfoResponseProto {
        GetFileInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    |m: &GetFileInfoResponseProto| { &m.fs },
                    |m: &mut GetFileInfoResponseProto| { &mut m.fs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileInfoResponseProto>(
                    "GetFileInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileInfoResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFileInfoResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFileClosedRequestProto {
    fn default() -> &'a IsFileClosedRequestProto {
        <IsFileClosedRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFileClosedRequestProto {
    pub fn new() -> IsFileClosedRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IsFileClosedRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFileClosedRequestProto {
        IsFileClosedRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &IsFileClosedRequestProto| { &m.src },
                    |m: &mut IsFileClosedRequestProto| { &mut m.src },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedRequestProto>(
                    "IsFileClosedRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsFileClosedRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedRequestProto,
        };
        unsafe {
            instance.get(IsFileClosedRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for IsFileClosedRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsFileClosedResponseProto {
    // message fields
    result: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsFileClosedResponseProto {
    fn default() -> &'a IsFileClosedResponseProto {
        <IsFileClosedResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl IsFileClosedResponseProto {
    pub fn new() -> IsFileClosedResponseProto {
        ::std::default::Default::default()
    }

    // required bool result = 1;


    pub fn get_result(&self) -> bool {
        self.result.unwrap_or(false)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IsFileClosedResponseProto {
    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsFileClosedResponseProto {
        IsFileClosedResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &IsFileClosedResponseProto| { &m.result },
                    |m: &mut IsFileClosedResponseProto| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsFileClosedResponseProto>(
                    "IsFileClosedResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsFileClosedResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<IsFileClosedResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsFileClosedResponseProto,
        };
        unsafe {
            instance.get(IsFileClosedResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for IsFileClosedResponseProto {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsFileClosedResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsFileClosedResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoProto {
    // message fields
    id: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    replication: ::std::option::Option<u32>,
    pool: ::protobuf::SingularField<::std::string::String>,
    expiration: ::protobuf::SingularPtrField<CacheDirectiveInfoExpirationProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveInfoProto {
    fn default() -> &'a CacheDirectiveInfoProto {
        <CacheDirectiveInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveInfoProto {
    pub fn new() -> CacheDirectiveInfoProto {
        ::std::default::Default::default()
    }

    // optional int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 replication = 3;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // optional string pool = 4;


    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.CacheDirectiveInfoExpirationProto expiration = 5;


    pub fn get_expiration(&self) -> &CacheDirectiveInfoExpirationProto {
        self.expiration.as_ref().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::default_instance())
    }
    pub fn clear_expiration(&mut self) {
        self.expiration.clear();
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: CacheDirectiveInfoExpirationProto) {
        self.expiration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expiration(&mut self) -> &mut CacheDirectiveInfoExpirationProto {
        if self.expiration.is_none() {
            self.expiration.set_default();
        }
        self.expiration.as_mut().unwrap()
    }

    // Take field
    pub fn take_expiration(&mut self) -> CacheDirectiveInfoExpirationProto {
        self.expiration.take().unwrap_or_else(|| CacheDirectiveInfoExpirationProto::new())
    }
}

impl ::protobuf::Message for CacheDirectiveInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.expiration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expiration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.expiration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.expiration.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveInfoProto {
        CacheDirectiveInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &CacheDirectiveInfoProto| { &m.id },
                    |m: &mut CacheDirectiveInfoProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CacheDirectiveInfoProto| { &m.path },
                    |m: &mut CacheDirectiveInfoProto| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    |m: &CacheDirectiveInfoProto| { &m.replication },
                    |m: &mut CacheDirectiveInfoProto| { &mut m.replication },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pool",
                    |m: &CacheDirectiveInfoProto| { &m.pool },
                    |m: &mut CacheDirectiveInfoProto| { &mut m.pool },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoExpirationProto>>(
                    "expiration",
                    |m: &CacheDirectiveInfoProto| { &m.expiration },
                    |m: &mut CacheDirectiveInfoProto| { &mut m.expiration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoProto>(
                    "CacheDirectiveInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheDirectiveInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.path.clear();
        self.replication = ::std::option::Option::None;
        self.pool.clear();
        self.expiration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveInfoExpirationProto {
    // message fields
    millis: ::std::option::Option<i64>,
    isRelative: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveInfoExpirationProto {
    fn default() -> &'a CacheDirectiveInfoExpirationProto {
        <CacheDirectiveInfoExpirationProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveInfoExpirationProto {
    pub fn new() -> CacheDirectiveInfoExpirationProto {
        ::std::default::Default::default()
    }

    // required int64 millis = 1;


    pub fn get_millis(&self) -> i64 {
        self.millis.unwrap_or(0)
    }
    pub fn clear_millis(&mut self) {
        self.millis = ::std::option::Option::None;
    }

    pub fn has_millis(&self) -> bool {
        self.millis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_millis(&mut self, v: i64) {
        self.millis = ::std::option::Option::Some(v);
    }

    // required bool isRelative = 2;


    pub fn get_isRelative(&self) -> bool {
        self.isRelative.unwrap_or(false)
    }
    pub fn clear_isRelative(&mut self) {
        self.isRelative = ::std::option::Option::None;
    }

    pub fn has_isRelative(&self) -> bool {
        self.isRelative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRelative(&mut self, v: bool) {
        self.isRelative = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CacheDirectiveInfoExpirationProto {
    fn is_initialized(&self) -> bool {
        if self.millis.is_none() {
            return false;
        }
        if self.isRelative.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.millis = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isRelative = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.millis {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isRelative {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.millis {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.isRelative {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveInfoExpirationProto {
        CacheDirectiveInfoExpirationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "millis",
                    |m: &CacheDirectiveInfoExpirationProto| { &m.millis },
                    |m: &mut CacheDirectiveInfoExpirationProto| { &mut m.millis },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isRelative",
                    |m: &CacheDirectiveInfoExpirationProto| { &m.isRelative },
                    |m: &mut CacheDirectiveInfoExpirationProto| { &mut m.isRelative },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveInfoExpirationProto>(
                    "CacheDirectiveInfoExpirationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheDirectiveInfoExpirationProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveInfoExpirationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveInfoExpirationProto,
        };
        unsafe {
            instance.get(CacheDirectiveInfoExpirationProto::new)
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveInfoExpirationProto {
    fn clear(&mut self) {
        self.millis = ::std::option::Option::None;
        self.isRelative = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveInfoExpirationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveInfoExpirationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    hasExpired: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveStatsProto {
    fn default() -> &'a CacheDirectiveStatsProto {
        <CacheDirectiveStatsProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveStatsProto {
    pub fn new() -> CacheDirectiveStatsProto {
        ::std::default::Default::default()
    }

    // required int64 bytesNeeded = 1;


    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }
    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 bytesCached = 2;


    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }
    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    // required int64 filesNeeded = 3;


    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }
    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 filesCached = 4;


    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }
    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }

    // required bool hasExpired = 5;


    pub fn get_hasExpired(&self) -> bool {
        self.hasExpired.unwrap_or(false)
    }
    pub fn clear_hasExpired(&mut self) {
        self.hasExpired = ::std::option::Option::None;
    }

    pub fn has_hasExpired(&self) -> bool {
        self.hasExpired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasExpired(&mut self, v: bool) {
        self.hasExpired = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CacheDirectiveStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        if self.hasExpired.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasExpired = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hasExpired {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.hasExpired {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveStatsProto {
        CacheDirectiveStatsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    |m: &CacheDirectiveStatsProto| { &m.bytesNeeded },
                    |m: &mut CacheDirectiveStatsProto| { &mut m.bytesNeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    |m: &CacheDirectiveStatsProto| { &m.bytesCached },
                    |m: &mut CacheDirectiveStatsProto| { &mut m.bytesCached },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    |m: &CacheDirectiveStatsProto| { &m.filesNeeded },
                    |m: &mut CacheDirectiveStatsProto| { &mut m.filesNeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    |m: &CacheDirectiveStatsProto| { &m.filesCached },
                    |m: &mut CacheDirectiveStatsProto| { &mut m.filesCached },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasExpired",
                    |m: &CacheDirectiveStatsProto| { &m.hasExpired },
                    |m: &mut CacheDirectiveStatsProto| { &mut m.hasExpired },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveStatsProto>(
                    "CacheDirectiveStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheDirectiveStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveStatsProto,
        };
        unsafe {
            instance.get(CacheDirectiveStatsProto::new)
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveStatsProto {
    fn clear(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
        self.bytesCached = ::std::option::Option::None;
        self.filesNeeded = ::std::option::Option::None;
        self.filesCached = ::std::option::Option::None;
        self.hasExpired = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCacheDirectiveRequestProto {
    fn default() -> &'a AddCacheDirectiveRequestProto {
        <AddCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCacheDirectiveRequestProto {
    pub fn new() -> AddCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // optional uint32 cacheFlags = 2;


    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCacheDirectiveRequestProto {
        AddCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    |m: &AddCacheDirectiveRequestProto| { &m.info },
                    |m: &mut AddCacheDirectiveRequestProto| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    |m: &AddCacheDirectiveRequestProto| { &m.cacheFlags },
                    |m: &mut AddCacheDirectiveRequestProto| { &mut m.cacheFlags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveRequestProto>(
                    "AddCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.cacheFlags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCacheDirectiveResponseProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCacheDirectiveResponseProto {
    fn default() -> &'a AddCacheDirectiveResponseProto {
        <AddCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCacheDirectiveResponseProto {
    pub fn new() -> AddCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AddCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCacheDirectiveResponseProto {
        AddCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &AddCacheDirectiveResponseProto| { &m.id },
                    |m: &mut AddCacheDirectiveResponseProto| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCacheDirectiveResponseProto>(
                    "AddCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(AddCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AddCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    cacheFlags: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCacheDirectiveRequestProto {
    fn default() -> &'a ModifyCacheDirectiveRequestProto {
        <ModifyCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCacheDirectiveRequestProto {
    pub fn new() -> ModifyCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // optional uint32 cacheFlags = 2;


    pub fn get_cacheFlags(&self) -> u32 {
        self.cacheFlags.unwrap_or(0)
    }
    pub fn clear_cacheFlags(&mut self) {
        self.cacheFlags = ::std::option::Option::None;
    }

    pub fn has_cacheFlags(&self) -> bool {
        self.cacheFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheFlags(&mut self, v: u32) {
        self.cacheFlags = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cacheFlags = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cacheFlags {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cacheFlags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCacheDirectiveRequestProto {
        ModifyCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    |m: &ModifyCacheDirectiveRequestProto| { &m.info },
                    |m: &mut ModifyCacheDirectiveRequestProto| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "cacheFlags",
                    |m: &ModifyCacheDirectiveRequestProto| { &m.cacheFlags },
                    |m: &mut ModifyCacheDirectiveRequestProto| { &mut m.cacheFlags },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveRequestProto>(
                    "ModifyCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.cacheFlags = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCacheDirectiveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCacheDirectiveResponseProto {
    fn default() -> &'a ModifyCacheDirectiveResponseProto {
        <ModifyCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCacheDirectiveResponseProto {
    pub fn new() -> ModifyCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCacheDirectiveResponseProto {
        ModifyCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCacheDirectiveResponseProto>(
                    "ModifyCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(ModifyCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ModifyCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveRequestProto {
    // message fields
    id: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCacheDirectiveRequestProto {
    fn default() -> &'a RemoveCacheDirectiveRequestProto {
        <RemoveCacheDirectiveRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCacheDirectiveRequestProto {
    pub fn new() -> RemoveCacheDirectiveRequestProto {
        ::std::default::Default::default()
    }

    // required int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id.unwrap_or(0)
    }
    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveRequestProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCacheDirectiveRequestProto {
        RemoveCacheDirectiveRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &RemoveCacheDirectiveRequestProto| { &m.id },
                    |m: &mut RemoveCacheDirectiveRequestProto| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveRequestProto>(
                    "RemoveCacheDirectiveRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveCacheDirectiveRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveRequestProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveRequestProto {
    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCacheDirectiveResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCacheDirectiveResponseProto {
    fn default() -> &'a RemoveCacheDirectiveResponseProto {
        <RemoveCacheDirectiveResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCacheDirectiveResponseProto {
    pub fn new() -> RemoveCacheDirectiveResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveCacheDirectiveResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCacheDirectiveResponseProto {
        RemoveCacheDirectiveResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCacheDirectiveResponseProto>(
                    "RemoveCacheDirectiveResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveCacheDirectiveResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCacheDirectiveResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCacheDirectiveResponseProto,
        };
        unsafe {
            instance.get(RemoveCacheDirectiveResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoveCacheDirectiveResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCacheDirectiveResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCacheDirectiveResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesRequestProto {
    // message fields
    prevId: ::std::option::Option<i64>,
    filter: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCacheDirectivesRequestProto {
    fn default() -> &'a ListCacheDirectivesRequestProto {
        <ListCacheDirectivesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCacheDirectivesRequestProto {
    pub fn new() -> ListCacheDirectivesRequestProto {
        ::std::default::Default::default()
    }

    // required int64 prevId = 1;


    pub fn get_prevId(&self) -> i64 {
        self.prevId.unwrap_or(0)
    }
    pub fn clear_prevId(&mut self) {
        self.prevId = ::std::option::Option::None;
    }

    pub fn has_prevId(&self) -> bool {
        self.prevId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevId(&mut self, v: i64) {
        self.prevId = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto filter = 2;


    pub fn get_filter(&self) -> &CacheDirectiveInfoProto {
        self.filter.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: CacheDirectiveInfoProto) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> CacheDirectiveInfoProto {
        self.filter.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }
}

impl ::protobuf::Message for ListCacheDirectivesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevId.is_none() {
            return false;
        }
        if self.filter.is_none() {
            return false;
        }
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prevId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.prevId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.prevId {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCacheDirectivesRequestProto {
        ListCacheDirectivesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prevId",
                    |m: &ListCacheDirectivesRequestProto| { &m.prevId },
                    |m: &mut ListCacheDirectivesRequestProto| { &mut m.prevId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "filter",
                    |m: &ListCacheDirectivesRequestProto| { &m.filter },
                    |m: &mut ListCacheDirectivesRequestProto| { &mut m.filter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesRequestProto>(
                    "ListCacheDirectivesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCacheDirectivesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesRequestProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesRequestProto {
    fn clear(&mut self) {
        self.prevId = ::std::option::Option::None;
        self.filter.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CacheDirectiveEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CacheDirectiveInfoProto>,
    stats: ::protobuf::SingularPtrField<CacheDirectiveStatsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CacheDirectiveEntryProto {
    fn default() -> &'a CacheDirectiveEntryProto {
        <CacheDirectiveEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl CacheDirectiveEntryProto {
    pub fn new() -> CacheDirectiveEntryProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CacheDirectiveInfoProto info = 1;


    pub fn get_info(&self) -> &CacheDirectiveInfoProto {
        self.info.as_ref().unwrap_or_else(|| CacheDirectiveInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CacheDirectiveInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CacheDirectiveInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CacheDirectiveInfoProto {
        self.info.take().unwrap_or_else(|| CacheDirectiveInfoProto::new())
    }

    // required .hadoop.hdfs.CacheDirectiveStatsProto stats = 2;


    pub fn get_stats(&self) -> &CacheDirectiveStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CacheDirectiveStatsProto::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CacheDirectiveStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CacheDirectiveStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CacheDirectiveStatsProto {
        self.stats.take().unwrap_or_else(|| CacheDirectiveStatsProto::new())
    }
}

impl ::protobuf::Message for CacheDirectiveEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CacheDirectiveEntryProto {
        CacheDirectiveEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveInfoProto>>(
                    "info",
                    |m: &CacheDirectiveEntryProto| { &m.info },
                    |m: &mut CacheDirectiveEntryProto| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveStatsProto>>(
                    "stats",
                    |m: &CacheDirectiveEntryProto| { &m.stats },
                    |m: &mut CacheDirectiveEntryProto| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CacheDirectiveEntryProto>(
                    "CacheDirectiveEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CacheDirectiveEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CacheDirectiveEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CacheDirectiveEntryProto,
        };
        unsafe {
            instance.get(CacheDirectiveEntryProto::new)
        }
    }
}

impl ::protobuf::Clear for CacheDirectiveEntryProto {
    fn clear(&mut self) {
        self.info.clear();
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CacheDirectiveEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheDirectiveEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCacheDirectivesResponseProto {
    // message fields
    elements: ::protobuf::RepeatedField<CacheDirectiveEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCacheDirectivesResponseProto {
    fn default() -> &'a ListCacheDirectivesResponseProto {
        <ListCacheDirectivesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCacheDirectivesResponseProto {
    pub fn new() -> ListCacheDirectivesResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.CacheDirectiveEntryProto elements = 1;


    pub fn get_elements(&self) -> &[CacheDirectiveEntryProto] {
        &self.elements
    }
    pub fn clear_elements(&mut self) {
        self.elements.clear();
    }

    // Param is passed by value, moved
    pub fn set_elements(&mut self, v: ::protobuf::RepeatedField<CacheDirectiveEntryProto>) {
        self.elements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_elements(&mut self) -> &mut ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        &mut self.elements
    }

    // Take field
    pub fn take_elements(&mut self) -> ::protobuf::RepeatedField<CacheDirectiveEntryProto> {
        ::std::mem::replace(&mut self.elements, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListCacheDirectivesResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.elements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.elements)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.elements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCacheDirectivesResponseProto {
        ListCacheDirectivesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CacheDirectiveEntryProto>>(
                    "elements",
                    |m: &ListCacheDirectivesResponseProto| { &m.elements },
                    |m: &mut ListCacheDirectivesResponseProto| { &mut m.elements },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    |m: &ListCacheDirectivesResponseProto| { &m.hasMore },
                    |m: &mut ListCacheDirectivesResponseProto| { &mut m.hasMore },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCacheDirectivesResponseProto>(
                    "ListCacheDirectivesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCacheDirectivesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCacheDirectivesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCacheDirectivesResponseProto,
        };
        unsafe {
            instance.get(ListCacheDirectivesResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCacheDirectivesResponseProto {
    fn clear(&mut self) {
        self.elements.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCacheDirectivesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCacheDirectivesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolInfoProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    ownerName: ::protobuf::SingularField<::std::string::String>,
    groupName: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    limit: ::std::option::Option<i64>,
    maxRelativeExpiry: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolInfoProto {
    fn default() -> &'a CachePoolInfoProto {
        <CachePoolInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolInfoProto {
    pub fn new() -> CachePoolInfoProto {
        ::std::default::Default::default()
    }

    // optional string poolName = 1;


    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ownerName = 2;


    pub fn get_ownerName(&self) -> &str {
        match self.ownerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ownerName(&mut self) {
        self.ownerName.clear();
    }

    pub fn has_ownerName(&self) -> bool {
        self.ownerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownerName(&mut self, v: ::std::string::String) {
        self.ownerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ownerName(&mut self) -> &mut ::std::string::String {
        if self.ownerName.is_none() {
            self.ownerName.set_default();
        }
        self.ownerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ownerName(&mut self) -> ::std::string::String {
        self.ownerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string groupName = 3;


    pub fn get_groupName(&self) -> &str {
        match self.groupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupName(&mut self) {
        self.groupName.clear();
    }

    pub fn has_groupName(&self) -> bool {
        self.groupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupName(&mut self, v: ::std::string::String) {
        self.groupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupName(&mut self) -> &mut ::std::string::String {
        if self.groupName.is_none() {
            self.groupName.set_default();
        }
        self.groupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupName(&mut self) -> ::std::string::String {
        self.groupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mode = 4;


    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional int64 limit = 5;


    pub fn get_limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    // optional int64 maxRelativeExpiry = 6;


    pub fn get_maxRelativeExpiry(&self) -> i64 {
        self.maxRelativeExpiry.unwrap_or(0)
    }
    pub fn clear_maxRelativeExpiry(&mut self) {
        self.maxRelativeExpiry = ::std::option::Option::None;
    }

    pub fn has_maxRelativeExpiry(&self) -> bool {
        self.maxRelativeExpiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRelativeExpiry(&mut self, v: i64) {
        self.maxRelativeExpiry = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachePoolInfoProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ownerName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupName)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maxRelativeExpiry = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.groupName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxRelativeExpiry {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ownerName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.groupName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.maxRelativeExpiry {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolInfoProto {
        CachePoolInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    |m: &CachePoolInfoProto| { &m.poolName },
                    |m: &mut CachePoolInfoProto| { &mut m.poolName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ownerName",
                    |m: &CachePoolInfoProto| { &m.ownerName },
                    |m: &mut CachePoolInfoProto| { &mut m.ownerName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "groupName",
                    |m: &CachePoolInfoProto| { &m.groupName },
                    |m: &mut CachePoolInfoProto| { &mut m.groupName },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    |m: &CachePoolInfoProto| { &m.mode },
                    |m: &mut CachePoolInfoProto| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &CachePoolInfoProto| { &m.limit },
                    |m: &mut CachePoolInfoProto| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "maxRelativeExpiry",
                    |m: &CachePoolInfoProto| { &m.maxRelativeExpiry },
                    |m: &mut CachePoolInfoProto| { &mut m.maxRelativeExpiry },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolInfoProto>(
                    "CachePoolInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CachePoolInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolInfoProto,
        };
        unsafe {
            instance.get(CachePoolInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for CachePoolInfoProto {
    fn clear(&mut self) {
        self.poolName.clear();
        self.ownerName.clear();
        self.groupName.clear();
        self.mode = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.maxRelativeExpiry = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolStatsProto {
    // message fields
    bytesNeeded: ::std::option::Option<i64>,
    bytesCached: ::std::option::Option<i64>,
    bytesOverlimit: ::std::option::Option<i64>,
    filesNeeded: ::std::option::Option<i64>,
    filesCached: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolStatsProto {
    fn default() -> &'a CachePoolStatsProto {
        <CachePoolStatsProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolStatsProto {
    pub fn new() -> CachePoolStatsProto {
        ::std::default::Default::default()
    }

    // required int64 bytesNeeded = 1;


    pub fn get_bytesNeeded(&self) -> i64 {
        self.bytesNeeded.unwrap_or(0)
    }
    pub fn clear_bytesNeeded(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
    }

    pub fn has_bytesNeeded(&self) -> bool {
        self.bytesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesNeeded(&mut self, v: i64) {
        self.bytesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 bytesCached = 2;


    pub fn get_bytesCached(&self) -> i64 {
        self.bytesCached.unwrap_or(0)
    }
    pub fn clear_bytesCached(&mut self) {
        self.bytesCached = ::std::option::Option::None;
    }

    pub fn has_bytesCached(&self) -> bool {
        self.bytesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesCached(&mut self, v: i64) {
        self.bytesCached = ::std::option::Option::Some(v);
    }

    // required int64 bytesOverlimit = 3;


    pub fn get_bytesOverlimit(&self) -> i64 {
        self.bytesOverlimit.unwrap_or(0)
    }
    pub fn clear_bytesOverlimit(&mut self) {
        self.bytesOverlimit = ::std::option::Option::None;
    }

    pub fn has_bytesOverlimit(&self) -> bool {
        self.bytesOverlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesOverlimit(&mut self, v: i64) {
        self.bytesOverlimit = ::std::option::Option::Some(v);
    }

    // required int64 filesNeeded = 4;


    pub fn get_filesNeeded(&self) -> i64 {
        self.filesNeeded.unwrap_or(0)
    }
    pub fn clear_filesNeeded(&mut self) {
        self.filesNeeded = ::std::option::Option::None;
    }

    pub fn has_filesNeeded(&self) -> bool {
        self.filesNeeded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesNeeded(&mut self, v: i64) {
        self.filesNeeded = ::std::option::Option::Some(v);
    }

    // required int64 filesCached = 5;


    pub fn get_filesCached(&self) -> i64 {
        self.filesCached.unwrap_or(0)
    }
    pub fn clear_filesCached(&mut self) {
        self.filesCached = ::std::option::Option::None;
    }

    pub fn has_filesCached(&self) -> bool {
        self.filesCached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filesCached(&mut self, v: i64) {
        self.filesCached = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachePoolStatsProto {
    fn is_initialized(&self) -> bool {
        if self.bytesNeeded.is_none() {
            return false;
        }
        if self.bytesCached.is_none() {
            return false;
        }
        if self.bytesOverlimit.is_none() {
            return false;
        }
        if self.filesNeeded.is_none() {
            return false;
        }
        if self.filesCached.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesNeeded = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesCached = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytesOverlimit = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesNeeded = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.filesCached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesNeeded {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesCached {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesOverlimit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesNeeded {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.filesCached {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesNeeded {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.bytesCached {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.bytesOverlimit {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.filesNeeded {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.filesCached {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolStatsProto {
        CachePoolStatsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesNeeded",
                    |m: &CachePoolStatsProto| { &m.bytesNeeded },
                    |m: &mut CachePoolStatsProto| { &mut m.bytesNeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesCached",
                    |m: &CachePoolStatsProto| { &m.bytesCached },
                    |m: &mut CachePoolStatsProto| { &mut m.bytesCached },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bytesOverlimit",
                    |m: &CachePoolStatsProto| { &m.bytesOverlimit },
                    |m: &mut CachePoolStatsProto| { &mut m.bytesOverlimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesNeeded",
                    |m: &CachePoolStatsProto| { &m.filesNeeded },
                    |m: &mut CachePoolStatsProto| { &mut m.filesNeeded },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "filesCached",
                    |m: &CachePoolStatsProto| { &m.filesCached },
                    |m: &mut CachePoolStatsProto| { &mut m.filesCached },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolStatsProto>(
                    "CachePoolStatsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CachePoolStatsProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolStatsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolStatsProto,
        };
        unsafe {
            instance.get(CachePoolStatsProto::new)
        }
    }
}

impl ::protobuf::Clear for CachePoolStatsProto {
    fn clear(&mut self) {
        self.bytesNeeded = ::std::option::Option::None;
        self.bytesCached = ::std::option::Option::None;
        self.bytesOverlimit = ::std::option::Option::None;
        self.filesNeeded = ::std::option::Option::None;
        self.filesCached = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCachePoolRequestProto {
    fn default() -> &'a AddCachePoolRequestProto {
        <AddCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCachePoolRequestProto {
    pub fn new() -> AddCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }
}

impl ::protobuf::Message for AddCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCachePoolRequestProto {
        AddCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    |m: &AddCachePoolRequestProto| { &m.info },
                    |m: &mut AddCachePoolRequestProto| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolRequestProto>(
                    "AddCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolRequestProto,
        };
        unsafe {
            instance.get(AddCachePoolRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AddCachePoolRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCachePoolResponseProto {
    fn default() -> &'a AddCachePoolResponseProto {
        <AddCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AddCachePoolResponseProto {
    pub fn new() -> AddCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCachePoolResponseProto {
        AddCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AddCachePoolResponseProto>(
                    "AddCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AddCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddCachePoolResponseProto,
        };
        unsafe {
            instance.get(AddCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AddCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolRequestProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCachePoolRequestProto {
    fn default() -> &'a ModifyCachePoolRequestProto {
        <ModifyCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCachePoolRequestProto {
    pub fn new() -> ModifyCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }
}

impl ::protobuf::Message for ModifyCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCachePoolRequestProto {
        ModifyCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    |m: &ModifyCachePoolRequestProto| { &m.info },
                    |m: &mut ModifyCachePoolRequestProto| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolRequestProto>(
                    "ModifyCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolRequestProto,
        };
        unsafe {
            instance.get(ModifyCachePoolRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolRequestProto {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModifyCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyCachePoolResponseProto {
    fn default() -> &'a ModifyCachePoolResponseProto {
        <ModifyCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ModifyCachePoolResponseProto {
    pub fn new() -> ModifyCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ModifyCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyCachePoolResponseProto {
        ModifyCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ModifyCachePoolResponseProto>(
                    "ModifyCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ModifyCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModifyCachePoolResponseProto,
        };
        unsafe {
            instance.get(ModifyCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ModifyCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolRequestProto {
    // message fields
    poolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCachePoolRequestProto {
    fn default() -> &'a RemoveCachePoolRequestProto {
        <RemoveCachePoolRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCachePoolRequestProto {
    pub fn new() -> RemoveCachePoolRequestProto {
        ::std::default::Default::default()
    }

    // required string poolName = 1;


    pub fn get_poolName(&self) -> &str {
        match self.poolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolName(&mut self) {
        self.poolName.clear();
    }

    pub fn has_poolName(&self) -> bool {
        self.poolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolName(&mut self, v: ::std::string::String) {
        self.poolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolName(&mut self) -> &mut ::std::string::String {
        if self.poolName.is_none() {
            self.poolName.set_default();
        }
        self.poolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolName(&mut self) -> ::std::string::String {
        self.poolName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveCachePoolRequestProto {
    fn is_initialized(&self) -> bool {
        if self.poolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCachePoolRequestProto {
        RemoveCachePoolRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolName",
                    |m: &RemoveCachePoolRequestProto| { &m.poolName },
                    |m: &mut RemoveCachePoolRequestProto| { &mut m.poolName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolRequestProto>(
                    "RemoveCachePoolRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveCachePoolRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolRequestProto,
        };
        unsafe {
            instance.get(RemoveCachePoolRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolRequestProto {
    fn clear(&mut self) {
        self.poolName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveCachePoolResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveCachePoolResponseProto {
    fn default() -> &'a RemoveCachePoolResponseProto {
        <RemoveCachePoolResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoveCachePoolResponseProto {
    pub fn new() -> RemoveCachePoolResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveCachePoolResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveCachePoolResponseProto {
        RemoveCachePoolResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RemoveCachePoolResponseProto>(
                    "RemoveCachePoolResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveCachePoolResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoveCachePoolResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveCachePoolResponseProto,
        };
        unsafe {
            instance.get(RemoveCachePoolResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoveCachePoolResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveCachePoolResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveCachePoolResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsRequestProto {
    // message fields
    prevPoolName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCachePoolsRequestProto {
    fn default() -> &'a ListCachePoolsRequestProto {
        <ListCachePoolsRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCachePoolsRequestProto {
    pub fn new() -> ListCachePoolsRequestProto {
        ::std::default::Default::default()
    }

    // required string prevPoolName = 1;


    pub fn get_prevPoolName(&self) -> &str {
        match self.prevPoolName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_prevPoolName(&mut self) {
        self.prevPoolName.clear();
    }

    pub fn has_prevPoolName(&self) -> bool {
        self.prevPoolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prevPoolName(&mut self, v: ::std::string::String) {
        self.prevPoolName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevPoolName(&mut self) -> &mut ::std::string::String {
        if self.prevPoolName.is_none() {
            self.prevPoolName.set_default();
        }
        self.prevPoolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_prevPoolName(&mut self) -> ::std::string::String {
        self.prevPoolName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListCachePoolsRequestProto {
    fn is_initialized(&self) -> bool {
        if self.prevPoolName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prevPoolName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prevPoolName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prevPoolName.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCachePoolsRequestProto {
        ListCachePoolsRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prevPoolName",
                    |m: &ListCachePoolsRequestProto| { &m.prevPoolName },
                    |m: &mut ListCachePoolsRequestProto| { &mut m.prevPoolName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsRequestProto>(
                    "ListCachePoolsRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCachePoolsRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsRequestProto,
        };
        unsafe {
            instance.get(ListCachePoolsRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsRequestProto {
    fn clear(&mut self) {
        self.prevPoolName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCachePoolsResponseProto {
    // message fields
    entries: ::protobuf::RepeatedField<CachePoolEntryProto>,
    hasMore: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListCachePoolsResponseProto {
    fn default() -> &'a ListCachePoolsResponseProto {
        <ListCachePoolsResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ListCachePoolsResponseProto {
    pub fn new() -> ListCachePoolsResponseProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.CachePoolEntryProto entries = 1;


    pub fn get_entries(&self) -> &[CachePoolEntryProto] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CachePoolEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<CachePoolEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CachePoolEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    // required bool hasMore = 2;


    pub fn get_hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }
    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListCachePoolsResponseProto {
    fn is_initialized(&self) -> bool {
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hasMore = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCachePoolsResponseProto {
        ListCachePoolsResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolEntryProto>>(
                    "entries",
                    |m: &ListCachePoolsResponseProto| { &m.entries },
                    |m: &mut ListCachePoolsResponseProto| { &mut m.entries },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hasMore",
                    |m: &ListCachePoolsResponseProto| { &m.hasMore },
                    |m: &mut ListCachePoolsResponseProto| { &mut m.hasMore },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCachePoolsResponseProto>(
                    "ListCachePoolsResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCachePoolsResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ListCachePoolsResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCachePoolsResponseProto,
        };
        unsafe {
            instance.get(ListCachePoolsResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ListCachePoolsResponseProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.hasMore = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCachePoolsResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCachePoolsResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachePoolEntryProto {
    // message fields
    info: ::protobuf::SingularPtrField<CachePoolInfoProto>,
    stats: ::protobuf::SingularPtrField<CachePoolStatsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachePoolEntryProto {
    fn default() -> &'a CachePoolEntryProto {
        <CachePoolEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl CachePoolEntryProto {
    pub fn new() -> CachePoolEntryProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CachePoolInfoProto info = 1;


    pub fn get_info(&self) -> &CachePoolInfoProto {
        self.info.as_ref().unwrap_or_else(|| CachePoolInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CachePoolInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CachePoolInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CachePoolInfoProto {
        self.info.take().unwrap_or_else(|| CachePoolInfoProto::new())
    }

    // required .hadoop.hdfs.CachePoolStatsProto stats = 2;


    pub fn get_stats(&self) -> &CachePoolStatsProto {
        self.stats.as_ref().unwrap_or_else(|| CachePoolStatsProto::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: CachePoolStatsProto) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut CachePoolStatsProto {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> CachePoolStatsProto {
        self.stats.take().unwrap_or_else(|| CachePoolStatsProto::new())
    }
}

impl ::protobuf::Message for CachePoolEntryProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        if self.stats.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachePoolEntryProto {
        CachePoolEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolInfoProto>>(
                    "info",
                    |m: &CachePoolEntryProto| { &m.info },
                    |m: &mut CachePoolEntryProto| { &mut m.info },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachePoolStatsProto>>(
                    "stats",
                    |m: &CachePoolEntryProto| { &m.stats },
                    |m: &mut CachePoolEntryProto| { &mut m.stats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachePoolEntryProto>(
                    "CachePoolEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CachePoolEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<CachePoolEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachePoolEntryProto,
        };
        unsafe {
            instance.get(CachePoolEntryProto::new)
        }
    }
}

impl ::protobuf::Clear for CachePoolEntryProto {
    fn clear(&mut self) {
        self.info.clear();
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachePoolEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachePoolEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileLinkInfoRequestProto {
    fn default() -> &'a GetFileLinkInfoRequestProto {
        <GetFileLinkInfoRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileLinkInfoRequestProto {
    pub fn new() -> GetFileLinkInfoRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFileLinkInfoRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileLinkInfoRequestProto {
        GetFileLinkInfoRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &GetFileLinkInfoRequestProto| { &m.src },
                    |m: &mut GetFileLinkInfoRequestProto| { &mut m.src },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoRequestProto>(
                    "GetFileLinkInfoRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileLinkInfoRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoRequestProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileLinkInfoResponseProto {
    // message fields
    fs: ::protobuf::SingularPtrField<super::hdfs::HdfsFileStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileLinkInfoResponseProto {
    fn default() -> &'a GetFileLinkInfoResponseProto {
        <GetFileLinkInfoResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetFileLinkInfoResponseProto {
    pub fn new() -> GetFileLinkInfoResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.HdfsFileStatusProto fs = 1;


    pub fn get_fs(&self) -> &super::hdfs::HdfsFileStatusProto {
        self.fs.as_ref().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::default_instance())
    }
    pub fn clear_fs(&mut self) {
        self.fs.clear();
    }

    pub fn has_fs(&self) -> bool {
        self.fs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fs(&mut self, v: super::hdfs::HdfsFileStatusProto) {
        self.fs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fs(&mut self) -> &mut super::hdfs::HdfsFileStatusProto {
        if self.fs.is_none() {
            self.fs.set_default();
        }
        self.fs.as_mut().unwrap()
    }

    // Take field
    pub fn take_fs(&mut self) -> super::hdfs::HdfsFileStatusProto {
        self.fs.take().unwrap_or_else(|| super::hdfs::HdfsFileStatusProto::new())
    }
}

impl ::protobuf::Message for GetFileLinkInfoResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.fs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fs.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileLinkInfoResponseProto {
        GetFileLinkInfoResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::HdfsFileStatusProto>>(
                    "fs",
                    |m: &GetFileLinkInfoResponseProto| { &m.fs },
                    |m: &mut GetFileLinkInfoResponseProto| { &mut m.fs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileLinkInfoResponseProto>(
                    "GetFileLinkInfoResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileLinkInfoResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetFileLinkInfoResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileLinkInfoResponseProto,
        };
        unsafe {
            instance.get(GetFileLinkInfoResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetFileLinkInfoResponseProto {
    fn clear(&mut self) {
        self.fs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileLinkInfoResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileLinkInfoResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContentSummaryRequestProto {
    fn default() -> &'a GetContentSummaryRequestProto {
        <GetContentSummaryRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetContentSummaryRequestProto {
    pub fn new() -> GetContentSummaryRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetContentSummaryRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContentSummaryRequestProto {
        GetContentSummaryRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &GetContentSummaryRequestProto| { &m.path },
                    |m: &mut GetContentSummaryRequestProto| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryRequestProto>(
                    "GetContentSummaryRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContentSummaryRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryRequestProto,
        };
        unsafe {
            instance.get(GetContentSummaryRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetContentSummaryResponseProto {
    // message fields
    summary: ::protobuf::SingularPtrField<super::hdfs::ContentSummaryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetContentSummaryResponseProto {
    fn default() -> &'a GetContentSummaryResponseProto {
        <GetContentSummaryResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetContentSummaryResponseProto {
    pub fn new() -> GetContentSummaryResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ContentSummaryProto summary = 1;


    pub fn get_summary(&self) -> &super::hdfs::ContentSummaryProto {
        self.summary.as_ref().unwrap_or_else(|| super::hdfs::ContentSummaryProto::default_instance())
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: super::hdfs::ContentSummaryProto) {
        self.summary = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut super::hdfs::ContentSummaryProto {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> super::hdfs::ContentSummaryProto {
        self.summary.take().unwrap_or_else(|| super::hdfs::ContentSummaryProto::new())
    }
}

impl ::protobuf::Message for GetContentSummaryResponseProto {
    fn is_initialized(&self) -> bool {
        if self.summary.is_none() {
            return false;
        }
        for v in &self.summary {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.summary.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetContentSummaryResponseProto {
        GetContentSummaryResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ContentSummaryProto>>(
                    "summary",
                    |m: &GetContentSummaryResponseProto| { &m.summary },
                    |m: &mut GetContentSummaryResponseProto| { &mut m.summary },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetContentSummaryResponseProto>(
                    "GetContentSummaryResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetContentSummaryResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetContentSummaryResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetContentSummaryResponseProto,
        };
        unsafe {
            instance.get(GetContentSummaryResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetContentSummaryResponseProto {
    fn clear(&mut self) {
        self.summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetContentSummaryResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetContentSummaryResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQuotaUsageRequestProto {
    fn default() -> &'a GetQuotaUsageRequestProto {
        <GetQuotaUsageRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetQuotaUsageRequestProto {
    pub fn new() -> GetQuotaUsageRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetQuotaUsageRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQuotaUsageRequestProto {
        GetQuotaUsageRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &GetQuotaUsageRequestProto| { &m.path },
                    |m: &mut GetQuotaUsageRequestProto| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetQuotaUsageRequestProto>(
                    "GetQuotaUsageRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetQuotaUsageRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetQuotaUsageRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetQuotaUsageRequestProto,
        };
        unsafe {
            instance.get(GetQuotaUsageRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetQuotaUsageRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetQuotaUsageResponseProto {
    // message fields
    usage: ::protobuf::SingularPtrField<super::hdfs::QuotaUsageProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetQuotaUsageResponseProto {
    fn default() -> &'a GetQuotaUsageResponseProto {
        <GetQuotaUsageResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetQuotaUsageResponseProto {
    pub fn new() -> GetQuotaUsageResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.QuotaUsageProto usage = 1;


    pub fn get_usage(&self) -> &super::hdfs::QuotaUsageProto {
        self.usage.as_ref().unwrap_or_else(|| super::hdfs::QuotaUsageProto::default_instance())
    }
    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: super::hdfs::QuotaUsageProto) {
        self.usage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut super::hdfs::QuotaUsageProto {
        if self.usage.is_none() {
            self.usage.set_default();
        }
        self.usage.as_mut().unwrap()
    }

    // Take field
    pub fn take_usage(&mut self) -> super::hdfs::QuotaUsageProto {
        self.usage.take().unwrap_or_else(|| super::hdfs::QuotaUsageProto::new())
    }
}

impl ::protobuf::Message for GetQuotaUsageResponseProto {
    fn is_initialized(&self) -> bool {
        if self.usage.is_none() {
            return false;
        }
        for v in &self.usage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.usage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.usage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.usage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetQuotaUsageResponseProto {
        GetQuotaUsageResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::QuotaUsageProto>>(
                    "usage",
                    |m: &GetQuotaUsageResponseProto| { &m.usage },
                    |m: &mut GetQuotaUsageResponseProto| { &mut m.usage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetQuotaUsageResponseProto>(
                    "GetQuotaUsageResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetQuotaUsageResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetQuotaUsageResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetQuotaUsageResponseProto,
        };
        unsafe {
            instance.get(GetQuotaUsageResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetQuotaUsageResponseProto {
    fn clear(&mut self) {
        self.usage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetQuotaUsageResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetQuotaUsageResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    namespaceQuota: ::std::option::Option<u64>,
    storagespaceQuota: ::std::option::Option<u64>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetQuotaRequestProto {
    fn default() -> &'a SetQuotaRequestProto {
        <SetQuotaRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetQuotaRequestProto {
    pub fn new() -> SetQuotaRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 namespaceQuota = 2;


    pub fn get_namespaceQuota(&self) -> u64 {
        self.namespaceQuota.unwrap_or(0)
    }
    pub fn clear_namespaceQuota(&mut self) {
        self.namespaceQuota = ::std::option::Option::None;
    }

    pub fn has_namespaceQuota(&self) -> bool {
        self.namespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceQuota(&mut self, v: u64) {
        self.namespaceQuota = ::std::option::Option::Some(v);
    }

    // required uint64 storagespaceQuota = 3;


    pub fn get_storagespaceQuota(&self) -> u64 {
        self.storagespaceQuota.unwrap_or(0)
    }
    pub fn clear_storagespaceQuota(&mut self) {
        self.storagespaceQuota = ::std::option::Option::None;
    }

    pub fn has_storagespaceQuota(&self) -> bool {
        self.storagespaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagespaceQuota(&mut self, v: u64) {
        self.storagespaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetQuotaRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.namespaceQuota.is_none() {
            return false;
        }
        if self.storagespaceQuota.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.namespaceQuota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storagespaceQuota = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.namespaceQuota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storagespaceQuota {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.namespaceQuota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.storagespaceQuota {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetQuotaRequestProto {
        SetQuotaRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &SetQuotaRequestProto| { &m.path },
                    |m: &mut SetQuotaRequestProto| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "namespaceQuota",
                    |m: &SetQuotaRequestProto| { &m.namespaceQuota },
                    |m: &mut SetQuotaRequestProto| { &mut m.namespaceQuota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storagespaceQuota",
                    |m: &SetQuotaRequestProto| { &m.storagespaceQuota },
                    |m: &mut SetQuotaRequestProto| { &mut m.storagespaceQuota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "storageType",
                    |m: &SetQuotaRequestProto| { &m.storageType },
                    |m: &mut SetQuotaRequestProto| { &mut m.storageType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaRequestProto>(
                    "SetQuotaRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetQuotaRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaRequestProto,
        };
        unsafe {
            instance.get(SetQuotaRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetQuotaRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.namespaceQuota = ::std::option::Option::None;
        self.storagespaceQuota = ::std::option::Option::None;
        self.storageType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetQuotaResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetQuotaResponseProto {
    fn default() -> &'a SetQuotaResponseProto {
        <SetQuotaResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetQuotaResponseProto {
    pub fn new() -> SetQuotaResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetQuotaResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetQuotaResponseProto {
        SetQuotaResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetQuotaResponseProto>(
                    "SetQuotaResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetQuotaResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetQuotaResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetQuotaResponseProto,
        };
        unsafe {
            instance.get(SetQuotaResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetQuotaResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetQuotaResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetQuotaResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    client: ::protobuf::SingularField<::std::string::String>,
    lastBlockLength: ::std::option::Option<i64>,
    fileId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsyncRequestProto {
    fn default() -> &'a FsyncRequestProto {
        <FsyncRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl FsyncRequestProto {
    pub fn new() -> FsyncRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string client = 2;


    pub fn get_client(&self) -> &str {
        match self.client.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        if self.client.is_none() {
            self.client.set_default();
        }
        self.client.as_mut().unwrap()
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        self.client.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint64 lastBlockLength = 3;


    pub fn get_lastBlockLength(&self) -> i64 {
        self.lastBlockLength.unwrap_or(-1i64)
    }
    pub fn clear_lastBlockLength(&mut self) {
        self.lastBlockLength = ::std::option::Option::None;
    }

    pub fn has_lastBlockLength(&self) -> bool {
        self.lastBlockLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockLength(&mut self, v: i64) {
        self.lastBlockLength = ::std::option::Option::Some(v);
    }

    // optional uint64 fileId = 4;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FsyncRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.client.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.lastBlockLength = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.client.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lastBlockLength {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.client.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lastBlockLength {
            os.write_sint64(3, v)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsyncRequestProto {
        FsyncRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &FsyncRequestProto| { &m.src },
                    |m: &mut FsyncRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client",
                    |m: &FsyncRequestProto| { &m.client },
                    |m: &mut FsyncRequestProto| { &mut m.client },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "lastBlockLength",
                    |m: &FsyncRequestProto| { &m.lastBlockLength },
                    |m: &mut FsyncRequestProto| { &mut m.lastBlockLength },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &FsyncRequestProto| { &m.fileId },
                    |m: &mut FsyncRequestProto| { &mut m.fileId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsyncRequestProto>(
                    "FsyncRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FsyncRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncRequestProto,
        };
        unsafe {
            instance.get(FsyncRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for FsyncRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.client.clear();
        self.lastBlockLength = ::std::option::Option::None;
        self.fileId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsyncResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsyncResponseProto {
    fn default() -> &'a FsyncResponseProto {
        <FsyncResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl FsyncResponseProto {
    pub fn new() -> FsyncResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FsyncResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsyncResponseProto {
        FsyncResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<FsyncResponseProto>(
                    "FsyncResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FsyncResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<FsyncResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsyncResponseProto,
        };
        unsafe {
            instance.get(FsyncResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for FsyncResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsyncResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsyncResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesRequestProto {
    // message fields
    src: ::protobuf::SingularField<::std::string::String>,
    mtime: ::std::option::Option<u64>,
    atime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetTimesRequestProto {
    fn default() -> &'a SetTimesRequestProto {
        <SetTimesRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetTimesRequestProto {
    pub fn new() -> SetTimesRequestProto {
        ::std::default::Default::default()
    }

    // required string src = 1;


    pub fn get_src(&self) -> &str {
        match self.src.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: ::std::string::String) {
        self.src = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut ::std::string::String {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> ::std::string::String {
        self.src.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 mtime = 2;


    pub fn get_mtime(&self) -> u64 {
        self.mtime.unwrap_or(0)
    }
    pub fn clear_mtime(&mut self) {
        self.mtime = ::std::option::Option::None;
    }

    pub fn has_mtime(&self) -> bool {
        self.mtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtime(&mut self, v: u64) {
        self.mtime = ::std::option::Option::Some(v);
    }

    // required uint64 atime = 3;


    pub fn get_atime(&self) -> u64 {
        self.atime.unwrap_or(0)
    }
    pub fn clear_atime(&mut self) {
        self.atime = ::std::option::Option::None;
    }

    pub fn has_atime(&self) -> bool {
        self.atime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_atime(&mut self, v: u64) {
        self.atime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetTimesRequestProto {
    fn is_initialized(&self) -> bool {
        if self.src.is_none() {
            return false;
        }
        if self.mtime.is_none() {
            return false;
        }
        if self.atime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mtime = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.atime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mtime {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.atime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mtime {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.atime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetTimesRequestProto {
        SetTimesRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src",
                    |m: &SetTimesRequestProto| { &m.src },
                    |m: &mut SetTimesRequestProto| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mtime",
                    |m: &SetTimesRequestProto| { &m.mtime },
                    |m: &mut SetTimesRequestProto| { &mut m.mtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "atime",
                    |m: &SetTimesRequestProto| { &m.atime },
                    |m: &mut SetTimesRequestProto| { &mut m.atime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesRequestProto>(
                    "SetTimesRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetTimesRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesRequestProto,
        };
        unsafe {
            instance.get(SetTimesRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetTimesRequestProto {
    fn clear(&mut self) {
        self.src.clear();
        self.mtime = ::std::option::Option::None;
        self.atime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetTimesResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetTimesResponseProto {
    fn default() -> &'a SetTimesResponseProto {
        <SetTimesResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetTimesResponseProto {
    pub fn new() -> SetTimesResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetTimesResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetTimesResponseProto {
        SetTimesResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetTimesResponseProto>(
                    "SetTimesResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetTimesResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetTimesResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetTimesResponseProto,
        };
        unsafe {
            instance.get(SetTimesResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetTimesResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetTimesResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetTimesResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkRequestProto {
    // message fields
    target: ::protobuf::SingularField<::std::string::String>,
    link: ::protobuf::SingularField<::std::string::String>,
    dirPerm: ::protobuf::SingularPtrField<super::hdfs::FsPermissionProto>,
    createParent: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSymlinkRequestProto {
    fn default() -> &'a CreateSymlinkRequestProto {
        <CreateSymlinkRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSymlinkRequestProto {
    pub fn new() -> CreateSymlinkRequestProto {
        ::std::default::Default::default()
    }

    // required string target = 1;


    pub fn get_target(&self) -> &str {
        match self.target.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ::std::string::String) {
        self.target = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ::std::string::String {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ::std::string::String {
        self.target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string link = 2;


    pub fn get_link(&self) -> &str {
        match self.link.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    pub fn has_link(&self) -> bool {
        self.link.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::std::string::String) {
        self.link = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_link(&mut self) -> &mut ::std::string::String {
        if self.link.is_none() {
            self.link.set_default();
        }
        self.link.as_mut().unwrap()
    }

    // Take field
    pub fn take_link(&mut self) -> ::std::string::String {
        self.link.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto dirPerm = 3;


    pub fn get_dirPerm(&self) -> &super::hdfs::FsPermissionProto {
        self.dirPerm.as_ref().unwrap_or_else(|| super::hdfs::FsPermissionProto::default_instance())
    }
    pub fn clear_dirPerm(&mut self) {
        self.dirPerm.clear();
    }

    pub fn has_dirPerm(&self) -> bool {
        self.dirPerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirPerm(&mut self, v: super::hdfs::FsPermissionProto) {
        self.dirPerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirPerm(&mut self) -> &mut super::hdfs::FsPermissionProto {
        if self.dirPerm.is_none() {
            self.dirPerm.set_default();
        }
        self.dirPerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirPerm(&mut self) -> super::hdfs::FsPermissionProto {
        self.dirPerm.take().unwrap_or_else(|| super::hdfs::FsPermissionProto::new())
    }

    // required bool createParent = 4;


    pub fn get_createParent(&self) -> bool {
        self.createParent.unwrap_or(false)
    }
    pub fn clear_createParent(&mut self) {
        self.createParent = ::std::option::Option::None;
    }

    pub fn has_createParent(&self) -> bool {
        self.createParent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createParent(&mut self, v: bool) {
        self.createParent = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CreateSymlinkRequestProto {
    fn is_initialized(&self) -> bool {
        if self.target.is_none() {
            return false;
        }
        if self.link.is_none() {
            return false;
        }
        if self.dirPerm.is_none() {
            return false;
        }
        if self.createParent.is_none() {
            return false;
        }
        for v in &self.dirPerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.link)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirPerm)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.createParent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.target.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.link.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.createParent {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.target.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.link.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.dirPerm.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.createParent {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSymlinkRequestProto {
        CreateSymlinkRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target",
                    |m: &CreateSymlinkRequestProto| { &m.target },
                    |m: &mut CreateSymlinkRequestProto| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "link",
                    |m: &CreateSymlinkRequestProto| { &m.link },
                    |m: &mut CreateSymlinkRequestProto| { &mut m.link },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::FsPermissionProto>>(
                    "dirPerm",
                    |m: &CreateSymlinkRequestProto| { &m.dirPerm },
                    |m: &mut CreateSymlinkRequestProto| { &mut m.dirPerm },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "createParent",
                    |m: &CreateSymlinkRequestProto| { &m.createParent },
                    |m: &mut CreateSymlinkRequestProto| { &mut m.createParent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkRequestProto>(
                    "CreateSymlinkRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSymlinkRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkRequestProto,
        };
        unsafe {
            instance.get(CreateSymlinkRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkRequestProto {
    fn clear(&mut self) {
        self.target.clear();
        self.link.clear();
        self.dirPerm.clear();
        self.createParent = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSymlinkResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSymlinkResponseProto {
    fn default() -> &'a CreateSymlinkResponseProto {
        <CreateSymlinkResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSymlinkResponseProto {
    pub fn new() -> CreateSymlinkResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateSymlinkResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSymlinkResponseProto {
        CreateSymlinkResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CreateSymlinkResponseProto>(
                    "CreateSymlinkResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSymlinkResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSymlinkResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSymlinkResponseProto,
        };
        unsafe {
            instance.get(CreateSymlinkResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateSymlinkResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSymlinkResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSymlinkResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkTargetRequestProto {
    fn default() -> &'a GetLinkTargetRequestProto {
        <GetLinkTargetRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkTargetRequestProto {
    pub fn new() -> GetLinkTargetRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLinkTargetRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkTargetRequestProto {
        GetLinkTargetRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &GetLinkTargetRequestProto| { &m.path },
                    |m: &mut GetLinkTargetRequestProto| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetRequestProto>(
                    "GetLinkTargetRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetLinkTargetRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetRequestProto,
        };
        unsafe {
            instance.get(GetLinkTargetRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetLinkTargetResponseProto {
    // message fields
    targetPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLinkTargetResponseProto {
    fn default() -> &'a GetLinkTargetResponseProto {
        <GetLinkTargetResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetLinkTargetResponseProto {
    pub fn new() -> GetLinkTargetResponseProto {
        ::std::default::Default::default()
    }

    // optional string targetPath = 1;


    pub fn get_targetPath(&self) -> &str {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::string::String) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::string::String {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::string::String {
        self.targetPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetLinkTargetResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLinkTargetResponseProto {
        GetLinkTargetResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetPath",
                    |m: &GetLinkTargetResponseProto| { &m.targetPath },
                    |m: &mut GetLinkTargetResponseProto| { &mut m.targetPath },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetLinkTargetResponseProto>(
                    "GetLinkTargetResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetLinkTargetResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetLinkTargetResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetLinkTargetResponseProto,
        };
        unsafe {
            instance.get(GetLinkTargetResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetLinkTargetResponseProto {
    fn clear(&mut self) {
        self.targetPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetLinkTargetResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLinkTargetResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineRequestProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBlockForPipelineRequestProto {
    fn default() -> &'a UpdateBlockForPipelineRequestProto {
        <UpdateBlockForPipelineRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBlockForPipelineRequestProto {
    pub fn new() -> UpdateBlockForPipelineRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBlockForPipelineRequestProto {
        UpdateBlockForPipelineRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "block",
                    |m: &UpdateBlockForPipelineRequestProto| { &m.block },
                    |m: &mut UpdateBlockForPipelineRequestProto| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &UpdateBlockForPipelineRequestProto| { &m.clientName },
                    |m: &mut UpdateBlockForPipelineRequestProto| { &mut m.clientName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineRequestProto>(
                    "UpdateBlockForPipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateBlockForPipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineRequestProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineRequestProto {
    fn clear(&mut self) {
        self.block.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateBlockForPipelineResponseProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::LocatedBlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateBlockForPipelineResponseProto {
    fn default() -> &'a UpdateBlockForPipelineResponseProto {
        <UpdateBlockForPipelineResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdateBlockForPipelineResponseProto {
    pub fn new() -> UpdateBlockForPipelineResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::LocatedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::LocatedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::LocatedBlockProto::new())
    }
}

impl ::protobuf::Message for UpdateBlockForPipelineResponseProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateBlockForPipelineResponseProto {
        UpdateBlockForPipelineResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::LocatedBlockProto>>(
                    "block",
                    |m: &UpdateBlockForPipelineResponseProto| { &m.block },
                    |m: &mut UpdateBlockForPipelineResponseProto| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateBlockForPipelineResponseProto>(
                    "UpdateBlockForPipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateBlockForPipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdateBlockForPipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateBlockForPipelineResponseProto,
        };
        unsafe {
            instance.get(UpdateBlockForPipelineResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for UpdateBlockForPipelineResponseProto {
    fn clear(&mut self) {
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateBlockForPipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateBlockForPipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    oldBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newBlock: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    newNodes: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>,
    storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePipelineRequestProto {
    fn default() -> &'a UpdatePipelineRequestProto {
        <UpdatePipelineRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePipelineRequestProto {
    pub fn new() -> UpdatePipelineRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto oldBlock = 2;


    pub fn get_oldBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.oldBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_oldBlock(&mut self) {
        self.oldBlock.clear();
    }

    pub fn has_oldBlock(&self) -> bool {
        self.oldBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oldBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.oldBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oldBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.oldBlock.is_none() {
            self.oldBlock.set_default();
        }
        self.oldBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_oldBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.oldBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // required .hadoop.hdfs.ExtendedBlockProto newBlock = 3;


    pub fn get_newBlock(&self) -> &super::hdfs::ExtendedBlockProto {
        self.newBlock.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_newBlock(&mut self) {
        self.newBlock.clear();
    }

    pub fn has_newBlock(&self) -> bool {
        self.newBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newBlock(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.newBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newBlock(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.newBlock.is_none() {
            self.newBlock.set_default();
        }
        self.newBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_newBlock(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.newBlock.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeIDProto newNodes = 4;


    pub fn get_newNodes(&self) -> &[super::hdfs::DatanodeIDProto] {
        &self.newNodes
    }
    pub fn clear_newNodes(&mut self) {
        self.newNodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_newNodes(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto>) {
        self.newNodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_newNodes(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        &mut self.newNodes
    }

    // Take field
    pub fn take_newNodes(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeIDProto> {
        ::std::mem::replace(&mut self.newNodes, ::protobuf::RepeatedField::new())
    }

    // repeated string storageIDs = 5;


    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }
    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UpdatePipelineRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        if self.oldBlock.is_none() {
            return false;
        }
        if self.newBlock.is_none() {
            return false;
        }
        for v in &self.oldBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.newNodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.oldBlock)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.newBlock)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.newNodes)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.newNodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.oldBlock.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.newBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.newNodes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.storageIDs {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePipelineRequestProto {
        UpdatePipelineRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &UpdatePipelineRequestProto| { &m.clientName },
                    |m: &mut UpdatePipelineRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "oldBlock",
                    |m: &UpdatePipelineRequestProto| { &m.oldBlock },
                    |m: &mut UpdatePipelineRequestProto| { &mut m.oldBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "newBlock",
                    |m: &UpdatePipelineRequestProto| { &m.newBlock },
                    |m: &mut UpdatePipelineRequestProto| { &mut m.newBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeIDProto>>(
                    "newNodes",
                    |m: &UpdatePipelineRequestProto| { &m.newNodes },
                    |m: &mut UpdatePipelineRequestProto| { &mut m.newNodes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageIDs",
                    |m: &UpdatePipelineRequestProto| { &m.storageIDs },
                    |m: &mut UpdatePipelineRequestProto| { &mut m.storageIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineRequestProto>(
                    "UpdatePipelineRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePipelineRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineRequestProto,
        };
        unsafe {
            instance.get(UpdatePipelineRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.oldBlock.clear();
        self.newBlock.clear();
        self.newNodes.clear();
        self.storageIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdatePipelineResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdatePipelineResponseProto {
    fn default() -> &'a UpdatePipelineResponseProto {
        <UpdatePipelineResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl UpdatePipelineResponseProto {
    pub fn new() -> UpdatePipelineResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdatePipelineResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdatePipelineResponseProto {
        UpdatePipelineResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<UpdatePipelineResponseProto>(
                    "UpdatePipelineResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdatePipelineResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<UpdatePipelineResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdatePipelineResponseProto,
        };
        unsafe {
            instance.get(UpdatePipelineResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for UpdatePipelineResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdatePipelineResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdatePipelineResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthRequestProto {
    // message fields
    bandwidth: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetBalancerBandwidthRequestProto {
    fn default() -> &'a SetBalancerBandwidthRequestProto {
        <SetBalancerBandwidthRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl SetBalancerBandwidthRequestProto {
    pub fn new() -> SetBalancerBandwidthRequestProto {
        ::std::default::Default::default()
    }

    // required int64 bandwidth = 1;


    pub fn get_bandwidth(&self) -> i64 {
        self.bandwidth.unwrap_or(0)
    }
    pub fn clear_bandwidth(&mut self) {
        self.bandwidth = ::std::option::Option::None;
    }

    pub fn has_bandwidth(&self) -> bool {
        self.bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth(&mut self, v: i64) {
        self.bandwidth = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SetBalancerBandwidthRequestProto {
    fn is_initialized(&self) -> bool {
        if self.bandwidth.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bandwidth = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bandwidth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bandwidth {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetBalancerBandwidthRequestProto {
        SetBalancerBandwidthRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bandwidth",
                    |m: &SetBalancerBandwidthRequestProto| { &m.bandwidth },
                    |m: &mut SetBalancerBandwidthRequestProto| { &mut m.bandwidth },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthRequestProto>(
                    "SetBalancerBandwidthRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetBalancerBandwidthRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthRequestProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthRequestProto {
    fn clear(&mut self) {
        self.bandwidth = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetBalancerBandwidthResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetBalancerBandwidthResponseProto {
    fn default() -> &'a SetBalancerBandwidthResponseProto {
        <SetBalancerBandwidthResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl SetBalancerBandwidthResponseProto {
    pub fn new() -> SetBalancerBandwidthResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetBalancerBandwidthResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetBalancerBandwidthResponseProto {
        SetBalancerBandwidthResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetBalancerBandwidthResponseProto>(
                    "SetBalancerBandwidthResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetBalancerBandwidthResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<SetBalancerBandwidthResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetBalancerBandwidthResponseProto,
        };
        unsafe {
            instance.get(SetBalancerBandwidthResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for SetBalancerBandwidthResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetBalancerBandwidthResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetBalancerBandwidthResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataEncryptionKeyRequestProto {
    fn default() -> &'a GetDataEncryptionKeyRequestProto {
        <GetDataEncryptionKeyRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDataEncryptionKeyRequestProto {
    pub fn new() -> GetDataEncryptionKeyRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataEncryptionKeyRequestProto {
        GetDataEncryptionKeyRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyRequestProto>(
                    "GetDataEncryptionKeyRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDataEncryptionKeyRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyRequestProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDataEncryptionKeyResponseProto {
    // message fields
    dataEncryptionKey: ::protobuf::SingularPtrField<super::hdfs::DataEncryptionKeyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDataEncryptionKeyResponseProto {
    fn default() -> &'a GetDataEncryptionKeyResponseProto {
        <GetDataEncryptionKeyResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetDataEncryptionKeyResponseProto {
    pub fn new() -> GetDataEncryptionKeyResponseProto {
        ::std::default::Default::default()
    }

    // optional .hadoop.hdfs.DataEncryptionKeyProto dataEncryptionKey = 1;


    pub fn get_dataEncryptionKey(&self) -> &super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.as_ref().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::default_instance())
    }
    pub fn clear_dataEncryptionKey(&mut self) {
        self.dataEncryptionKey.clear();
    }

    pub fn has_dataEncryptionKey(&self) -> bool {
        self.dataEncryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataEncryptionKey(&mut self, v: super::hdfs::DataEncryptionKeyProto) {
        self.dataEncryptionKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataEncryptionKey(&mut self) -> &mut super::hdfs::DataEncryptionKeyProto {
        if self.dataEncryptionKey.is_none() {
            self.dataEncryptionKey.set_default();
        }
        self.dataEncryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataEncryptionKey(&mut self) -> super::hdfs::DataEncryptionKeyProto {
        self.dataEncryptionKey.take().unwrap_or_else(|| super::hdfs::DataEncryptionKeyProto::new())
    }
}

impl ::protobuf::Message for GetDataEncryptionKeyResponseProto {
    fn is_initialized(&self) -> bool {
        for v in &self.dataEncryptionKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataEncryptionKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dataEncryptionKey.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDataEncryptionKeyResponseProto {
        GetDataEncryptionKeyResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DataEncryptionKeyProto>>(
                    "dataEncryptionKey",
                    |m: &GetDataEncryptionKeyResponseProto| { &m.dataEncryptionKey },
                    |m: &mut GetDataEncryptionKeyResponseProto| { &mut m.dataEncryptionKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDataEncryptionKeyResponseProto>(
                    "GetDataEncryptionKeyResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDataEncryptionKeyResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetDataEncryptionKeyResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDataEncryptionKeyResponseProto,
        };
        unsafe {
            instance.get(GetDataEncryptionKeyResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetDataEncryptionKeyResponseProto {
    fn clear(&mut self) {
        self.dataEncryptionKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDataEncryptionKeyResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDataEncryptionKeyResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotRequestProto {
    fn default() -> &'a CreateSnapshotRequestProto {
        <CreateSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotRequestProto {
    pub fn new() -> CreateSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string snapshotName = 2;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotRequestProto {
        CreateSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &CreateSnapshotRequestProto| { &m.snapshotRoot },
                    |m: &mut CreateSnapshotRequestProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    |m: &CreateSnapshotRequestProto| { &m.snapshotName },
                    |m: &mut CreateSnapshotRequestProto| { &mut m.snapshotName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotRequestProto>(
                    "CreateSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotRequestProto,
        };
        unsafe {
            instance.get(CreateSnapshotRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateSnapshotResponseProto {
    // message fields
    snapshotPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateSnapshotResponseProto {
    fn default() -> &'a CreateSnapshotResponseProto {
        <CreateSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CreateSnapshotResponseProto {
    pub fn new() -> CreateSnapshotResponseProto {
        ::std::default::Default::default()
    }

    // required string snapshotPath = 1;


    pub fn get_snapshotPath(&self) -> &str {
        match self.snapshotPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotPath(&mut self) {
        self.snapshotPath.clear();
    }

    pub fn has_snapshotPath(&self) -> bool {
        self.snapshotPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotPath(&mut self, v: ::std::string::String) {
        self.snapshotPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotPath(&mut self) -> &mut ::std::string::String {
        if self.snapshotPath.is_none() {
            self.snapshotPath.set_default();
        }
        self.snapshotPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotPath(&mut self) -> ::std::string::String {
        self.snapshotPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotPath.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotPath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotPath.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateSnapshotResponseProto {
        CreateSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotPath",
                    |m: &CreateSnapshotResponseProto| { &m.snapshotPath },
                    |m: &mut CreateSnapshotResponseProto| { &mut m.snapshotPath },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateSnapshotResponseProto>(
                    "CreateSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateSnapshotResponseProto,
        };
        unsafe {
            instance.get(CreateSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateSnapshotResponseProto {
    fn clear(&mut self) {
        self.snapshotPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotOldName: ::protobuf::SingularField<::std::string::String>,
    snapshotNewName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameSnapshotRequestProto {
    fn default() -> &'a RenameSnapshotRequestProto {
        <RenameSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameSnapshotRequestProto {
    pub fn new() -> RenameSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotOldName = 2;


    pub fn get_snapshotOldName(&self) -> &str {
        match self.snapshotOldName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotOldName(&mut self) {
        self.snapshotOldName.clear();
    }

    pub fn has_snapshotOldName(&self) -> bool {
        self.snapshotOldName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotOldName(&mut self, v: ::std::string::String) {
        self.snapshotOldName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotOldName(&mut self) -> &mut ::std::string::String {
        if self.snapshotOldName.is_none() {
            self.snapshotOldName.set_default();
        }
        self.snapshotOldName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotOldName(&mut self) -> ::std::string::String {
        self.snapshotOldName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotNewName = 3;


    pub fn get_snapshotNewName(&self) -> &str {
        match self.snapshotNewName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotNewName(&mut self) {
        self.snapshotNewName.clear();
    }

    pub fn has_snapshotNewName(&self) -> bool {
        self.snapshotNewName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotNewName(&mut self, v: ::std::string::String) {
        self.snapshotNewName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotNewName(&mut self) -> &mut ::std::string::String {
        if self.snapshotNewName.is_none() {
            self.snapshotNewName.set_default();
        }
        self.snapshotNewName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotNewName(&mut self) -> ::std::string::String {
        self.snapshotNewName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RenameSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotOldName.is_none() {
            return false;
        }
        if self.snapshotNewName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotOldName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotNewName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotOldName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.snapshotNewName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameSnapshotRequestProto {
        RenameSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &RenameSnapshotRequestProto| { &m.snapshotRoot },
                    |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotOldName",
                    |m: &RenameSnapshotRequestProto| { &m.snapshotOldName },
                    |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotOldName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotNewName",
                    |m: &RenameSnapshotRequestProto| { &m.snapshotNewName },
                    |m: &mut RenameSnapshotRequestProto| { &mut m.snapshotNewName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotRequestProto>(
                    "RenameSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenameSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotRequestProto,
        };
        unsafe {
            instance.get(RenameSnapshotRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotOldName.clear();
        self.snapshotNewName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RenameSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RenameSnapshotResponseProto {
    fn default() -> &'a RenameSnapshotResponseProto {
        <RenameSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl RenameSnapshotResponseProto {
    pub fn new() -> RenameSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RenameSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RenameSnapshotResponseProto {
        RenameSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<RenameSnapshotResponseProto>(
                    "RenameSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RenameSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<RenameSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RenameSnapshotResponseProto,
        };
        unsafe {
            instance.get(RenameSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for RenameSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RenameSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenameSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowSnapshotRequestProto {
    fn default() -> &'a AllowSnapshotRequestProto {
        <AllowSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl AllowSnapshotRequestProto {
    pub fn new() -> AllowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AllowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowSnapshotRequestProto {
        AllowSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &AllowSnapshotRequestProto| { &m.snapshotRoot },
                    |m: &mut AllowSnapshotRequestProto| { &mut m.snapshotRoot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotRequestProto>(
                    "AllowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotRequestProto,
        };
        unsafe {
            instance.get(AllowSnapshotRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowSnapshotResponseProto {
    fn default() -> &'a AllowSnapshotResponseProto {
        <AllowSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl AllowSnapshotResponseProto {
    pub fn new() -> AllowSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AllowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowSnapshotResponseProto {
        AllowSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<AllowSnapshotResponseProto>(
                    "AllowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AllowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<AllowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AllowSnapshotResponseProto,
        };
        unsafe {
            instance.get(AllowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for AllowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisallowSnapshotRequestProto {
    fn default() -> &'a DisallowSnapshotRequestProto {
        <DisallowSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DisallowSnapshotRequestProto {
    pub fn new() -> DisallowSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DisallowSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisallowSnapshotRequestProto {
        DisallowSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &DisallowSnapshotRequestProto| { &m.snapshotRoot },
                    |m: &mut DisallowSnapshotRequestProto| { &mut m.snapshotRoot },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotRequestProto>(
                    "DisallowSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisallowSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotRequestProto,
        };
        unsafe {
            instance.get(DisallowSnapshotRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisallowSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisallowSnapshotResponseProto {
    fn default() -> &'a DisallowSnapshotResponseProto {
        <DisallowSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DisallowSnapshotResponseProto {
    pub fn new() -> DisallowSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisallowSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisallowSnapshotResponseProto {
        DisallowSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DisallowSnapshotResponseProto>(
                    "DisallowSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DisallowSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DisallowSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DisallowSnapshotResponseProto,
        };
        unsafe {
            instance.get(DisallowSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for DisallowSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisallowSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisallowSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotRequestProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotRequestProto {
    fn default() -> &'a DeleteSnapshotRequestProto {
        <DeleteSnapshotRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotRequestProto {
    pub fn new() -> DeleteSnapshotRequestProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotName = 2;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteSnapshotRequestProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.snapshotName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotRequestProto {
        DeleteSnapshotRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &DeleteSnapshotRequestProto| { &m.snapshotRoot },
                    |m: &mut DeleteSnapshotRequestProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    |m: &DeleteSnapshotRequestProto| { &m.snapshotName },
                    |m: &mut DeleteSnapshotRequestProto| { &mut m.snapshotName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotRequestProto>(
                    "DeleteSnapshotRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteSnapshotRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotRequestProto,
        };
        unsafe {
            instance.get(DeleteSnapshotRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotRequestProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.snapshotName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteSnapshotResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteSnapshotResponseProto {
    fn default() -> &'a DeleteSnapshotResponseProto {
        <DeleteSnapshotResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSnapshotResponseProto {
    pub fn new() -> DeleteSnapshotResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteSnapshotResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteSnapshotResponseProto {
        DeleteSnapshotResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DeleteSnapshotResponseProto>(
                    "DeleteSnapshotResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteSnapshotResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<DeleteSnapshotResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteSnapshotResponseProto,
        };
        unsafe {
            instance.get(DeleteSnapshotResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for DeleteSnapshotResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteSnapshotResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSnapshotResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessRequestProto {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<super::acl::AclEntryProto_FsActionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckAccessRequestProto {
    fn default() -> &'a CheckAccessRequestProto {
        <CheckAccessRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckAccessRequestProto {
    pub fn new() -> CheckAccessRequestProto {
        ::std::default::Default::default()
    }

    // required string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.AclEntryProto.FsActionProto mode = 2;


    pub fn get_mode(&self) -> super::acl::AclEntryProto_FsActionProto {
        self.mode.unwrap_or(super::acl::AclEntryProto_FsActionProto::NONE)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: super::acl::AclEntryProto_FsActionProto) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CheckAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.path.is_none() {
            return false;
        }
        if self.mode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_enum(2, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckAccessRequestProto {
        CheckAccessRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    |m: &CheckAccessRequestProto| { &m.path },
                    |m: &mut CheckAccessRequestProto| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::acl::AclEntryProto_FsActionProto>>(
                    "mode",
                    |m: &CheckAccessRequestProto| { &m.mode },
                    |m: &mut CheckAccessRequestProto| { &mut m.mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessRequestProto>(
                    "CheckAccessRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CheckAccessRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessRequestProto,
        };
        unsafe {
            instance.get(CheckAccessRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for CheckAccessRequestProto {
    fn clear(&mut self) {
        self.path.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckAccessResponseProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckAccessResponseProto {
    fn default() -> &'a CheckAccessResponseProto {
        <CheckAccessResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckAccessResponseProto {
    pub fn new() -> CheckAccessResponseProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckAccessResponseProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckAccessResponseProto {
        CheckAccessResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CheckAccessResponseProto>(
                    "CheckAccessResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CheckAccessResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckAccessResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckAccessResponseProto,
        };
        unsafe {
            instance.get(CheckAccessResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for CheckAccessResponseProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentEditLogTxidRequestProto {
    fn default() -> &'a GetCurrentEditLogTxidRequestProto {
        <GetCurrentEditLogTxidRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentEditLogTxidRequestProto {
    pub fn new() -> GetCurrentEditLogTxidRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentEditLogTxidRequestProto {
        GetCurrentEditLogTxidRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidRequestProto>(
                    "GetCurrentEditLogTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetCurrentEditLogTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidRequestProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCurrentEditLogTxidResponseProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentEditLogTxidResponseProto {
    fn default() -> &'a GetCurrentEditLogTxidResponseProto {
        <GetCurrentEditLogTxidResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentEditLogTxidResponseProto {
    pub fn new() -> GetCurrentEditLogTxidResponseProto {
        ::std::default::Default::default()
    }

    // required int64 txid = 1;


    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetCurrentEditLogTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentEditLogTxidResponseProto {
        GetCurrentEditLogTxidResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    |m: &GetCurrentEditLogTxidResponseProto| { &m.txid },
                    |m: &mut GetCurrentEditLogTxidResponseProto| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetCurrentEditLogTxidResponseProto>(
                    "GetCurrentEditLogTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetCurrentEditLogTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetCurrentEditLogTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetCurrentEditLogTxidResponseProto,
        };
        unsafe {
            instance.get(GetCurrentEditLogTxidResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetCurrentEditLogTxidResponseProto {
    fn clear(&mut self) {
        self.txid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCurrentEditLogTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentEditLogTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidRequestProto {
    // message fields
    txid: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditsFromTxidRequestProto {
    fn default() -> &'a GetEditsFromTxidRequestProto {
        <GetEditsFromTxidRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditsFromTxidRequestProto {
    pub fn new() -> GetEditsFromTxidRequestProto {
        ::std::default::Default::default()
    }

    // required int64 txid = 1;


    pub fn get_txid(&self) -> i64 {
        self.txid.unwrap_or(0)
    }
    pub fn clear_txid(&mut self) {
        self.txid = ::std::option::Option::None;
    }

    pub fn has_txid(&self) -> bool {
        self.txid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: i64) {
        self.txid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetEditsFromTxidRequestProto {
    fn is_initialized(&self) -> bool {
        if self.txid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.txid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txid {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditsFromTxidRequestProto {
        GetEditsFromTxidRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "txid",
                    |m: &GetEditsFromTxidRequestProto| { &m.txid },
                    |m: &mut GetEditsFromTxidRequestProto| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidRequestProto>(
                    "GetEditsFromTxidRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEditsFromTxidRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidRequestProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidRequestProto {
    fn clear(&mut self) {
        self.txid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEditsFromTxidResponseProto {
    // message fields
    eventsList: ::protobuf::SingularPtrField<super::inotify::EventsListProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEditsFromTxidResponseProto {
    fn default() -> &'a GetEditsFromTxidResponseProto {
        <GetEditsFromTxidResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl GetEditsFromTxidResponseProto {
    pub fn new() -> GetEditsFromTxidResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.EventsListProto eventsList = 1;


    pub fn get_eventsList(&self) -> &super::inotify::EventsListProto {
        self.eventsList.as_ref().unwrap_or_else(|| super::inotify::EventsListProto::default_instance())
    }
    pub fn clear_eventsList(&mut self) {
        self.eventsList.clear();
    }

    pub fn has_eventsList(&self) -> bool {
        self.eventsList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsList(&mut self, v: super::inotify::EventsListProto) {
        self.eventsList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventsList(&mut self) -> &mut super::inotify::EventsListProto {
        if self.eventsList.is_none() {
            self.eventsList.set_default();
        }
        self.eventsList.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventsList(&mut self) -> super::inotify::EventsListProto {
        self.eventsList.take().unwrap_or_else(|| super::inotify::EventsListProto::new())
    }
}

impl ::protobuf::Message for GetEditsFromTxidResponseProto {
    fn is_initialized(&self) -> bool {
        if self.eventsList.is_none() {
            return false;
        }
        for v in &self.eventsList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventsList)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.eventsList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.eventsList.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEditsFromTxidResponseProto {
        GetEditsFromTxidResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::inotify::EventsListProto>>(
                    "eventsList",
                    |m: &GetEditsFromTxidResponseProto| { &m.eventsList },
                    |m: &mut GetEditsFromTxidResponseProto| { &mut m.eventsList },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEditsFromTxidResponseProto>(
                    "GetEditsFromTxidResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEditsFromTxidResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<GetEditsFromTxidResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEditsFromTxidResponseProto,
        };
        unsafe {
            instance.get(GetEditsFromTxidResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for GetEditsFromTxidResponseProto {
    fn clear(&mut self) {
        self.eventsList.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEditsFromTxidResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEditsFromTxidResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateFlagProto {
    CREATE = 1,
    OVERWRITE = 2,
    APPEND = 4,
    LAZY_PERSIST = 16,
    NEW_BLOCK = 32,
}

impl ::protobuf::ProtobufEnum for CreateFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CreateFlagProto::CREATE),
            2 => ::std::option::Option::Some(CreateFlagProto::OVERWRITE),
            4 => ::std::option::Option::Some(CreateFlagProto::APPEND),
            16 => ::std::option::Option::Some(CreateFlagProto::LAZY_PERSIST),
            32 => ::std::option::Option::Some(CreateFlagProto::NEW_BLOCK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateFlagProto] = &[
            CreateFlagProto::CREATE,
            CreateFlagProto::OVERWRITE,
            CreateFlagProto::APPEND,
            CreateFlagProto::LAZY_PERSIST,
            CreateFlagProto::NEW_BLOCK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreateFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreateFlagProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CreateFlagProto {
    fn default() -> Self {
        CreateFlagProto::CREATE
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeReportTypeProto {
    ALL = 1,
    LIVE = 2,
    DEAD = 3,
    DECOMMISSIONING = 4,
}

impl ::protobuf::ProtobufEnum for DatanodeReportTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeReportTypeProto> {
        match value {
            1 => ::std::option::Option::Some(DatanodeReportTypeProto::ALL),
            2 => ::std::option::Option::Some(DatanodeReportTypeProto::LIVE),
            3 => ::std::option::Option::Some(DatanodeReportTypeProto::DEAD),
            4 => ::std::option::Option::Some(DatanodeReportTypeProto::DECOMMISSIONING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeReportTypeProto] = &[
            DatanodeReportTypeProto::ALL,
            DatanodeReportTypeProto::LIVE,
            DatanodeReportTypeProto::DEAD,
            DatanodeReportTypeProto::DECOMMISSIONING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeReportTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeReportTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DatanodeReportTypeProto {
    fn default() -> Self {
        DatanodeReportTypeProto::ALL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeReportTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SafeModeActionProto {
    SAFEMODE_LEAVE = 1,
    SAFEMODE_ENTER = 2,
    SAFEMODE_GET = 3,
    SAFEMODE_FORCE_EXIT = 4,
}

impl ::protobuf::ProtobufEnum for SafeModeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SafeModeActionProto> {
        match value {
            1 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_LEAVE),
            2 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_ENTER),
            3 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_GET),
            4 => ::std::option::Option::Some(SafeModeActionProto::SAFEMODE_FORCE_EXIT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SafeModeActionProto] = &[
            SafeModeActionProto::SAFEMODE_LEAVE,
            SafeModeActionProto::SAFEMODE_ENTER,
            SafeModeActionProto::SAFEMODE_GET,
            SafeModeActionProto::SAFEMODE_FORCE_EXIT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SafeModeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SafeModeActionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SafeModeActionProto {
    fn default() -> Self {
        SafeModeActionProto::SAFEMODE_LEAVE
    }
}

impl ::protobuf::reflect::ProtobufValue for SafeModeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RollingUpgradeActionProto {
    QUERY = 1,
    START = 2,
    FINALIZE = 3,
}

impl ::protobuf::ProtobufEnum for RollingUpgradeActionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RollingUpgradeActionProto> {
        match value {
            1 => ::std::option::Option::Some(RollingUpgradeActionProto::QUERY),
            2 => ::std::option::Option::Some(RollingUpgradeActionProto::START),
            3 => ::std::option::Option::Some(RollingUpgradeActionProto::FINALIZE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RollingUpgradeActionProto] = &[
            RollingUpgradeActionProto::QUERY,
            RollingUpgradeActionProto::START,
            RollingUpgradeActionProto::FINALIZE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RollingUpgradeActionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RollingUpgradeActionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for RollingUpgradeActionProto {
    fn default() -> Self {
        RollingUpgradeActionProto::QUERY
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeActionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CacheFlagProto {
    FORCE = 1,
}

impl ::protobuf::ProtobufEnum for CacheFlagProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CacheFlagProto> {
        match value {
            1 => ::std::option::Option::Some(CacheFlagProto::FORCE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CacheFlagProto] = &[
            CacheFlagProto::FORCE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CacheFlagProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CacheFlagProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CacheFlagProto {
    fn default() -> Self {
        CacheFlagProto::FORCE
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheFlagProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cClientNamenodeProtocol.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.pr\
    oto\x1a\nhdfs.proto\x1a\tacl.proto\x1a\x0bxattr.proto\x1a\x10encryption.\
    proto\x1a\rinotify.proto\"L\n\x1dGetBlockLocationsRequestProto\x12\x0b\n\
    \x03src\x18\x01\x20\x02(\t\x12\x0e\n\x06offset\x18\x02\x20\x02(\x04\x12\
    \x0e\n\x06length\x18\x03\x20\x02(\x04\"T\n\x1eGetBlockLocationsResponseP\
    roto\x122\n\tlocations\x18\x01\x20\x01(\x0b2\x1f.hadoop.hdfs.LocatedBloc\
    ksProto\"\x1f\n\x1dGetServerDefaultsRequestProto\"\\\n\x1eGetServerDefau\
    ltsResponseProto\x12:\n\x0eserverDefaults\x18\x01\x20\x02(\x0b2\".hadoop\
    .hdfs.FsServerDefaultsProto\"\xff\x01\n\x12CreateRequestProto\x12\x0b\n\
    \x03src\x18\x01\x20\x02(\t\x12.\n\x06masked\x18\x02\x20\x02(\x0b2\x1e.ha\
    doop.hdfs.FsPermissionProto\x12\x12\n\nclientName\x18\x03\x20\x02(\t\x12\
    \x12\n\ncreateFlag\x18\x04\x20\x02(\r\x12\x14\n\x0ccreateParent\x18\x05\
    \x20\x02(\x08\x12\x13\n\x0breplication\x18\x06\x20\x02(\r\x12\x11\n\tblo\
    ckSize\x18\x07\x20\x02(\x04\x12F\n\x15cryptoProtocolVersion\x18\x08\x20\
    \x03(\x0e2'.hadoop.hdfs.CryptoProtocolVersionProto\"C\n\x13CreateRespons\
    eProto\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hdfs.HdfsFileStatus\
    Proto\"C\n\x12AppendRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\
    \x12\n\nclientName\x18\x02\x20\x02(\t\x12\x0c\n\x04flag\x18\x03\x20\x01(\
    \r\"t\n\x13AppendResponseProto\x12-\n\x05block\x18\x01\x20\x01(\x0b2\x1e\
    .hadoop.hdfs.LocatedBlockProto\x12.\n\x04stat\x18\x02\x20\x01(\x0b2\x20.\
    hadoop.hdfs.HdfsFileStatusProto\">\n\x1aSetReplicationRequestProto\x12\
    \x0b\n\x03src\x18\x01\x20\x02(\t\x12\x13\n\x0breplication\x18\x02\x20\
    \x02(\r\"-\n\x1bSetReplicationResponseProto\x12\x0e\n\x06result\x18\x01\
    \x20\x02(\x08\"?\n\x1cSetStoragePolicyRequestProto\x12\x0b\n\x03src\x18\
    \x01\x20\x02(\t\x12\x12\n\npolicyName\x18\x02\x20\x02(\t\"\x1f\n\x1dSetS\
    toragePolicyResponseProto\",\n\x1cGetStoragePolicyRequestProto\x12\x0c\n\
    \x04path\x18\x01\x20\x02(\t\"\\\n\x1dGetStoragePolicyResponseProto\x12;\
    \n\rstoragePolicy\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.BlockStoragePolicyP\
    roto\"-\n\x1eUnsetStoragePolicyRequestProto\x12\x0b\n\x03src\x18\x01\x20\
    \x02(\t\"!\n\x1fUnsetStoragePolicyResponseProto\"\x20\n\x1eGetStoragePol\
    iciesRequestProto\"Y\n\x1fGetStoragePoliciesResponseProto\x126\n\x08poli\
    cies\x18\x01\x20\x03(\x0b2$.hadoop.hdfs.BlockStoragePolicyProto\"\\\n\
    \x19SetPermissionRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x122\n\
    \npermission\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProto\"\
    \x1c\n\x1aSetPermissionResponseProto\"H\n\x14SetOwnerRequestProto\x12\
    \x0b\n\x03src\x18\x01\x20\x02(\t\x12\x10\n\x08username\x18\x02\x20\x01(\
    \t\x12\x11\n\tgroupname\x18\x03\x20\x01(\t\"\x17\n\x15SetOwnerResponsePr\
    oto\"v\n\x18AbandonBlockRequestProto\x12*\n\x01b\x18\x01\x20\x02(\x0b2\
    \x1f.hadoop.hdfs.ExtendedBlockProto\x12\x0b\n\x03src\x18\x02\x20\x02(\t\
    \x12\x0e\n\x06holder\x18\x03\x20\x02(\t\x12\x11\n\x06fileId\x18\x04\x20\
    \x01(\x04:\x010\"\x1b\n\x19AbandonBlockResponseProto\"\xc9\x01\n\x14AddB\
    lockRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\nclientNa\
    me\x18\x02\x20\x02(\t\x121\n\x08previous\x18\x03\x20\x01(\x0b2\x1f.hadoo\
    p.hdfs.ExtendedBlockProto\x124\n\x0cexcludeNodes\x18\x04\x20\x03(\x0b2\
    \x1e.hadoop.hdfs.DatanodeInfoProto\x12\x11\n\x06fileId\x18\x05\x20\x01(\
    \x04:\x010\x12\x14\n\x0cfavoredNodes\x18\x06\x20\x03(\t\"F\n\x15AddBlock\
    ResponseProto\x12-\n\x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.Loca\
    tedBlockProto\"\xa4\x02\n!GetAdditionalDatanodeRequestProto\x12\x0b\n\
    \x03src\x18\x01\x20\x02(\t\x12,\n\x03blk\x18\x02\x20\x02(\x0b2\x1f.hadoo\
    p.hdfs.ExtendedBlockProto\x121\n\texistings\x18\x03\x20\x03(\x0b2\x1e.ha\
    doop.hdfs.DatanodeInfoProto\x120\n\x08excludes\x18\x04\x20\x03(\x0b2\x1e\
    .hadoop.hdfs.DatanodeInfoProto\x12\x1a\n\x12numAdditionalNodes\x18\x05\
    \x20\x02(\r\x12\x12\n\nclientName\x18\x06\x20\x02(\t\x12\x1c\n\x14existi\
    ngStorageUuids\x18\x07\x20\x03(\t\x12\x11\n\x06fileId\x18\x08\x20\x01(\
    \x04:\x010\"S\n\"GetAdditionalDatanodeResponseProto\x12-\n\x05block\x18\
    \x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\"y\n\x14CompleteReq\
    uestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x12\n\nclientName\x18\
    \x02\x20\x02(\t\x12-\n\x04last\x18\x03\x20\x01(\x0b2\x1f.hadoop.hdfs.Ext\
    endedBlockProto\x12\x11\n\x06fileId\x18\x04\x20\x01(\x04:\x010\"'\n\x15C\
    ompleteResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\"M\n\x1bRe\
    portBadBlocksRequestProto\x12.\n\x06blocks\x18\x01\x20\x03(\x0b2\x1e.had\
    oop.hdfs.LocatedBlockProto\"\x1e\n\x1cReportBadBlocksResponseProto\"/\n\
    \x12ConcatRequestProto\x12\x0b\n\x03trg\x18\x01\x20\x02(\t\x12\x0c\n\x04\
    srcs\x18\x02\x20\x03(\t\"\x15\n\x13ConcatResponseProto\"J\n\x14TruncateR\
    equestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x11\n\tnewLength\x18\
    \x02\x20\x02(\x04\x12\x12\n\nclientName\x18\x03\x20\x02(\t\"'\n\x15Trunc\
    ateResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\".\n\x12Rename\
    RequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\x0b\n\x03dst\x18\
    \x02\x20\x02(\t\"%\n\x13RenameResponseProto\x12\x0e\n\x06result\x18\x01\
    \x20\x02(\x08\"[\n\x13Rename2RequestProto\x12\x0b\n\x03src\x18\x01\x20\
    \x02(\t\x12\x0b\n\x03dst\x18\x02\x20\x02(\t\x12\x15\n\roverwriteDest\x18\
    \x03\x20\x02(\x08\x12\x13\n\x0bmoveToTrash\x18\x04\x20\x01(\x08\"\x16\n\
    \x14Rename2ResponseProto\"4\n\x12DeleteRequestProto\x12\x0b\n\x03src\x18\
    \x01\x20\x02(\t\x12\x11\n\trecursive\x18\x02\x20\x02(\x08\"%\n\x13Delete\
    ResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\"g\n\x12MkdirsReq\
    uestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12.\n\x06masked\x18\x02\
    \x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProto\x12\x14\n\x0ccreatePare\
    nt\x18\x03\x20\x02(\x08\"%\n\x13MkdirsResponseProto\x12\x0e\n\x06result\
    \x18\x01\x20\x02(\x08\"O\n\x16GetListingRequestProto\x12\x0b\n\x03src\
    \x18\x01\x20\x02(\t\x12\x12\n\nstartAfter\x18\x02\x20\x02(\x0c\x12\x14\n\
    \x0cneedLocation\x18\x03\x20\x02(\x08\"N\n\x17GetListingResponseProto\
    \x123\n\x07dirList\x18\x01\x20\x01(\x0b2\".hadoop.hdfs.DirectoryListingP\
    roto\"(\n&GetSnapshottableDirListingRequestProto\"x\n'GetSnapshottableDi\
    rListingResponseProto\x12M\n\x14snapshottableDirList\x18\x01\x20\x01(\
    \x0b2/.hadoop.hdfs.SnapshottableDirectoryListingProto\"c\n!GetSnapshotDi\
    ffReportRequestProto\x12\x14\n\x0csnapshotRoot\x18\x01\x20\x02(\t\x12\
    \x14\n\x0cfromSnapshot\x18\x02\x20\x02(\t\x12\x12\n\ntoSnapshot\x18\x03\
    \x20\x02(\t\"^\n\"GetSnapshotDiffReportResponseProto\x128\n\ndiffReport\
    \x18\x01\x20\x02(\x0b2$.hadoop.hdfs.SnapshotDiffReportProto\",\n\x16Rene\
    wLeaseRequestProto\x12\x12\n\nclientName\x18\x01\x20\x02(\t\"\x19\n\x17R\
    enewLeaseResponseProto\";\n\x18RecoverLeaseRequestProto\x12\x0b\n\x03src\
    \x18\x01\x20\x02(\t\x12\x12\n\nclientName\x18\x02\x20\x02(\t\"+\n\x19Rec\
    overLeaseResponseProto\x12\x0e\n\x06result\x18\x01\x20\x02(\x08\"\x19\n\
    \x17GetFsStatusRequestProto\"\xd1\x01\n\x17GetFsStatsResponseProto\x12\
    \x10\n\x08capacity\x18\x01\x20\x02(\x04\x12\x0c\n\x04used\x18\x02\x20\
    \x02(\x04\x12\x11\n\tremaining\x18\x03\x20\x02(\x04\x12\x18\n\x10under_r\
    eplicated\x18\x04\x20\x02(\x04\x12\x16\n\x0ecorrupt_blocks\x18\x05\x20\
    \x02(\x04\x12\x16\n\x0emissing_blocks\x18\x06\x20\x02(\x04\x12\x1f\n\x17\
    missing_repl_one_blocks\x18\x07\x20\x01(\x04\x12\x18\n\x10blocks_in_futu\
    re\x18\x08\x20\x01(\x04\"S\n\x1dGetDatanodeReportRequestProto\x122\n\x04\
    type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.DatanodeReportTypeProto\"L\n\x1e\
    GetDatanodeReportResponseProto\x12*\n\x02di\x18\x01\x20\x03(\x0b2\x1e.ha\
    doop.hdfs.DatanodeInfoProto\"Z\n$GetDatanodeStorageReportRequestProto\
    \x122\n\x04type\x18\x01\x20\x02(\x0e2$.hadoop.hdfs.DatanodeReportTypePro\
    to\"\x8b\x01\n\x1aDatanodeStorageReportProto\x124\n\x0cdatanodeInfo\x18\
    \x01\x20\x02(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x127\n\x0estorageRe\
    ports\x18\x02\x20\x03(\x0b2\x1f.hadoop.hdfs.StorageReportProto\"p\n%GetD\
    atanodeStorageReportResponseProto\x12G\n\x16datanodeStorageReports\x18\
    \x01\x20\x03(\x0b2'.hadoop.hdfs.DatanodeStorageReportProto\"5\n!GetPrefe\
    rredBlockSizeRequestProto\x12\x10\n\x08filename\x18\x01\x20\x02(\t\"3\n\
    \"GetPreferredBlockSizeResponseProto\x12\r\n\x05bsize\x18\x01\x20\x02(\
    \x04\"c\n\x17SetSafeModeRequestProto\x120\n\x06action\x18\x01\x20\x02(\
    \x0e2\x20.hadoop.hdfs.SafeModeActionProto\x12\x16\n\x07checked\x18\x02\
    \x20\x01(\x08:\x05false\"*\n\x18SetSafeModeResponseProto\x12\x0e\n\x06re\
    sult\x18\x01\x20\x02(\x08\"\x1b\n\x19SaveNamespaceRequestProto\"\x1c\n\
    \x1aSaveNamespaceResponseProto\"\x17\n\x15RollEditsRequestProto\"0\n\x16\
    RollEditsResponseProto\x12\x16\n\x0enewSegmentTxId\x18\x01\x20\x02(\x04\
    \"/\n\x20RestoreFailedStorageRequestProto\x12\x0b\n\x03arg\x18\x01\x20\
    \x02(\t\"3\n!RestoreFailedStorageResponseProto\x12\x0e\n\x06result\x18\
    \x01\x20\x02(\x08\"\x1a\n\x18RefreshNodesRequestProto\"\x1b\n\x19Refresh\
    NodesResponseProto\"\x1d\n\x1bFinalizeUpgradeRequestProto\"\x1e\n\x1cFin\
    alizeUpgradeResponseProto\"T\n\x1aRollingUpgradeRequestProto\x126\n\x06a\
    ction\x18\x01\x20\x02(\x0e2&.hadoop.hdfs.RollingUpgradeActionProto\"\x99\
    \x01\n\x17RollingUpgradeInfoProto\x126\n\x06status\x18\x01\x20\x02(\x0b2\
    &.hadoop.hdfs.RollingUpgradeStatusProto\x12\x11\n\tstartTime\x18\x02\x20\
    \x02(\x04\x12\x14\n\x0cfinalizeTime\x18\x03\x20\x02(\x04\x12\x1d\n\x15cr\
    eatedRollbackImages\x18\x04\x20\x02(\x08\"_\n\x1bRollingUpgradeResponseP\
    roto\x12@\n\x12rollingUpgradeInfo\x18\x01\x20\x01(\x0b2$.hadoop.hdfs.Rol\
    lingUpgradeInfoProto\"A\n!ListCorruptFileBlocksRequestProto\x12\x0c\n\
    \x04path\x18\x01\x20\x02(\t\x12\x0e\n\x06cookie\x18\x02\x20\x01(\t\"Z\n\
    \"ListCorruptFileBlocksResponseProto\x124\n\x07corrupt\x18\x01\x20\x02(\
    \x0b2#.hadoop.hdfs.CorruptFileBlocksProto\"(\n\x14MetaSaveRequestProto\
    \x12\x10\n\x08filename\x18\x01\x20\x02(\t\"\x17\n\x15MetaSaveResponsePro\
    to\"&\n\x17GetFileInfoRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\"\
    H\n\x18GetFileInfoResponseProto\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.h\
    adoop.hdfs.HdfsFileStatusProto\"'\n\x18IsFileClosedRequestProto\x12\x0b\
    \n\x03src\x18\x01\x20\x02(\t\"+\n\x19IsFileClosedResponseProto\x12\x0e\n\
    \x06result\x18\x01\x20\x02(\x08\"\x9a\x01\n\x17CacheDirectiveInfoProto\
    \x12\n\n\x02id\x18\x01\x20\x01(\x03\x12\x0c\n\x04path\x18\x02\x20\x01(\t\
    \x12\x13\n\x0breplication\x18\x03\x20\x01(\r\x12\x0c\n\x04pool\x18\x04\
    \x20\x01(\t\x12B\n\nexpiration\x18\x05\x20\x01(\x0b2..hadoop.hdfs.CacheD\
    irectiveInfoExpirationProto\"G\n!CacheDirectiveInfoExpirationProto\x12\
    \x0e\n\x06millis\x18\x01\x20\x02(\x03\x12\x12\n\nisRelative\x18\x02\x20\
    \x02(\x08\"\x82\x01\n\x18CacheDirectiveStatsProto\x12\x13\n\x0bbytesNeed\
    ed\x18\x01\x20\x02(\x03\x12\x13\n\x0bbytesCached\x18\x02\x20\x02(\x03\
    \x12\x13\n\x0bfilesNeeded\x18\x03\x20\x02(\x03\x12\x13\n\x0bfilesCached\
    \x18\x04\x20\x02(\x03\x12\x12\n\nhasExpired\x18\x05\x20\x02(\x08\"g\n\
    \x1dAddCacheDirectiveRequestProto\x122\n\x04info\x18\x01\x20\x02(\x0b2$.\
    hadoop.hdfs.CacheDirectiveInfoProto\x12\x12\n\ncacheFlags\x18\x02\x20\
    \x01(\r\",\n\x1eAddCacheDirectiveResponseProto\x12\n\n\x02id\x18\x01\x20\
    \x02(\x03\"j\n\x20ModifyCacheDirectiveRequestProto\x122\n\x04info\x18\
    \x01\x20\x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProto\x12\x12\n\ncache\
    Flags\x18\x02\x20\x01(\r\"#\n!ModifyCacheDirectiveResponseProto\".\n\x20\
    RemoveCacheDirectiveRequestProto\x12\n\n\x02id\x18\x01\x20\x02(\x03\"#\n\
    !RemoveCacheDirectiveResponseProto\"g\n\x1fListCacheDirectivesRequestPro\
    to\x12\x0e\n\x06prevId\x18\x01\x20\x02(\x03\x124\n\x06filter\x18\x02\x20\
    \x02(\x0b2$.hadoop.hdfs.CacheDirectiveInfoProto\"\x84\x01\n\x18CacheDire\
    ctiveEntryProto\x122\n\x04info\x18\x01\x20\x02(\x0b2$.hadoop.hdfs.CacheD\
    irectiveInfoProto\x124\n\x05stats\x18\x02\x20\x02(\x0b2%.hadoop.hdfs.Cac\
    heDirectiveStatsProto\"l\n\x20ListCacheDirectivesResponseProto\x127\n\
    \x08elements\x18\x01\x20\x03(\x0b2%.hadoop.hdfs.CacheDirectiveEntryProto\
    \x12\x0f\n\x07hasMore\x18\x02\x20\x02(\x08\"\x84\x01\n\x12CachePoolInfoP\
    roto\x12\x10\n\x08poolName\x18\x01\x20\x01(\t\x12\x11\n\townerName\x18\
    \x02\x20\x01(\t\x12\x11\n\tgroupName\x18\x03\x20\x01(\t\x12\x0c\n\x04mod\
    e\x18\x04\x20\x01(\x05\x12\r\n\x05limit\x18\x05\x20\x01(\x03\x12\x19\n\
    \x11maxRelativeExpiry\x18\x06\x20\x01(\x03\"\x81\x01\n\x13CachePoolStats\
    Proto\x12\x13\n\x0bbytesNeeded\x18\x01\x20\x02(\x03\x12\x13\n\x0bbytesCa\
    ched\x18\x02\x20\x02(\x03\x12\x16\n\x0ebytesOverlimit\x18\x03\x20\x02(\
    \x03\x12\x13\n\x0bfilesNeeded\x18\x04\x20\x02(\x03\x12\x13\n\x0bfilesCac\
    hed\x18\x05\x20\x02(\x03\"I\n\x18AddCachePoolRequestProto\x12-\n\x04info\
    \x18\x01\x20\x02(\x0b2\x1f.hadoop.hdfs.CachePoolInfoProto\"\x1b\n\x19Add\
    CachePoolResponseProto\"L\n\x1bModifyCachePoolRequestProto\x12-\n\x04inf\
    o\x18\x01\x20\x02(\x0b2\x1f.hadoop.hdfs.CachePoolInfoProto\"\x1e\n\x1cMo\
    difyCachePoolResponseProto\"/\n\x1bRemoveCachePoolRequestProto\x12\x10\n\
    \x08poolName\x18\x01\x20\x02(\t\"\x1e\n\x1cRemoveCachePoolResponseProto\
    \"2\n\x1aListCachePoolsRequestProto\x12\x14\n\x0cprevPoolName\x18\x01\
    \x20\x02(\t\"a\n\x1bListCachePoolsResponseProto\x121\n\x07entries\x18\
    \x01\x20\x03(\x0b2\x20.hadoop.hdfs.CachePoolEntryProto\x12\x0f\n\x07hasM\
    ore\x18\x02\x20\x02(\x08\"u\n\x13CachePoolEntryProto\x12-\n\x04info\x18\
    \x01\x20\x02(\x0b2\x1f.hadoop.hdfs.CachePoolInfoProto\x12/\n\x05stats\
    \x18\x02\x20\x02(\x0b2\x20.hadoop.hdfs.CachePoolStatsProto\"*\n\x1bGetFi\
    leLinkInfoRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\"L\n\x1cGetFi\
    leLinkInfoResponseProto\x12,\n\x02fs\x18\x01\x20\x01(\x0b2\x20.hadoop.hd\
    fs.HdfsFileStatusProto\"-\n\x1dGetContentSummaryRequestProto\x12\x0c\n\
    \x04path\x18\x01\x20\x02(\t\"S\n\x1eGetContentSummaryResponseProto\x121\
    \n\x07summary\x18\x01\x20\x02(\x0b2\x20.hadoop.hdfs.ContentSummaryProto\
    \")\n\x19GetQuotaUsageRequestProto\x12\x0c\n\x04path\x18\x01\x20\x02(\t\
    \"I\n\x1aGetQuotaUsageResponseProto\x12+\n\x05usage\x18\x01\x20\x02(\x0b\
    2\x1c.hadoop.hdfs.QuotaUsageProto\"\x8b\x01\n\x14SetQuotaRequestProto\
    \x12\x0c\n\x04path\x18\x01\x20\x02(\t\x12\x16\n\x0enamespaceQuota\x18\
    \x02\x20\x02(\x04\x12\x19\n\x11storagespaceQuota\x18\x03\x20\x02(\x04\
    \x122\n\x0bstorageType\x18\x04\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageType\
    Proto\"\x17\n\x15SetQuotaResponseProto\"`\n\x11FsyncRequestProto\x12\x0b\
    \n\x03src\x18\x01\x20\x02(\t\x12\x0e\n\x06client\x18\x02\x20\x02(\t\x12\
    \x1b\n\x0flastBlockLength\x18\x03\x20\x01(\x12:\x02-1\x12\x11\n\x06fileI\
    d\x18\x04\x20\x01(\x04:\x010\"\x14\n\x12FsyncResponseProto\"A\n\x14SetTi\
    mesRequestProto\x12\x0b\n\x03src\x18\x01\x20\x02(\t\x12\r\n\x05mtime\x18\
    \x02\x20\x02(\x04\x12\r\n\x05atime\x18\x03\x20\x02(\x04\"\x17\n\x15SetTi\
    mesResponseProto\"\x80\x01\n\x19CreateSymlinkRequestProto\x12\x0e\n\x06t\
    arget\x18\x01\x20\x02(\t\x12\x0c\n\x04link\x18\x02\x20\x02(\t\x12/\n\x07\
    dirPerm\x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProto\x12\x14\
    \n\x0ccreateParent\x18\x04\x20\x02(\x08\"\x1c\n\x1aCreateSymlinkResponse\
    Proto\")\n\x19GetLinkTargetRequestProto\x12\x0c\n\x04path\x18\x01\x20\
    \x02(\t\"0\n\x1aGetLinkTargetResponseProto\x12\x12\n\ntargetPath\x18\x01\
    \x20\x01(\t\"h\n\"UpdateBlockForPipelineRequestProto\x12.\n\x05block\x18\
    \x01\x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProto\x12\x12\n\nclientN\
    ame\x18\x02\x20\x02(\t\"T\n#UpdateBlockForPipelineResponseProto\x12-\n\
    \x05block\x18\x01\x20\x02(\x0b2\x1e.hadoop.hdfs.LocatedBlockProto\"\xda\
    \x01\n\x1aUpdatePipelineRequestProto\x12\x12\n\nclientName\x18\x01\x20\
    \x02(\t\x121\n\x08oldBlock\x18\x02\x20\x02(\x0b2\x1f.hadoop.hdfs.Extende\
    dBlockProto\x121\n\x08newBlock\x18\x03\x20\x02(\x0b2\x1f.hadoop.hdfs.Ext\
    endedBlockProto\x12.\n\x08newNodes\x18\x04\x20\x03(\x0b2\x1c.hadoop.hdfs\
    .DatanodeIDProto\x12\x12\n\nstorageIDs\x18\x05\x20\x03(\t\"\x1d\n\x1bUpd\
    atePipelineResponseProto\"5\n\x20SetBalancerBandwidthRequestProto\x12\
    \x11\n\tbandwidth\x18\x01\x20\x02(\x03\"#\n!SetBalancerBandwidthResponse\
    Proto\"\"\n\x20GetDataEncryptionKeyRequestProto\"c\n!GetDataEncryptionKe\
    yResponseProto\x12>\n\x11dataEncryptionKey\x18\x01\x20\x01(\x0b2#.hadoop\
    .hdfs.DataEncryptionKeyProto\"H\n\x1aCreateSnapshotRequestProto\x12\x14\
    \n\x0csnapshotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0csnapshotName\x18\x02\
    \x20\x01(\t\"3\n\x1bCreateSnapshotResponseProto\x12\x14\n\x0csnapshotPat\
    h\x18\x01\x20\x02(\t\"d\n\x1aRenameSnapshotRequestProto\x12\x14\n\x0csna\
    pshotRoot\x18\x01\x20\x02(\t\x12\x17\n\x0fsnapshotOldName\x18\x02\x20\
    \x02(\t\x12\x17\n\x0fsnapshotNewName\x18\x03\x20\x02(\t\"\x1d\n\x1bRenam\
    eSnapshotResponseProto\"1\n\x19AllowSnapshotRequestProto\x12\x14\n\x0csn\
    apshotRoot\x18\x01\x20\x02(\t\"\x1c\n\x1aAllowSnapshotResponseProto\"4\n\
    \x1cDisallowSnapshotRequestProto\x12\x14\n\x0csnapshotRoot\x18\x01\x20\
    \x02(\t\"\x1f\n\x1dDisallowSnapshotResponseProto\"H\n\x1aDeleteSnapshotR\
    equestProto\x12\x14\n\x0csnapshotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0csn\
    apshotName\x18\x02\x20\x02(\t\"\x1d\n\x1bDeleteSnapshotResponseProto\"_\
    \n\x17CheckAccessRequestProto\x12\x0c\n\x04path\x18\x01\x20\x02(\t\x126\
    \n\x04mode\x18\x02\x20\x02(\x0e2(.hadoop.hdfs.AclEntryProto.FsActionProt\
    o\"\x1a\n\x18CheckAccessResponseProto\"#\n!GetCurrentEditLogTxidRequestP\
    roto\"2\n\"GetCurrentEditLogTxidResponseProto\x12\x0c\n\x04txid\x18\x01\
    \x20\x02(\x03\",\n\x1cGetEditsFromTxidRequestProto\x12\x0c\n\x04txid\x18\
    \x01\x20\x02(\x03\"Q\n\x1dGetEditsFromTxidResponseProto\x120\n\neventsLi\
    st\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.EventsListProto*Y\n\x0fCreateFl\
    agProto\x12\n\n\x06CREATE\x10\x01\x12\r\n\tOVERWRITE\x10\x02\x12\n\n\x06\
    APPEND\x10\x04\x12\x10\n\x0cLAZY_PERSIST\x10\x10\x12\r\n\tNEW_BLOCK\x10\
    \x20*K\n\x17DatanodeReportTypeProto\x12\x07\n\x03ALL\x10\x01\x12\x08\n\
    \x04LIVE\x10\x02\x12\x08\n\x04DEAD\x10\x03\x12\x13\n\x0fDECOMMISSIONING\
    \x10\x04*h\n\x13SafeModeActionProto\x12\x12\n\x0eSAFEMODE_LEAVE\x10\x01\
    \x12\x12\n\x0eSAFEMODE_ENTER\x10\x02\x12\x10\n\x0cSAFEMODE_GET\x10\x03\
    \x12\x17\n\x13SAFEMODE_FORCE_EXIT\x10\x04*?\n\x19RollingUpgradeActionPro\
    to\x12\t\n\x05QUERY\x10\x01\x12\t\n\x05START\x10\x02\x12\x0c\n\x08FINALI\
    ZE\x10\x03*\x1b\n\x0eCacheFlagProto\x12\t\n\x05FORCE\x10\x012\xeeC\n\x16\
    ClientNamenodeProtocol\x12l\n\x11getBlockLocations\x12*.hadoop.hdfs.GetB\
    lockLocationsRequestProto\x1a+.hadoop.hdfs.GetBlockLocationsResponseProt\
    o\x12l\n\x11getServerDefaults\x12*.hadoop.hdfs.GetServerDefaultsRequestP\
    roto\x1a+.hadoop.hdfs.GetServerDefaultsResponseProto\x12K\n\x06create\
    \x12\x1f.hadoop.hdfs.CreateRequestProto\x1a\x20.hadoop.hdfs.CreateRespon\
    seProto\x12K\n\x06append\x12\x1f.hadoop.hdfs.AppendRequestProto\x1a\x20.\
    hadoop.hdfs.AppendResponseProto\x12c\n\x0esetReplication\x12'.hadoop.hdf\
    s.SetReplicationRequestProto\x1a(.hadoop.hdfs.SetReplicationResponseProt\
    o\x12i\n\x10setStoragePolicy\x12).hadoop.hdfs.SetStoragePolicyRequestPro\
    to\x1a*.hadoop.hdfs.SetStoragePolicyResponseProto\x12o\n\x12unsetStorage\
    Policy\x12+.hadoop.hdfs.UnsetStoragePolicyRequestProto\x1a,.hadoop.hdfs.\
    UnsetStoragePolicyResponseProto\x12i\n\x10getStoragePolicy\x12).hadoop.h\
    dfs.GetStoragePolicyRequestProto\x1a*.hadoop.hdfs.GetStoragePolicyRespon\
    seProto\x12o\n\x12getStoragePolicies\x12+.hadoop.hdfs.GetStoragePolicies\
    RequestProto\x1a,.hadoop.hdfs.GetStoragePoliciesResponseProto\x12`\n\rse\
    tPermission\x12&.hadoop.hdfs.SetPermissionRequestProto\x1a'.hadoop.hdfs.\
    SetPermissionResponseProto\x12Q\n\x08setOwner\x12!.hadoop.hdfs.SetOwnerR\
    equestProto\x1a\".hadoop.hdfs.SetOwnerResponseProto\x12]\n\x0cabandonBlo\
    ck\x12%.hadoop.hdfs.AbandonBlockRequestProto\x1a&.hadoop.hdfs.AbandonBlo\
    ckResponseProto\x12Q\n\x08addBlock\x12!.hadoop.hdfs.AddBlockRequestProto\
    \x1a\".hadoop.hdfs.AddBlockResponseProto\x12x\n\x15getAdditionalDatanode\
    \x12..hadoop.hdfs.GetAdditionalDatanodeRequestProto\x1a/.hadoop.hdfs.Get\
    AdditionalDatanodeResponseProto\x12Q\n\x08complete\x12!.hadoop.hdfs.Comp\
    leteRequestProto\x1a\".hadoop.hdfs.CompleteResponseProto\x12f\n\x0frepor\
    tBadBlocks\x12(.hadoop.hdfs.ReportBadBlocksRequestProto\x1a).hadoop.hdfs\
    .ReportBadBlocksResponseProto\x12K\n\x06concat\x12\x1f.hadoop.hdfs.Conca\
    tRequestProto\x1a\x20.hadoop.hdfs.ConcatResponseProto\x12Q\n\x08truncate\
    \x12!.hadoop.hdfs.TruncateRequestProto\x1a\".hadoop.hdfs.TruncateRespons\
    eProto\x12K\n\x06rename\x12\x1f.hadoop.hdfs.RenameRequestProto\x1a\x20.h\
    adoop.hdfs.RenameResponseProto\x12N\n\x07rename2\x12\x20.hadoop.hdfs.Ren\
    ame2RequestProto\x1a!.hadoop.hdfs.Rename2ResponseProto\x12K\n\x06delete\
    \x12\x1f.hadoop.hdfs.DeleteRequestProto\x1a\x20.hadoop.hdfs.DeleteRespon\
    seProto\x12K\n\x06mkdirs\x12\x1f.hadoop.hdfs.MkdirsRequestProto\x1a\x20.\
    hadoop.hdfs.MkdirsResponseProto\x12W\n\ngetListing\x12#.hadoop.hdfs.GetL\
    istingRequestProto\x1a$.hadoop.hdfs.GetListingResponseProto\x12W\n\nrene\
    wLease\x12#.hadoop.hdfs.RenewLeaseRequestProto\x1a$.hadoop.hdfs.RenewLea\
    seResponseProto\x12]\n\x0crecoverLease\x12%.hadoop.hdfs.RecoverLeaseRequ\
    estProto\x1a&.hadoop.hdfs.RecoverLeaseResponseProto\x12X\n\ngetFsStats\
    \x12$.hadoop.hdfs.GetFsStatusRequestProto\x1a$.hadoop.hdfs.GetFsStatsRes\
    ponseProto\x12l\n\x11getDatanodeReport\x12*.hadoop.hdfs.GetDatanodeRepor\
    tRequestProto\x1a+.hadoop.hdfs.GetDatanodeReportResponseProto\x12\x81\
    \x01\n\x18getDatanodeStorageReport\x121.hadoop.hdfs.GetDatanodeStorageRe\
    portRequestProto\x1a2.hadoop.hdfs.GetDatanodeStorageReportResponseProto\
    \x12x\n\x15getPreferredBlockSize\x12..hadoop.hdfs.GetPreferredBlockSizeR\
    equestProto\x1a/.hadoop.hdfs.GetPreferredBlockSizeResponseProto\x12Z\n\
    \x0bsetSafeMode\x12$.hadoop.hdfs.SetSafeModeRequestProto\x1a%.hadoop.hdf\
    s.SetSafeModeResponseProto\x12`\n\rsaveNamespace\x12&.hadoop.hdfs.SaveNa\
    mespaceRequestProto\x1a'.hadoop.hdfs.SaveNamespaceResponseProto\x12T\n\t\
    rollEdits\x12\".hadoop.hdfs.RollEditsRequestProto\x1a#.hadoop.hdfs.RollE\
    ditsResponseProto\x12u\n\x14restoreFailedStorage\x12-.hadoop.hdfs.Restor\
    eFailedStorageRequestProto\x1a..hadoop.hdfs.RestoreFailedStorageResponse\
    Proto\x12]\n\x0crefreshNodes\x12%.hadoop.hdfs.RefreshNodesRequestProto\
    \x1a&.hadoop.hdfs.RefreshNodesResponseProto\x12f\n\x0ffinalizeUpgrade\
    \x12(.hadoop.hdfs.FinalizeUpgradeRequestProto\x1a).hadoop.hdfs.FinalizeU\
    pgradeResponseProto\x12c\n\x0erollingUpgrade\x12'.hadoop.hdfs.RollingUpg\
    radeRequestProto\x1a(.hadoop.hdfs.RollingUpgradeResponseProto\x12x\n\x15\
    listCorruptFileBlocks\x12..hadoop.hdfs.ListCorruptFileBlocksRequestProto\
    \x1a/.hadoop.hdfs.ListCorruptFileBlocksResponseProto\x12Q\n\x08metaSave\
    \x12!.hadoop.hdfs.MetaSaveRequestProto\x1a\".hadoop.hdfs.MetaSaveRespons\
    eProto\x12Z\n\x0bgetFileInfo\x12$.hadoop.hdfs.GetFileInfoRequestProto\
    \x1a%.hadoop.hdfs.GetFileInfoResponseProto\x12l\n\x11addCacheDirective\
    \x12*.hadoop.hdfs.AddCacheDirectiveRequestProto\x1a+.hadoop.hdfs.AddCach\
    eDirectiveResponseProto\x12u\n\x14modifyCacheDirective\x12-.hadoop.hdfs.\
    ModifyCacheDirectiveRequestProto\x1a..hadoop.hdfs.ModifyCacheDirectiveRe\
    sponseProto\x12u\n\x14removeCacheDirective\x12-.hadoop.hdfs.RemoveCacheD\
    irectiveRequestProto\x1a..hadoop.hdfs.RemoveCacheDirectiveResponseProto\
    \x12r\n\x13listCacheDirectives\x12,.hadoop.hdfs.ListCacheDirectivesReque\
    stProto\x1a-.hadoop.hdfs.ListCacheDirectivesResponseProto\x12]\n\x0caddC\
    achePool\x12%.hadoop.hdfs.AddCachePoolRequestProto\x1a&.hadoop.hdfs.AddC\
    achePoolResponseProto\x12f\n\x0fmodifyCachePool\x12(.hadoop.hdfs.ModifyC\
    achePoolRequestProto\x1a).hadoop.hdfs.ModifyCachePoolResponseProto\x12f\
    \n\x0fremoveCachePool\x12(.hadoop.hdfs.RemoveCachePoolRequestProto\x1a).\
    hadoop.hdfs.RemoveCachePoolResponseProto\x12c\n\x0elistCachePools\x12'.h\
    adoop.hdfs.ListCachePoolsRequestProto\x1a(.hadoop.hdfs.ListCachePoolsRes\
    ponseProto\x12f\n\x0fgetFileLinkInfo\x12(.hadoop.hdfs.GetFileLinkInfoReq\
    uestProto\x1a).hadoop.hdfs.GetFileLinkInfoResponseProto\x12l\n\x11getCon\
    tentSummary\x12*.hadoop.hdfs.GetContentSummaryRequestProto\x1a+.hadoop.h\
    dfs.GetContentSummaryResponseProto\x12Q\n\x08setQuota\x12!.hadoop.hdfs.S\
    etQuotaRequestProto\x1a\".hadoop.hdfs.SetQuotaResponseProto\x12H\n\x05fs\
    ync\x12\x1e.hadoop.hdfs.FsyncRequestProto\x1a\x1f.hadoop.hdfs.FsyncRespo\
    nseProto\x12Q\n\x08setTimes\x12!.hadoop.hdfs.SetTimesRequestProto\x1a\".\
    hadoop.hdfs.SetTimesResponseProto\x12`\n\rcreateSymlink\x12&.hadoop.hdfs\
    .CreateSymlinkRequestProto\x1a'.hadoop.hdfs.CreateSymlinkResponseProto\
    \x12`\n\rgetLinkTarget\x12&.hadoop.hdfs.GetLinkTargetRequestProto\x1a'.h\
    adoop.hdfs.GetLinkTargetResponseProto\x12{\n\x16updateBlockForPipeline\
    \x12/.hadoop.hdfs.UpdateBlockForPipelineRequestProto\x1a0.hadoop.hdfs.Up\
    dateBlockForPipelineResponseProto\x12c\n\x0eupdatePipeline\x12'.hadoop.h\
    dfs.UpdatePipelineRequestProto\x1a(.hadoop.hdfs.UpdatePipelineResponsePr\
    oto\x12s\n\x12getDelegationToken\x12-.hadoop.common.GetDelegationTokenRe\
    questProto\x1a..hadoop.common.GetDelegationTokenResponseProto\x12y\n\x14\
    renewDelegationToken\x12/.hadoop.common.RenewDelegationTokenRequestProto\
    \x1a0.hadoop.common.RenewDelegationTokenResponseProto\x12|\n\x15cancelDe\
    legationToken\x120.hadoop.common.CancelDelegationTokenRequestProto\x1a1.\
    hadoop.common.CancelDelegationTokenResponseProto\x12u\n\x14setBalancerBa\
    ndwidth\x12-.hadoop.hdfs.SetBalancerBandwidthRequestProto\x1a..hadoop.hd\
    fs.SetBalancerBandwidthResponseProto\x12u\n\x14getDataEncryptionKey\x12-\
    .hadoop.hdfs.GetDataEncryptionKeyRequestProto\x1a..hadoop.hdfs.GetDataEn\
    cryptionKeyResponseProto\x12c\n\x0ecreateSnapshot\x12'.hadoop.hdfs.Creat\
    eSnapshotRequestProto\x1a(.hadoop.hdfs.CreateSnapshotResponseProto\x12c\
    \n\x0erenameSnapshot\x12'.hadoop.hdfs.RenameSnapshotRequestProto\x1a(.ha\
    doop.hdfs.RenameSnapshotResponseProto\x12`\n\rallowSnapshot\x12&.hadoop.\
    hdfs.AllowSnapshotRequestProto\x1a'.hadoop.hdfs.AllowSnapshotResponsePro\
    to\x12i\n\x10disallowSnapshot\x12).hadoop.hdfs.DisallowSnapshotRequestPr\
    oto\x1a*.hadoop.hdfs.DisallowSnapshotResponseProto\x12\x87\x01\n\x1agetS\
    napshottableDirListing\x123.hadoop.hdfs.GetSnapshottableDirListingReques\
    tProto\x1a4.hadoop.hdfs.GetSnapshottableDirListingResponseProto\x12c\n\
    \x0edeleteSnapshot\x12'.hadoop.hdfs.DeleteSnapshotRequestProto\x1a(.hado\
    op.hdfs.DeleteSnapshotResponseProto\x12x\n\x15getSnapshotDiffReport\x12.\
    .hadoop.hdfs.GetSnapshotDiffReportRequestProto\x1a/.hadoop.hdfs.GetSnaps\
    hotDiffReportResponseProto\x12]\n\x0cisFileClosed\x12%.hadoop.hdfs.IsFil\
    eClosedRequestProto\x1a&.hadoop.hdfs.IsFileClosedResponseProto\x12i\n\
    \x10modifyAclEntries\x12).hadoop.hdfs.ModifyAclEntriesRequestProto\x1a*.\
    hadoop.hdfs.ModifyAclEntriesResponseProto\x12i\n\x10removeAclEntries\x12\
    ).hadoop.hdfs.RemoveAclEntriesRequestProto\x1a*.hadoop.hdfs.RemoveAclEnt\
    riesResponseProto\x12i\n\x10removeDefaultAcl\x12).hadoop.hdfs.RemoveDefa\
    ultAclRequestProto\x1a*.hadoop.hdfs.RemoveDefaultAclResponseProto\x12T\n\
    \tremoveAcl\x12\".hadoop.hdfs.RemoveAclRequestProto\x1a#.hadoop.hdfs.Rem\
    oveAclResponseProto\x12K\n\x06setAcl\x12\x1f.hadoop.hdfs.SetAclRequestPr\
    oto\x1a\x20.hadoop.hdfs.SetAclResponseProto\x12]\n\x0cgetAclStatus\x12%.\
    hadoop.hdfs.GetAclStatusRequestProto\x1a&.hadoop.hdfs.GetAclStatusRespon\
    seProto\x12Q\n\x08setXAttr\x12!.hadoop.hdfs.SetXAttrRequestProto\x1a\".h\
    adoop.hdfs.SetXAttrResponseProto\x12T\n\tgetXAttrs\x12\".hadoop.hdfs.Get\
    XAttrsRequestProto\x1a#.hadoop.hdfs.GetXAttrsResponseProto\x12W\n\nlistX\
    Attrs\x12#.hadoop.hdfs.ListXAttrsRequestProto\x1a$.hadoop.hdfs.ListXAttr\
    sResponseProto\x12Z\n\x0bremoveXAttr\x12$.hadoop.hdfs.RemoveXAttrRequest\
    Proto\x1a%.hadoop.hdfs.RemoveXAttrResponseProto\x12Z\n\x0bcheckAccess\
    \x12$.hadoop.hdfs.CheckAccessRequestProto\x1a%.hadoop.hdfs.CheckAccessRe\
    sponseProto\x12u\n\x14createEncryptionZone\x12-.hadoop.hdfs.CreateEncryp\
    tionZoneRequestProto\x1a..hadoop.hdfs.CreateEncryptionZoneResponseProto\
    \x12r\n\x13listEncryptionZones\x12,.hadoop.hdfs.ListEncryptionZonesReque\
    stProto\x1a-.hadoop.hdfs.ListEncryptionZonesResponseProto\x12]\n\x0cgetE\
    ZForPath\x12%.hadoop.hdfs.GetEZForPathRequestProto\x1a&.hadoop.hdfs.GetE\
    ZForPathResponseProto\x12x\n\x15getCurrentEditLogTxid\x12..hadoop.hdfs.G\
    etCurrentEditLogTxidRequestProto\x1a/.hadoop.hdfs.GetCurrentEditLogTxidR\
    esponseProto\x12i\n\x10getEditsFromTxid\x12).hadoop.hdfs.GetEditsFromTxi\
    dRequestProto\x1a*.hadoop.hdfs.GetEditsFromTxidResponseProto\x12`\n\rget\
    QuotaUsage\x12&.hadoop.hdfs.GetQuotaUsageRequestProto\x1a'.hadoop.hdfs.G\
    etQuotaUsageResponseProtoBK\n%org.apache.hadoop.hdfs.protocol.protoB\x1c\
    ClientNamenodeProtocolProtos\xa0\x01\x01\x88\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
