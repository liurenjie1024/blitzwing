// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `datatransfer.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct DataTransferEncryptorMessageProto {
    // message fields
    status: ::std::option::Option<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    message: ::protobuf::SingularField<::std::string::String>,
    cipherOption: ::protobuf::RepeatedField<super::hdfs::CipherOptionProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataTransferEncryptorMessageProto {
    fn default() -> &'a DataTransferEncryptorMessageProto {
        <DataTransferEncryptorMessageProto as ::protobuf::Message>::default_instance()
    }
}

impl DataTransferEncryptorMessageProto {
    pub fn new() -> DataTransferEncryptorMessageProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DataTransferEncryptorMessageProto.DataTransferEncryptorStatus status = 1;


    pub fn get_status(&self) -> DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
        self.status.unwrap_or(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DataTransferEncryptorMessageProto_DataTransferEncryptorStatus) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.CipherOptionProto cipherOption = 4;


    pub fn get_cipherOption(&self) -> &[super::hdfs::CipherOptionProto] {
        &self.cipherOption
    }
    pub fn clear_cipherOption(&mut self) {
        self.cipherOption.clear();
    }

    // Param is passed by value, moved
    pub fn set_cipherOption(&mut self, v: ::protobuf::RepeatedField<super::hdfs::CipherOptionProto>) {
        self.cipherOption = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cipherOption(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::CipherOptionProto> {
        &mut self.cipherOption
    }

    // Take field
    pub fn take_cipherOption(&mut self) -> ::protobuf::RepeatedField<super::hdfs::CipherOptionProto> {
        ::std::mem::replace(&mut self.cipherOption, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DataTransferEncryptorMessageProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.cipherOption {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cipherOption)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.cipherOption {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.cipherOption {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataTransferEncryptorMessageProto {
        DataTransferEncryptorMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus>>(
                    "status",
                    |m: &DataTransferEncryptorMessageProto| { &m.status },
                    |m: &mut DataTransferEncryptorMessageProto| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &DataTransferEncryptorMessageProto| { &m.payload },
                    |m: &mut DataTransferEncryptorMessageProto| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &DataTransferEncryptorMessageProto| { &m.message },
                    |m: &mut DataTransferEncryptorMessageProto| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::CipherOptionProto>>(
                    "cipherOption",
                    |m: &DataTransferEncryptorMessageProto| { &m.cipherOption },
                    |m: &mut DataTransferEncryptorMessageProto| { &mut m.cipherOption },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataTransferEncryptorMessageProto>(
                    "DataTransferEncryptorMessageProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataTransferEncryptorMessageProto {
        static mut instance: ::protobuf::lazy::Lazy<DataTransferEncryptorMessageProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataTransferEncryptorMessageProto,
        };
        unsafe {
            instance.get(DataTransferEncryptorMessageProto::new)
        }
    }
}

impl ::protobuf::Clear for DataTransferEncryptorMessageProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.payload.clear();
        self.message.clear();
        self.cipherOption.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataTransferEncryptorMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferEncryptorMessageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    SUCCESS = 0,
    ERROR_UNKNOWN_KEY = 1,
    ERROR = 2,
}

impl ::protobuf::ProtobufEnum for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataTransferEncryptorMessageProto_DataTransferEncryptorStatus> {
        match value {
            0 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS),
            1 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR_UNKNOWN_KEY),
            2 => ::std::option::Option::Some(DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DataTransferEncryptorMessageProto_DataTransferEncryptorStatus] = &[
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS,
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR_UNKNOWN_KEY,
            DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DataTransferEncryptorMessageProto_DataTransferEncryptorStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
}

impl ::std::default::Default for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn default() -> Self {
        DataTransferEncryptorMessageProto_DataTransferEncryptorStatus::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferEncryptorMessageProto_DataTransferEncryptorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BaseHeaderProto {
    // message fields
    block: ::protobuf::SingularPtrField<super::hdfs::ExtendedBlockProto>,
    token: ::protobuf::SingularPtrField<super::Security::TokenProto>,
    traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BaseHeaderProto {
    fn default() -> &'a BaseHeaderProto {
        <BaseHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl BaseHeaderProto {
    pub fn new() -> BaseHeaderProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto block = 1;


    pub fn get_block(&self) -> &super::hdfs::ExtendedBlockProto {
        self.block.as_ref().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: super::hdfs::ExtendedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut super::hdfs::ExtendedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> super::hdfs::ExtendedBlockProto {
        self.block.take().unwrap_or_else(|| super::hdfs::ExtendedBlockProto::new())
    }

    // optional .hadoop.common.TokenProto token = 2;


    pub fn get_token(&self) -> &super::Security::TokenProto {
        self.token.as_ref().unwrap_or_else(|| super::Security::TokenProto::default_instance())
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: super::Security::TokenProto) {
        self.token = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut super::Security::TokenProto {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> super::Security::TokenProto {
        self.token.take().unwrap_or_else(|| super::Security::TokenProto::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 3;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| DataTransferTraceInfoProto::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for BaseHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.token {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.token)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.token.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseHeaderProto {
        BaseHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::ExtendedBlockProto>>(
                    "block",
                    |m: &BaseHeaderProto| { &m.block },
                    |m: &mut BaseHeaderProto| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                    "token",
                    |m: &BaseHeaderProto| { &m.token },
                    |m: &mut BaseHeaderProto| { &mut m.token },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                    "traceInfo",
                    |m: &BaseHeaderProto| { &m.traceInfo },
                    |m: &mut BaseHeaderProto| { &mut m.traceInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BaseHeaderProto>(
                    "BaseHeaderProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BaseHeaderProto {
        static mut instance: ::protobuf::lazy::Lazy<BaseHeaderProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseHeaderProto,
        };
        unsafe {
            instance.get(BaseHeaderProto::new)
        }
    }
}

impl ::protobuf::Clear for BaseHeaderProto {
    fn clear(&mut self) {
        self.block.clear();
        self.token.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataTransferTraceInfoProto {
    // message fields
    traceId: ::std::option::Option<u64>,
    parentId: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataTransferTraceInfoProto {
    fn default() -> &'a DataTransferTraceInfoProto {
        <DataTransferTraceInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DataTransferTraceInfoProto {
    pub fn new() -> DataTransferTraceInfoProto {
        ::std::default::Default::default()
    }

    // required uint64 traceId = 1;


    pub fn get_traceId(&self) -> u64 {
        self.traceId.unwrap_or(0)
    }
    pub fn clear_traceId(&mut self) {
        self.traceId = ::std::option::Option::None;
    }

    pub fn has_traceId(&self) -> bool {
        self.traceId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceId(&mut self, v: u64) {
        self.traceId = ::std::option::Option::Some(v);
    }

    // required uint64 parentId = 2;


    pub fn get_parentId(&self) -> u64 {
        self.parentId.unwrap_or(0)
    }
    pub fn clear_parentId(&mut self) {
        self.parentId = ::std::option::Option::None;
    }

    pub fn has_parentId(&self) -> bool {
        self.parentId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentId(&mut self, v: u64) {
        self.parentId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DataTransferTraceInfoProto {
    fn is_initialized(&self) -> bool {
        if self.traceId.is_none() {
            return false;
        }
        if self.parentId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.traceId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.parentId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.traceId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.parentId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.traceId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.parentId {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataTransferTraceInfoProto {
        DataTransferTraceInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "traceId",
                    |m: &DataTransferTraceInfoProto| { &m.traceId },
                    |m: &mut DataTransferTraceInfoProto| { &mut m.traceId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "parentId",
                    |m: &DataTransferTraceInfoProto| { &m.parentId },
                    |m: &mut DataTransferTraceInfoProto| { &mut m.parentId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataTransferTraceInfoProto>(
                    "DataTransferTraceInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataTransferTraceInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<DataTransferTraceInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataTransferTraceInfoProto,
        };
        unsafe {
            instance.get(DataTransferTraceInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for DataTransferTraceInfoProto {
    fn clear(&mut self) {
        self.traceId = ::std::option::Option::None;
        self.parentId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataTransferTraceInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataTransferTraceInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientOperationHeaderProto {
    // message fields
    baseHeader: ::protobuf::SingularPtrField<BaseHeaderProto>,
    clientName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientOperationHeaderProto {
    fn default() -> &'a ClientOperationHeaderProto {
        <ClientOperationHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl ClientOperationHeaderProto {
    pub fn new() -> ClientOperationHeaderProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto baseHeader = 1;


    pub fn get_baseHeader(&self) -> &BaseHeaderProto {
        self.baseHeader.as_ref().unwrap_or_else(|| BaseHeaderProto::default_instance())
    }
    pub fn clear_baseHeader(&mut self) {
        self.baseHeader.clear();
    }

    pub fn has_baseHeader(&self) -> bool {
        self.baseHeader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseHeader(&mut self, v: BaseHeaderProto) {
        self.baseHeader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_baseHeader(&mut self) -> &mut BaseHeaderProto {
        if self.baseHeader.is_none() {
            self.baseHeader.set_default();
        }
        self.baseHeader.as_mut().unwrap()
    }

    // Take field
    pub fn take_baseHeader(&mut self) -> BaseHeaderProto {
        self.baseHeader.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required string clientName = 2;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClientOperationHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.baseHeader.is_none() {
            return false;
        }
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.baseHeader {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.baseHeader)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.baseHeader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.baseHeader.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientOperationHeaderProto {
        ClientOperationHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                    "baseHeader",
                    |m: &ClientOperationHeaderProto| { &m.baseHeader },
                    |m: &mut ClientOperationHeaderProto| { &mut m.baseHeader },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &ClientOperationHeaderProto| { &m.clientName },
                    |m: &mut ClientOperationHeaderProto| { &mut m.clientName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientOperationHeaderProto>(
                    "ClientOperationHeaderProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientOperationHeaderProto {
        static mut instance: ::protobuf::lazy::Lazy<ClientOperationHeaderProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientOperationHeaderProto,
        };
        unsafe {
            instance.get(ClientOperationHeaderProto::new)
        }
    }
}

impl ::protobuf::Clear for ClientOperationHeaderProto {
    fn clear(&mut self) {
        self.baseHeader.clear();
        self.clientName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientOperationHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientOperationHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CachingStrategyProto {
    // message fields
    dropBehind: ::std::option::Option<bool>,
    readahead: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CachingStrategyProto {
    fn default() -> &'a CachingStrategyProto {
        <CachingStrategyProto as ::protobuf::Message>::default_instance()
    }
}

impl CachingStrategyProto {
    pub fn new() -> CachingStrategyProto {
        ::std::default::Default::default()
    }

    // optional bool dropBehind = 1;


    pub fn get_dropBehind(&self) -> bool {
        self.dropBehind.unwrap_or(false)
    }
    pub fn clear_dropBehind(&mut self) {
        self.dropBehind = ::std::option::Option::None;
    }

    pub fn has_dropBehind(&self) -> bool {
        self.dropBehind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropBehind(&mut self, v: bool) {
        self.dropBehind = ::std::option::Option::Some(v);
    }

    // optional int64 readahead = 2;


    pub fn get_readahead(&self) -> i64 {
        self.readahead.unwrap_or(0)
    }
    pub fn clear_readahead(&mut self) {
        self.readahead = ::std::option::Option::None;
    }

    pub fn has_readahead(&self) -> bool {
        self.readahead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readahead(&mut self, v: i64) {
        self.readahead = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CachingStrategyProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dropBehind = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.readahead = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.dropBehind {
            my_size += 2;
        }
        if let Some(v) = self.readahead {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.dropBehind {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.readahead {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CachingStrategyProto {
        CachingStrategyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dropBehind",
                    |m: &CachingStrategyProto| { &m.dropBehind },
                    |m: &mut CachingStrategyProto| { &mut m.dropBehind },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "readahead",
                    |m: &CachingStrategyProto| { &m.readahead },
                    |m: &mut CachingStrategyProto| { &mut m.readahead },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CachingStrategyProto>(
                    "CachingStrategyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CachingStrategyProto {
        static mut instance: ::protobuf::lazy::Lazy<CachingStrategyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CachingStrategyProto,
        };
        unsafe {
            instance.get(CachingStrategyProto::new)
        }
    }
}

impl ::protobuf::Clear for CachingStrategyProto {
    fn clear(&mut self) {
        self.dropBehind = ::std::option::Option::None;
        self.readahead = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CachingStrategyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CachingStrategyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpReadBlockProto {
    // message fields
    header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    offset: ::std::option::Option<u64>,
    len: ::std::option::Option<u64>,
    sendChecksums: ::std::option::Option<bool>,
    cachingStrategy: ::protobuf::SingularPtrField<CachingStrategyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpReadBlockProto {
    fn default() -> &'a OpReadBlockProto {
        <OpReadBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpReadBlockProto {
    pub fn new() -> OpReadBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| ClientOperationHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // required uint64 len = 3;


    pub fn get_len(&self) -> u64 {
        self.len.unwrap_or(0)
    }
    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: u64) {
        self.len = ::std::option::Option::Some(v);
    }

    // optional bool sendChecksums = 4;


    pub fn get_sendChecksums(&self) -> bool {
        self.sendChecksums.unwrap_or(true)
    }
    pub fn clear_sendChecksums(&mut self) {
        self.sendChecksums = ::std::option::Option::None;
    }

    pub fn has_sendChecksums(&self) -> bool {
        self.sendChecksums.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sendChecksums(&mut self, v: bool) {
        self.sendChecksums = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.CachingStrategyProto cachingStrategy = 5;


    pub fn get_cachingStrategy(&self) -> &CachingStrategyProto {
        self.cachingStrategy.as_ref().unwrap_or_else(|| CachingStrategyProto::default_instance())
    }
    pub fn clear_cachingStrategy(&mut self) {
        self.cachingStrategy.clear();
    }

    pub fn has_cachingStrategy(&self) -> bool {
        self.cachingStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingStrategy(&mut self, v: CachingStrategyProto) {
        self.cachingStrategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingStrategy(&mut self) -> &mut CachingStrategyProto {
        if self.cachingStrategy.is_none() {
            self.cachingStrategy.set_default();
        }
        self.cachingStrategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingStrategy(&mut self) -> CachingStrategyProto {
        self.cachingStrategy.take().unwrap_or_else(|| CachingStrategyProto::new())
    }
}

impl ::protobuf::Message for OpReadBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.len.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cachingStrategy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.len = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sendChecksums = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cachingStrategy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sendChecksums {
            my_size += 2;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.len {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.sendChecksums {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpReadBlockProto {
        OpReadBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                    "header",
                    |m: &OpReadBlockProto| { &m.header },
                    |m: &mut OpReadBlockProto| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    |m: &OpReadBlockProto| { &m.offset },
                    |m: &mut OpReadBlockProto| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "len",
                    |m: &OpReadBlockProto| { &m.len },
                    |m: &mut OpReadBlockProto| { &mut m.len },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sendChecksums",
                    |m: &OpReadBlockProto| { &m.sendChecksums },
                    |m: &mut OpReadBlockProto| { &mut m.sendChecksums },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachingStrategyProto>>(
                    "cachingStrategy",
                    |m: &OpReadBlockProto| { &m.cachingStrategy },
                    |m: &mut OpReadBlockProto| { &mut m.cachingStrategy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpReadBlockProto>(
                    "OpReadBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpReadBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<OpReadBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpReadBlockProto,
        };
        unsafe {
            instance.get(OpReadBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for OpReadBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.offset = ::std::option::Option::None;
        self.len = ::std::option::Option::None;
        self.sendChecksums = ::std::option::Option::None;
        self.cachingStrategy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpReadBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpReadBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChecksumProto {
    // message fields
    field_type: ::std::option::Option<super::hdfs::ChecksumTypeProto>,
    bytesPerChecksum: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChecksumProto {
    fn default() -> &'a ChecksumProto {
        <ChecksumProto as ::protobuf::Message>::default_instance()
    }
}

impl ChecksumProto {
    pub fn new() -> ChecksumProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ChecksumTypeProto type = 1;


    pub fn get_field_type(&self) -> super::hdfs::ChecksumTypeProto {
        self.field_type.unwrap_or(super::hdfs::ChecksumTypeProto::CHECKSUM_NULL)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: super::hdfs::ChecksumTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required uint32 bytesPerChecksum = 2;


    pub fn get_bytesPerChecksum(&self) -> u32 {
        self.bytesPerChecksum.unwrap_or(0)
    }
    pub fn clear_bytesPerChecksum(&mut self) {
        self.bytesPerChecksum = ::std::option::Option::None;
    }

    pub fn has_bytesPerChecksum(&self) -> bool {
        self.bytesPerChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerChecksum(&mut self, v: u32) {
        self.bytesPerChecksum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ChecksumProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.bytesPerChecksum.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerChecksum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.bytesPerChecksum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.bytesPerChecksum {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChecksumProto {
        ChecksumProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::ChecksumTypeProto>>(
                    "type",
                    |m: &ChecksumProto| { &m.field_type },
                    |m: &mut ChecksumProto| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bytesPerChecksum",
                    |m: &ChecksumProto| { &m.bytesPerChecksum },
                    |m: &mut ChecksumProto| { &mut m.bytesPerChecksum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ChecksumProto>(
                    "ChecksumProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ChecksumProto {
        static mut instance: ::protobuf::lazy::Lazy<ChecksumProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ChecksumProto,
        };
        unsafe {
            instance.get(ChecksumProto::new)
        }
    }
}

impl ::protobuf::Clear for ChecksumProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.bytesPerChecksum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChecksumProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksumProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpWriteBlockProto {
    // message fields
    header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    targets: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    source: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    stage: ::std::option::Option<OpWriteBlockProto_BlockConstructionStage>,
    pipelineSize: ::std::option::Option<u32>,
    minBytesRcvd: ::std::option::Option<u64>,
    maxBytesRcvd: ::std::option::Option<u64>,
    latestGenerationStamp: ::std::option::Option<u64>,
    requestedChecksum: ::protobuf::SingularPtrField<ChecksumProto>,
    cachingStrategy: ::protobuf::SingularPtrField<CachingStrategyProto>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    targetStorageTypes: ::std::vec::Vec<super::hdfs::StorageTypeProto>,
    allowLazyPersist: ::std::option::Option<bool>,
    pinning: ::std::option::Option<bool>,
    targetPinnings: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpWriteBlockProto {
    fn default() -> &'a OpWriteBlockProto {
        <OpWriteBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpWriteBlockProto {
    pub fn new() -> OpWriteBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| ClientOperationHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto targets = 2;


    pub fn get_targets(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    // optional .hadoop.hdfs.DatanodeInfoProto source = 3;


    pub fn get_source(&self) -> &super::hdfs::DatanodeInfoProto {
        self.source.as_ref().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.source.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // required .hadoop.hdfs.OpWriteBlockProto.BlockConstructionStage stage = 4;


    pub fn get_stage(&self) -> OpWriteBlockProto_BlockConstructionStage {
        self.stage.unwrap_or(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND)
    }
    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: OpWriteBlockProto_BlockConstructionStage) {
        self.stage = ::std::option::Option::Some(v);
    }

    // required uint32 pipelineSize = 5;


    pub fn get_pipelineSize(&self) -> u32 {
        self.pipelineSize.unwrap_or(0)
    }
    pub fn clear_pipelineSize(&mut self) {
        self.pipelineSize = ::std::option::Option::None;
    }

    pub fn has_pipelineSize(&self) -> bool {
        self.pipelineSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pipelineSize(&mut self, v: u32) {
        self.pipelineSize = ::std::option::Option::Some(v);
    }

    // required uint64 minBytesRcvd = 6;


    pub fn get_minBytesRcvd(&self) -> u64 {
        self.minBytesRcvd.unwrap_or(0)
    }
    pub fn clear_minBytesRcvd(&mut self) {
        self.minBytesRcvd = ::std::option::Option::None;
    }

    pub fn has_minBytesRcvd(&self) -> bool {
        self.minBytesRcvd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minBytesRcvd(&mut self, v: u64) {
        self.minBytesRcvd = ::std::option::Option::Some(v);
    }

    // required uint64 maxBytesRcvd = 7;


    pub fn get_maxBytesRcvd(&self) -> u64 {
        self.maxBytesRcvd.unwrap_or(0)
    }
    pub fn clear_maxBytesRcvd(&mut self) {
        self.maxBytesRcvd = ::std::option::Option::None;
    }

    pub fn has_maxBytesRcvd(&self) -> bool {
        self.maxBytesRcvd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxBytesRcvd(&mut self, v: u64) {
        self.maxBytesRcvd = ::std::option::Option::Some(v);
    }

    // required uint64 latestGenerationStamp = 8;


    pub fn get_latestGenerationStamp(&self) -> u64 {
        self.latestGenerationStamp.unwrap_or(0)
    }
    pub fn clear_latestGenerationStamp(&mut self) {
        self.latestGenerationStamp = ::std::option::Option::None;
    }

    pub fn has_latestGenerationStamp(&self) -> bool {
        self.latestGenerationStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latestGenerationStamp(&mut self, v: u64) {
        self.latestGenerationStamp = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.ChecksumProto requestedChecksum = 9;


    pub fn get_requestedChecksum(&self) -> &ChecksumProto {
        self.requestedChecksum.as_ref().unwrap_or_else(|| ChecksumProto::default_instance())
    }
    pub fn clear_requestedChecksum(&mut self) {
        self.requestedChecksum.clear();
    }

    pub fn has_requestedChecksum(&self) -> bool {
        self.requestedChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requestedChecksum(&mut self, v: ChecksumProto) {
        self.requestedChecksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requestedChecksum(&mut self) -> &mut ChecksumProto {
        if self.requestedChecksum.is_none() {
            self.requestedChecksum.set_default();
        }
        self.requestedChecksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_requestedChecksum(&mut self) -> ChecksumProto {
        self.requestedChecksum.take().unwrap_or_else(|| ChecksumProto::new())
    }

    // optional .hadoop.hdfs.CachingStrategyProto cachingStrategy = 10;


    pub fn get_cachingStrategy(&self) -> &CachingStrategyProto {
        self.cachingStrategy.as_ref().unwrap_or_else(|| CachingStrategyProto::default_instance())
    }
    pub fn clear_cachingStrategy(&mut self) {
        self.cachingStrategy.clear();
    }

    pub fn has_cachingStrategy(&self) -> bool {
        self.cachingStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingStrategy(&mut self, v: CachingStrategyProto) {
        self.cachingStrategy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingStrategy(&mut self) -> &mut CachingStrategyProto {
        if self.cachingStrategy.is_none() {
            self.cachingStrategy.set_default();
        }
        self.cachingStrategy.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingStrategy(&mut self) -> CachingStrategyProto {
        self.cachingStrategy.take().unwrap_or_else(|| CachingStrategyProto::new())
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 11;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.StorageTypeProto targetStorageTypes = 12;


    pub fn get_targetStorageTypes(&self) -> &[super::hdfs::StorageTypeProto] {
        &self.targetStorageTypes
    }
    pub fn clear_targetStorageTypes(&mut self) {
        self.targetStorageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageTypes(&mut self, v: ::std::vec::Vec<super::hdfs::StorageTypeProto>) {
        self.targetStorageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageTypes(&mut self) -> &mut ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        &mut self.targetStorageTypes
    }

    // Take field
    pub fn take_targetStorageTypes(&mut self) -> ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        ::std::mem::replace(&mut self.targetStorageTypes, ::std::vec::Vec::new())
    }

    // optional bool allowLazyPersist = 13;


    pub fn get_allowLazyPersist(&self) -> bool {
        self.allowLazyPersist.unwrap_or(false)
    }
    pub fn clear_allowLazyPersist(&mut self) {
        self.allowLazyPersist = ::std::option::Option::None;
    }

    pub fn has_allowLazyPersist(&self) -> bool {
        self.allowLazyPersist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowLazyPersist(&mut self, v: bool) {
        self.allowLazyPersist = ::std::option::Option::Some(v);
    }

    // optional bool pinning = 14;


    pub fn get_pinning(&self) -> bool {
        self.pinning.unwrap_or(false)
    }
    pub fn clear_pinning(&mut self) {
        self.pinning = ::std::option::Option::None;
    }

    pub fn has_pinning(&self) -> bool {
        self.pinning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pinning(&mut self, v: bool) {
        self.pinning = ::std::option::Option::Some(v);
    }

    // repeated bool targetPinnings = 15;


    pub fn get_targetPinnings(&self) -> &[bool] {
        &self.targetPinnings
    }
    pub fn clear_targetPinnings(&mut self) {
        self.targetPinnings.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetPinnings(&mut self, v: ::std::vec::Vec<bool>) {
        self.targetPinnings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetPinnings(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.targetPinnings
    }

    // Take field
    pub fn take_targetPinnings(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.targetPinnings, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpWriteBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.stage.is_none() {
            return false;
        }
        if self.pipelineSize.is_none() {
            return false;
        }
        if self.minBytesRcvd.is_none() {
            return false;
        }
        if self.maxBytesRcvd.is_none() {
            return false;
        }
        if self.latestGenerationStamp.is_none() {
            return false;
        }
        if self.requestedChecksum.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requestedChecksum {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cachingStrategy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stage, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.pipelineSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.minBytesRcvd = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.maxBytesRcvd = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.latestGenerationStamp = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requestedChecksum)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cachingStrategy)?;
                },
                11 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 11, &mut self.unknown_fields)?
                },
                12 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.targetStorageTypes, 12, &mut self.unknown_fields)?
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowLazyPersist = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pinning = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.targetPinnings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.pipelineSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minBytesRcvd {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maxBytesRcvd {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.latestGenerationStamp {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.requestedChecksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(11, v);
        }
        for value in &self.targetStorageTypes {
            my_size += ::protobuf::rt::enum_size(12, *value);
        };
        if let Some(v) = self.allowLazyPersist {
            my_size += 2;
        }
        if let Some(v) = self.pinning {
            my_size += 2;
        }
        my_size += 2 * self.targetPinnings.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.targets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stage {
            os.write_enum(4, v.value())?;
        }
        if let Some(v) = self.pipelineSize {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.minBytesRcvd {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.maxBytesRcvd {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.latestGenerationStamp {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.requestedChecksum.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cachingStrategy.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(11, v.value())?;
        }
        for v in &self.targetStorageTypes {
            os.write_enum(12, v.value())?;
        };
        if let Some(v) = self.allowLazyPersist {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pinning {
            os.write_bool(14, v)?;
        }
        for v in &self.targetPinnings {
            os.write_bool(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpWriteBlockProto {
        OpWriteBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                    "header",
                    |m: &OpWriteBlockProto| { &m.header },
                    |m: &mut OpWriteBlockProto| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "targets",
                    |m: &OpWriteBlockProto| { &m.targets },
                    |m: &mut OpWriteBlockProto| { &mut m.targets },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "source",
                    |m: &OpWriteBlockProto| { &m.source },
                    |m: &mut OpWriteBlockProto| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpWriteBlockProto_BlockConstructionStage>>(
                    "stage",
                    |m: &OpWriteBlockProto| { &m.stage },
                    |m: &mut OpWriteBlockProto| { &mut m.stage },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "pipelineSize",
                    |m: &OpWriteBlockProto| { &m.pipelineSize },
                    |m: &mut OpWriteBlockProto| { &mut m.pipelineSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "minBytesRcvd",
                    |m: &OpWriteBlockProto| { &m.minBytesRcvd },
                    |m: &mut OpWriteBlockProto| { &mut m.minBytesRcvd },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "maxBytesRcvd",
                    |m: &OpWriteBlockProto| { &m.maxBytesRcvd },
                    |m: &mut OpWriteBlockProto| { &mut m.maxBytesRcvd },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "latestGenerationStamp",
                    |m: &OpWriteBlockProto| { &m.latestGenerationStamp },
                    |m: &mut OpWriteBlockProto| { &mut m.latestGenerationStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChecksumProto>>(
                    "requestedChecksum",
                    |m: &OpWriteBlockProto| { &m.requestedChecksum },
                    |m: &mut OpWriteBlockProto| { &mut m.requestedChecksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CachingStrategyProto>>(
                    "cachingStrategy",
                    |m: &OpWriteBlockProto| { &m.cachingStrategy },
                    |m: &mut OpWriteBlockProto| { &mut m.cachingStrategy },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "storageType",
                    |m: &OpWriteBlockProto| { &m.storageType },
                    |m: &mut OpWriteBlockProto| { &mut m.storageType },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "targetStorageTypes",
                    |m: &OpWriteBlockProto| { &m.targetStorageTypes },
                    |m: &mut OpWriteBlockProto| { &mut m.targetStorageTypes },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "allowLazyPersist",
                    |m: &OpWriteBlockProto| { &m.allowLazyPersist },
                    |m: &mut OpWriteBlockProto| { &mut m.allowLazyPersist },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "pinning",
                    |m: &OpWriteBlockProto| { &m.pinning },
                    |m: &mut OpWriteBlockProto| { &mut m.pinning },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "targetPinnings",
                    |m: &OpWriteBlockProto| { &m.targetPinnings },
                    |m: &mut OpWriteBlockProto| { &mut m.targetPinnings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpWriteBlockProto>(
                    "OpWriteBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpWriteBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<OpWriteBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpWriteBlockProto,
        };
        unsafe {
            instance.get(OpWriteBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for OpWriteBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.targets.clear();
        self.source.clear();
        self.stage = ::std::option::Option::None;
        self.pipelineSize = ::std::option::Option::None;
        self.minBytesRcvd = ::std::option::Option::None;
        self.maxBytesRcvd = ::std::option::Option::None;
        self.latestGenerationStamp = ::std::option::Option::None;
        self.requestedChecksum.clear();
        self.cachingStrategy.clear();
        self.storageType = ::std::option::Option::None;
        self.targetStorageTypes.clear();
        self.allowLazyPersist = ::std::option::Option::None;
        self.pinning = ::std::option::Option::None;
        self.targetPinnings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpWriteBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpWriteBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpWriteBlockProto_BlockConstructionStage {
    PIPELINE_SETUP_APPEND = 0,
    PIPELINE_SETUP_APPEND_RECOVERY = 1,
    DATA_STREAMING = 2,
    PIPELINE_SETUP_STREAMING_RECOVERY = 3,
    PIPELINE_CLOSE = 4,
    PIPELINE_CLOSE_RECOVERY = 5,
    PIPELINE_SETUP_CREATE = 6,
    TRANSFER_RBW = 7,
    TRANSFER_FINALIZED = 8,
}

impl ::protobuf::ProtobufEnum for OpWriteBlockProto_BlockConstructionStage {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpWriteBlockProto_BlockConstructionStage> {
        match value {
            0 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND),
            1 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND_RECOVERY),
            2 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::DATA_STREAMING),
            3 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_STREAMING_RECOVERY),
            4 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE),
            5 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE_RECOVERY),
            6 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_CREATE),
            7 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::TRANSFER_RBW),
            8 => ::std::option::Option::Some(OpWriteBlockProto_BlockConstructionStage::TRANSFER_FINALIZED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpWriteBlockProto_BlockConstructionStage] = &[
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::DATA_STREAMING,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_STREAMING_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_CLOSE_RECOVERY,
            OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_CREATE,
            OpWriteBlockProto_BlockConstructionStage::TRANSFER_RBW,
            OpWriteBlockProto_BlockConstructionStage::TRANSFER_FINALIZED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OpWriteBlockProto_BlockConstructionStage", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OpWriteBlockProto_BlockConstructionStage {
}

impl ::std::default::Default for OpWriteBlockProto_BlockConstructionStage {
    fn default() -> Self {
        OpWriteBlockProto_BlockConstructionStage::PIPELINE_SETUP_APPEND
    }
}

impl ::protobuf::reflect::ProtobufValue for OpWriteBlockProto_BlockConstructionStage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpTransferBlockProto {
    // message fields
    header: ::protobuf::SingularPtrField<ClientOperationHeaderProto>,
    targets: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>,
    targetStorageTypes: ::std::vec::Vec<super::hdfs::StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpTransferBlockProto {
    fn default() -> &'a OpTransferBlockProto {
        <OpTransferBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpTransferBlockProto {
    pub fn new() -> OpTransferBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ClientOperationHeaderProto header = 1;


    pub fn get_header(&self) -> &ClientOperationHeaderProto {
        self.header.as_ref().unwrap_or_else(|| ClientOperationHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: ClientOperationHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut ClientOperationHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> ClientOperationHeaderProto {
        self.header.take().unwrap_or_else(|| ClientOperationHeaderProto::new())
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto targets = 2;


    pub fn get_targets(&self) -> &[super::hdfs::DatanodeInfoProto] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<super::hdfs::DatanodeInfoProto> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto targetStorageTypes = 3;


    pub fn get_targetStorageTypes(&self) -> &[super::hdfs::StorageTypeProto] {
        &self.targetStorageTypes
    }
    pub fn clear_targetStorageTypes(&mut self) {
        self.targetStorageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetStorageTypes(&mut self, v: ::std::vec::Vec<super::hdfs::StorageTypeProto>) {
        self.targetStorageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetStorageTypes(&mut self) -> &mut ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        &mut self.targetStorageTypes
    }

    // Take field
    pub fn take_targetStorageTypes(&mut self) -> ::std::vec::Vec<super::hdfs::StorageTypeProto> {
        ::std::mem::replace(&mut self.targetStorageTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for OpTransferBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.targetStorageTypes, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.targetStorageTypes {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.targets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.targetStorageTypes {
            os.write_enum(3, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpTransferBlockProto {
        OpTransferBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientOperationHeaderProto>>(
                    "header",
                    |m: &OpTransferBlockProto| { &m.header },
                    |m: &mut OpTransferBlockProto| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "targets",
                    |m: &OpTransferBlockProto| { &m.targets },
                    |m: &mut OpTransferBlockProto| { &mut m.targets },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "targetStorageTypes",
                    |m: &OpTransferBlockProto| { &m.targetStorageTypes },
                    |m: &mut OpTransferBlockProto| { &mut m.targetStorageTypes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpTransferBlockProto>(
                    "OpTransferBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpTransferBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<OpTransferBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpTransferBlockProto,
        };
        unsafe {
            instance.get(OpTransferBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for OpTransferBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.targets.clear();
        self.targetStorageTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpTransferBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpTransferBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpReplaceBlockProto {
    // message fields
    header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    delHint: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularPtrField<super::hdfs::DatanodeInfoProto>,
    storageType: ::std::option::Option<super::hdfs::StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpReplaceBlockProto {
    fn default() -> &'a OpReplaceBlockProto {
        <OpReplaceBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpReplaceBlockProto {
    pub fn new() -> OpReplaceBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| BaseHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required string delHint = 2;


    pub fn get_delHint(&self) -> &str {
        match self.delHint.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_delHint(&mut self) {
        self.delHint.clear();
    }

    pub fn has_delHint(&self) -> bool {
        self.delHint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delHint(&mut self, v: ::std::string::String) {
        self.delHint = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delHint(&mut self) -> &mut ::std::string::String {
        if self.delHint.is_none() {
            self.delHint.set_default();
        }
        self.delHint.as_mut().unwrap()
    }

    // Take field
    pub fn take_delHint(&mut self) -> ::std::string::String {
        self.delHint.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.DatanodeInfoProto source = 3;


    pub fn get_source(&self) -> &super::hdfs::DatanodeInfoProto {
        self.source.as_ref().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: super::hdfs::DatanodeInfoProto) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut super::hdfs::DatanodeInfoProto {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> super::hdfs::DatanodeInfoProto {
        self.source.take().unwrap_or_else(|| super::hdfs::DatanodeInfoProto::new())
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 4;


    pub fn get_storageType(&self) -> super::hdfs::StorageTypeProto {
        self.storageType.unwrap_or(super::hdfs::StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: super::hdfs::StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpReplaceBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.delHint.is_none() {
            return false;
        }
        if self.source.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.delHint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delHint.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delHint.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpReplaceBlockProto {
        OpReplaceBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                    "header",
                    |m: &OpReplaceBlockProto| { &m.header },
                    |m: &mut OpReplaceBlockProto| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "delHint",
                    |m: &OpReplaceBlockProto| { &m.delHint },
                    |m: &mut OpReplaceBlockProto| { &mut m.delHint },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hdfs::DatanodeInfoProto>>(
                    "source",
                    |m: &OpReplaceBlockProto| { &m.source },
                    |m: &mut OpReplaceBlockProto| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::StorageTypeProto>>(
                    "storageType",
                    |m: &OpReplaceBlockProto| { &m.storageType },
                    |m: &mut OpReplaceBlockProto| { &mut m.storageType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpReplaceBlockProto>(
                    "OpReplaceBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpReplaceBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<OpReplaceBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpReplaceBlockProto,
        };
        unsafe {
            instance.get(OpReplaceBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for OpReplaceBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.delHint.clear();
        self.source.clear();
        self.storageType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpReplaceBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpReplaceBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpCopyBlockProto {
    // message fields
    header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpCopyBlockProto {
    fn default() -> &'a OpCopyBlockProto {
        <OpCopyBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl OpCopyBlockProto {
    pub fn new() -> OpCopyBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| BaseHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }
}

impl ::protobuf::Message for OpCopyBlockProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpCopyBlockProto {
        OpCopyBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                    "header",
                    |m: &OpCopyBlockProto| { &m.header },
                    |m: &mut OpCopyBlockProto| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpCopyBlockProto>(
                    "OpCopyBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpCopyBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<OpCopyBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpCopyBlockProto,
        };
        unsafe {
            instance.get(OpCopyBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for OpCopyBlockProto {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpCopyBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpCopyBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpBlockChecksumProto {
    // message fields
    header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpBlockChecksumProto {
    fn default() -> &'a OpBlockChecksumProto {
        <OpBlockChecksumProto as ::protobuf::Message>::default_instance()
    }
}

impl OpBlockChecksumProto {
    pub fn new() -> OpBlockChecksumProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| BaseHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }
}

impl ::protobuf::Message for OpBlockChecksumProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpBlockChecksumProto {
        OpBlockChecksumProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                    "header",
                    |m: &OpBlockChecksumProto| { &m.header },
                    |m: &mut OpBlockChecksumProto| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpBlockChecksumProto>(
                    "OpBlockChecksumProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpBlockChecksumProto {
        static mut instance: ::protobuf::lazy::Lazy<OpBlockChecksumProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpBlockChecksumProto,
        };
        unsafe {
            instance.get(OpBlockChecksumProto::new)
        }
    }
}

impl ::protobuf::Clear for OpBlockChecksumProto {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpBlockChecksumProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpBlockChecksumProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmIdProto {
    // message fields
    hi: ::std::option::Option<i64>,
    lo: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmIdProto {
    fn default() -> &'a ShortCircuitShmIdProto {
        <ShortCircuitShmIdProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmIdProto {
    pub fn new() -> ShortCircuitShmIdProto {
        ::std::default::Default::default()
    }

    // required int64 hi = 1;


    pub fn get_hi(&self) -> i64 {
        self.hi.unwrap_or(0)
    }
    pub fn clear_hi(&mut self) {
        self.hi = ::std::option::Option::None;
    }

    pub fn has_hi(&self) -> bool {
        self.hi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hi(&mut self, v: i64) {
        self.hi = ::std::option::Option::Some(v);
    }

    // required int64 lo = 2;


    pub fn get_lo(&self) -> i64 {
        self.lo.unwrap_or(0)
    }
    pub fn clear_lo(&mut self) {
        self.lo = ::std::option::Option::None;
    }

    pub fn has_lo(&self) -> bool {
        self.lo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lo(&mut self, v: i64) {
        self.lo = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShortCircuitShmIdProto {
    fn is_initialized(&self) -> bool {
        if self.hi.is_none() {
            return false;
        }
        if self.lo.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.hi = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lo = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.hi {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lo {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hi {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.lo {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmIdProto {
        ShortCircuitShmIdProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "hi",
                    |m: &ShortCircuitShmIdProto| { &m.hi },
                    |m: &mut ShortCircuitShmIdProto| { &mut m.hi },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lo",
                    |m: &ShortCircuitShmIdProto| { &m.lo },
                    |m: &mut ShortCircuitShmIdProto| { &mut m.lo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShortCircuitShmIdProto>(
                    "ShortCircuitShmIdProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShortCircuitShmIdProto {
        static mut instance: ::protobuf::lazy::Lazy<ShortCircuitShmIdProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShortCircuitShmIdProto,
        };
        unsafe {
            instance.get(ShortCircuitShmIdProto::new)
        }
    }
}

impl ::protobuf::Clear for ShortCircuitShmIdProto {
    fn clear(&mut self) {
        self.hi = ::std::option::Option::None;
        self.lo = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmIdProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmIdProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmSlotProto {
    // message fields
    shmId: ::protobuf::SingularPtrField<ShortCircuitShmIdProto>,
    slotIdx: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmSlotProto {
    fn default() -> &'a ShortCircuitShmSlotProto {
        <ShortCircuitShmSlotProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmSlotProto {
    pub fn new() -> ShortCircuitShmSlotProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ShortCircuitShmIdProto shmId = 1;


    pub fn get_shmId(&self) -> &ShortCircuitShmIdProto {
        self.shmId.as_ref().unwrap_or_else(|| ShortCircuitShmIdProto::default_instance())
    }
    pub fn clear_shmId(&mut self) {
        self.shmId.clear();
    }

    pub fn has_shmId(&self) -> bool {
        self.shmId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shmId(&mut self, v: ShortCircuitShmIdProto) {
        self.shmId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shmId(&mut self) -> &mut ShortCircuitShmIdProto {
        if self.shmId.is_none() {
            self.shmId.set_default();
        }
        self.shmId.as_mut().unwrap()
    }

    // Take field
    pub fn take_shmId(&mut self) -> ShortCircuitShmIdProto {
        self.shmId.take().unwrap_or_else(|| ShortCircuitShmIdProto::new())
    }

    // required int32 slotIdx = 2;


    pub fn get_slotIdx(&self) -> i32 {
        self.slotIdx.unwrap_or(0)
    }
    pub fn clear_slotIdx(&mut self) {
        self.slotIdx = ::std::option::Option::None;
    }

    pub fn has_slotIdx(&self) -> bool {
        self.slotIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotIdx(&mut self, v: i32) {
        self.slotIdx = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ShortCircuitShmSlotProto {
    fn is_initialized(&self) -> bool {
        if self.shmId.is_none() {
            return false;
        }
        if self.slotIdx.is_none() {
            return false;
        }
        for v in &self.shmId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shmId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slotIdx = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shmId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.slotIdx {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shmId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.slotIdx {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmSlotProto {
        ShortCircuitShmSlotProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmIdProto>>(
                    "shmId",
                    |m: &ShortCircuitShmSlotProto| { &m.shmId },
                    |m: &mut ShortCircuitShmSlotProto| { &mut m.shmId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "slotIdx",
                    |m: &ShortCircuitShmSlotProto| { &m.slotIdx },
                    |m: &mut ShortCircuitShmSlotProto| { &mut m.slotIdx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShortCircuitShmSlotProto>(
                    "ShortCircuitShmSlotProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShortCircuitShmSlotProto {
        static mut instance: ::protobuf::lazy::Lazy<ShortCircuitShmSlotProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShortCircuitShmSlotProto,
        };
        unsafe {
            instance.get(ShortCircuitShmSlotProto::new)
        }
    }
}

impl ::protobuf::Clear for ShortCircuitShmSlotProto {
    fn clear(&mut self) {
        self.shmId.clear();
        self.slotIdx = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmSlotProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmSlotProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpRequestShortCircuitAccessProto {
    // message fields
    header: ::protobuf::SingularPtrField<BaseHeaderProto>,
    maxVersion: ::std::option::Option<u32>,
    slotId: ::protobuf::SingularPtrField<ShortCircuitShmSlotProto>,
    supportsReceiptVerification: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpRequestShortCircuitAccessProto {
    fn default() -> &'a OpRequestShortCircuitAccessProto {
        <OpRequestShortCircuitAccessProto as ::protobuf::Message>::default_instance()
    }
}

impl OpRequestShortCircuitAccessProto {
    pub fn new() -> OpRequestShortCircuitAccessProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BaseHeaderProto header = 1;


    pub fn get_header(&self) -> &BaseHeaderProto {
        self.header.as_ref().unwrap_or_else(|| BaseHeaderProto::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: BaseHeaderProto) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut BaseHeaderProto {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> BaseHeaderProto {
        self.header.take().unwrap_or_else(|| BaseHeaderProto::new())
    }

    // required uint32 maxVersion = 2;


    pub fn get_maxVersion(&self) -> u32 {
        self.maxVersion.unwrap_or(0)
    }
    pub fn clear_maxVersion(&mut self) {
        self.maxVersion = ::std::option::Option::None;
    }

    pub fn has_maxVersion(&self) -> bool {
        self.maxVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxVersion(&mut self, v: u32) {
        self.maxVersion = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ShortCircuitShmSlotProto slotId = 3;


    pub fn get_slotId(&self) -> &ShortCircuitShmSlotProto {
        self.slotId.as_ref().unwrap_or_else(|| ShortCircuitShmSlotProto::default_instance())
    }
    pub fn clear_slotId(&mut self) {
        self.slotId.clear();
    }

    pub fn has_slotId(&self) -> bool {
        self.slotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotId(&mut self, v: ShortCircuitShmSlotProto) {
        self.slotId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slotId(&mut self) -> &mut ShortCircuitShmSlotProto {
        if self.slotId.is_none() {
            self.slotId.set_default();
        }
        self.slotId.as_mut().unwrap()
    }

    // Take field
    pub fn take_slotId(&mut self) -> ShortCircuitShmSlotProto {
        self.slotId.take().unwrap_or_else(|| ShortCircuitShmSlotProto::new())
    }

    // optional bool supportsReceiptVerification = 4;


    pub fn get_supportsReceiptVerification(&self) -> bool {
        self.supportsReceiptVerification.unwrap_or(false)
    }
    pub fn clear_supportsReceiptVerification(&mut self) {
        self.supportsReceiptVerification = ::std::option::Option::None;
    }

    pub fn has_supportsReceiptVerification(&self) -> bool {
        self.supportsReceiptVerification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supportsReceiptVerification(&mut self, v: bool) {
        self.supportsReceiptVerification = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpRequestShortCircuitAccessProto {
    fn is_initialized(&self) -> bool {
        if self.header.is_none() {
            return false;
        }
        if self.maxVersion.is_none() {
            return false;
        }
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slotId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxVersion = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.slotId)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supportsReceiptVerification = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.maxVersion {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.slotId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.supportsReceiptVerification {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.maxVersion {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.slotId.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.supportsReceiptVerification {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpRequestShortCircuitAccessProto {
        OpRequestShortCircuitAccessProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseHeaderProto>>(
                    "header",
                    |m: &OpRequestShortCircuitAccessProto| { &m.header },
                    |m: &mut OpRequestShortCircuitAccessProto| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maxVersion",
                    |m: &OpRequestShortCircuitAccessProto| { &m.maxVersion },
                    |m: &mut OpRequestShortCircuitAccessProto| { &mut m.maxVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmSlotProto>>(
                    "slotId",
                    |m: &OpRequestShortCircuitAccessProto| { &m.slotId },
                    |m: &mut OpRequestShortCircuitAccessProto| { &mut m.slotId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "supportsReceiptVerification",
                    |m: &OpRequestShortCircuitAccessProto| { &m.supportsReceiptVerification },
                    |m: &mut OpRequestShortCircuitAccessProto| { &mut m.supportsReceiptVerification },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpRequestShortCircuitAccessProto>(
                    "OpRequestShortCircuitAccessProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpRequestShortCircuitAccessProto {
        static mut instance: ::protobuf::lazy::Lazy<OpRequestShortCircuitAccessProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpRequestShortCircuitAccessProto,
        };
        unsafe {
            instance.get(OpRequestShortCircuitAccessProto::new)
        }
    }
}

impl ::protobuf::Clear for OpRequestShortCircuitAccessProto {
    fn clear(&mut self) {
        self.header.clear();
        self.maxVersion = ::std::option::Option::None;
        self.slotId.clear();
        self.supportsReceiptVerification = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpRequestShortCircuitAccessProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpRequestShortCircuitAccessProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseShortCircuitAccessRequestProto {
    // message fields
    slotId: ::protobuf::SingularPtrField<ShortCircuitShmSlotProto>,
    traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseShortCircuitAccessRequestProto {
    fn default() -> &'a ReleaseShortCircuitAccessRequestProto {
        <ReleaseShortCircuitAccessRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseShortCircuitAccessRequestProto {
    pub fn new() -> ReleaseShortCircuitAccessRequestProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ShortCircuitShmSlotProto slotId = 1;


    pub fn get_slotId(&self) -> &ShortCircuitShmSlotProto {
        self.slotId.as_ref().unwrap_or_else(|| ShortCircuitShmSlotProto::default_instance())
    }
    pub fn clear_slotId(&mut self) {
        self.slotId.clear();
    }

    pub fn has_slotId(&self) -> bool {
        self.slotId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slotId(&mut self, v: ShortCircuitShmSlotProto) {
        self.slotId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slotId(&mut self) -> &mut ShortCircuitShmSlotProto {
        if self.slotId.is_none() {
            self.slotId.set_default();
        }
        self.slotId.as_mut().unwrap()
    }

    // Take field
    pub fn take_slotId(&mut self) -> ShortCircuitShmSlotProto {
        self.slotId.take().unwrap_or_else(|| ShortCircuitShmSlotProto::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 2;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| DataTransferTraceInfoProto::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for ReleaseShortCircuitAccessRequestProto {
    fn is_initialized(&self) -> bool {
        if self.slotId.is_none() {
            return false;
        }
        for v in &self.slotId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.slotId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.slotId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.slotId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseShortCircuitAccessRequestProto {
        ReleaseShortCircuitAccessRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmSlotProto>>(
                    "slotId",
                    |m: &ReleaseShortCircuitAccessRequestProto| { &m.slotId },
                    |m: &mut ReleaseShortCircuitAccessRequestProto| { &mut m.slotId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                    "traceInfo",
                    |m: &ReleaseShortCircuitAccessRequestProto| { &m.traceInfo },
                    |m: &mut ReleaseShortCircuitAccessRequestProto| { &mut m.traceInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReleaseShortCircuitAccessRequestProto>(
                    "ReleaseShortCircuitAccessRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReleaseShortCircuitAccessRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ReleaseShortCircuitAccessRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReleaseShortCircuitAccessRequestProto,
        };
        unsafe {
            instance.get(ReleaseShortCircuitAccessRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ReleaseShortCircuitAccessRequestProto {
    fn clear(&mut self) {
        self.slotId.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseShortCircuitAccessRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseShortCircuitAccessRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReleaseShortCircuitAccessResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReleaseShortCircuitAccessResponseProto {
    fn default() -> &'a ReleaseShortCircuitAccessResponseProto {
        <ReleaseShortCircuitAccessResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ReleaseShortCircuitAccessResponseProto {
    pub fn new() -> ReleaseShortCircuitAccessResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReleaseShortCircuitAccessResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReleaseShortCircuitAccessResponseProto {
        ReleaseShortCircuitAccessResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &ReleaseShortCircuitAccessResponseProto| { &m.status },
                    |m: &mut ReleaseShortCircuitAccessResponseProto| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &ReleaseShortCircuitAccessResponseProto| { &m.error },
                    |m: &mut ReleaseShortCircuitAccessResponseProto| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReleaseShortCircuitAccessResponseProto>(
                    "ReleaseShortCircuitAccessResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReleaseShortCircuitAccessResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ReleaseShortCircuitAccessResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReleaseShortCircuitAccessResponseProto,
        };
        unsafe {
            instance.get(ReleaseShortCircuitAccessResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ReleaseShortCircuitAccessResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReleaseShortCircuitAccessResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReleaseShortCircuitAccessResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmRequestProto {
    // message fields
    clientName: ::protobuf::SingularField<::std::string::String>,
    traceInfo: ::protobuf::SingularPtrField<DataTransferTraceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmRequestProto {
    fn default() -> &'a ShortCircuitShmRequestProto {
        <ShortCircuitShmRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmRequestProto {
    pub fn new() -> ShortCircuitShmRequestProto {
        ::std::default::Default::default()
    }

    // required string clientName = 1;


    pub fn get_clientName(&self) -> &str {
        match self.clientName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientName(&mut self) {
        self.clientName.clear();
    }

    pub fn has_clientName(&self) -> bool {
        self.clientName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientName(&mut self, v: ::std::string::String) {
        self.clientName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientName(&mut self) -> &mut ::std::string::String {
        if self.clientName.is_none() {
            self.clientName.set_default();
        }
        self.clientName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientName(&mut self) -> ::std::string::String {
        self.clientName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.DataTransferTraceInfoProto traceInfo = 2;


    pub fn get_traceInfo(&self) -> &DataTransferTraceInfoProto {
        self.traceInfo.as_ref().unwrap_or_else(|| DataTransferTraceInfoProto::default_instance())
    }
    pub fn clear_traceInfo(&mut self) {
        self.traceInfo.clear();
    }

    pub fn has_traceInfo(&self) -> bool {
        self.traceInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traceInfo(&mut self, v: DataTransferTraceInfoProto) {
        self.traceInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traceInfo(&mut self) -> &mut DataTransferTraceInfoProto {
        if self.traceInfo.is_none() {
            self.traceInfo.set_default();
        }
        self.traceInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_traceInfo(&mut self) -> DataTransferTraceInfoProto {
        self.traceInfo.take().unwrap_or_else(|| DataTransferTraceInfoProto::new())
    }
}

impl ::protobuf::Message for ShortCircuitShmRequestProto {
    fn is_initialized(&self) -> bool {
        if self.clientName.is_none() {
            return false;
        }
        for v in &self.traceInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.traceInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.traceInfo.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmRequestProto {
        ShortCircuitShmRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clientName",
                    |m: &ShortCircuitShmRequestProto| { &m.clientName },
                    |m: &mut ShortCircuitShmRequestProto| { &mut m.clientName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DataTransferTraceInfoProto>>(
                    "traceInfo",
                    |m: &ShortCircuitShmRequestProto| { &m.traceInfo },
                    |m: &mut ShortCircuitShmRequestProto| { &mut m.traceInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShortCircuitShmRequestProto>(
                    "ShortCircuitShmRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShortCircuitShmRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<ShortCircuitShmRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShortCircuitShmRequestProto,
        };
        unsafe {
            instance.get(ShortCircuitShmRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for ShortCircuitShmRequestProto {
    fn clear(&mut self) {
        self.clientName.clear();
        self.traceInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShortCircuitShmResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    error: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularPtrField<ShortCircuitShmIdProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShortCircuitShmResponseProto {
    fn default() -> &'a ShortCircuitShmResponseProto {
        <ShortCircuitShmResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl ShortCircuitShmResponseProto {
    pub fn new() -> ShortCircuitShmResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string error = 2;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.ShortCircuitShmIdProto id = 3;


    pub fn get_id(&self) -> &ShortCircuitShmIdProto {
        self.id.as_ref().unwrap_or_else(|| ShortCircuitShmIdProto::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ShortCircuitShmIdProto) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ShortCircuitShmIdProto {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ShortCircuitShmIdProto {
        self.id.take().unwrap_or_else(|| ShortCircuitShmIdProto::new())
    }
}

impl ::protobuf::Message for ShortCircuitShmResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShortCircuitShmResponseProto {
        ShortCircuitShmResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &ShortCircuitShmResponseProto| { &m.status },
                    |m: &mut ShortCircuitShmResponseProto| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &ShortCircuitShmResponseProto| { &m.error },
                    |m: &mut ShortCircuitShmResponseProto| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShortCircuitShmIdProto>>(
                    "id",
                    |m: &ShortCircuitShmResponseProto| { &m.id },
                    |m: &mut ShortCircuitShmResponseProto| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShortCircuitShmResponseProto>(
                    "ShortCircuitShmResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShortCircuitShmResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<ShortCircuitShmResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShortCircuitShmResponseProto,
        };
        unsafe {
            instance.get(ShortCircuitShmResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for ShortCircuitShmResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.error.clear();
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShortCircuitShmResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitShmResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PacketHeaderProto {
    // message fields
    offsetInBlock: ::std::option::Option<i64>,
    seqno: ::std::option::Option<i64>,
    lastPacketInBlock: ::std::option::Option<bool>,
    dataLen: ::std::option::Option<i32>,
    syncBlock: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PacketHeaderProto {
    fn default() -> &'a PacketHeaderProto {
        <PacketHeaderProto as ::protobuf::Message>::default_instance()
    }
}

impl PacketHeaderProto {
    pub fn new() -> PacketHeaderProto {
        ::std::default::Default::default()
    }

    // required sfixed64 offsetInBlock = 1;


    pub fn get_offsetInBlock(&self) -> i64 {
        self.offsetInBlock.unwrap_or(0)
    }
    pub fn clear_offsetInBlock(&mut self) {
        self.offsetInBlock = ::std::option::Option::None;
    }

    pub fn has_offsetInBlock(&self) -> bool {
        self.offsetInBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offsetInBlock(&mut self, v: i64) {
        self.offsetInBlock = ::std::option::Option::Some(v);
    }

    // required sfixed64 seqno = 2;


    pub fn get_seqno(&self) -> i64 {
        self.seqno.unwrap_or(0)
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = ::std::option::Option::None;
    }

    pub fn has_seqno(&self) -> bool {
        self.seqno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = ::std::option::Option::Some(v);
    }

    // required bool lastPacketInBlock = 3;


    pub fn get_lastPacketInBlock(&self) -> bool {
        self.lastPacketInBlock.unwrap_or(false)
    }
    pub fn clear_lastPacketInBlock(&mut self) {
        self.lastPacketInBlock = ::std::option::Option::None;
    }

    pub fn has_lastPacketInBlock(&self) -> bool {
        self.lastPacketInBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastPacketInBlock(&mut self, v: bool) {
        self.lastPacketInBlock = ::std::option::Option::Some(v);
    }

    // required sfixed32 dataLen = 4;


    pub fn get_dataLen(&self) -> i32 {
        self.dataLen.unwrap_or(0)
    }
    pub fn clear_dataLen(&mut self) {
        self.dataLen = ::std::option::Option::None;
    }

    pub fn has_dataLen(&self) -> bool {
        self.dataLen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataLen(&mut self, v: i32) {
        self.dataLen = ::std::option::Option::Some(v);
    }

    // optional bool syncBlock = 5;


    pub fn get_syncBlock(&self) -> bool {
        self.syncBlock.unwrap_or(false)
    }
    pub fn clear_syncBlock(&mut self) {
        self.syncBlock = ::std::option::Option::None;
    }

    pub fn has_syncBlock(&self) -> bool {
        self.syncBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syncBlock(&mut self, v: bool) {
        self.syncBlock = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PacketHeaderProto {
    fn is_initialized(&self) -> bool {
        if self.offsetInBlock.is_none() {
            return false;
        }
        if self.seqno.is_none() {
            return false;
        }
        if self.lastPacketInBlock.is_none() {
            return false;
        }
        if self.dataLen.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.offsetInBlock = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed64()?;
                    self.seqno = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lastPacketInBlock = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.dataLen = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncBlock = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.offsetInBlock {
            my_size += 9;
        }
        if let Some(v) = self.seqno {
            my_size += 9;
        }
        if let Some(v) = self.lastPacketInBlock {
            my_size += 2;
        }
        if let Some(v) = self.dataLen {
            my_size += 5;
        }
        if let Some(v) = self.syncBlock {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.offsetInBlock {
            os.write_sfixed64(1, v)?;
        }
        if let Some(v) = self.seqno {
            os.write_sfixed64(2, v)?;
        }
        if let Some(v) = self.lastPacketInBlock {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.dataLen {
            os.write_sfixed32(4, v)?;
        }
        if let Some(v) = self.syncBlock {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PacketHeaderProto {
        PacketHeaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "offsetInBlock",
                    |m: &PacketHeaderProto| { &m.offsetInBlock },
                    |m: &mut PacketHeaderProto| { &mut m.offsetInBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed64>(
                    "seqno",
                    |m: &PacketHeaderProto| { &m.seqno },
                    |m: &mut PacketHeaderProto| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "lastPacketInBlock",
                    |m: &PacketHeaderProto| { &m.lastPacketInBlock },
                    |m: &mut PacketHeaderProto| { &mut m.lastPacketInBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                    "dataLen",
                    |m: &PacketHeaderProto| { &m.dataLen },
                    |m: &mut PacketHeaderProto| { &mut m.dataLen },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "syncBlock",
                    |m: &PacketHeaderProto| { &m.syncBlock },
                    |m: &mut PacketHeaderProto| { &mut m.syncBlock },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PacketHeaderProto>(
                    "PacketHeaderProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PacketHeaderProto {
        static mut instance: ::protobuf::lazy::Lazy<PacketHeaderProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PacketHeaderProto,
        };
        unsafe {
            instance.get(PacketHeaderProto::new)
        }
    }
}

impl ::protobuf::Clear for PacketHeaderProto {
    fn clear(&mut self) {
        self.offsetInBlock = ::std::option::Option::None;
        self.seqno = ::std::option::Option::None;
        self.lastPacketInBlock = ::std::option::Option::None;
        self.dataLen = ::std::option::Option::None;
        self.syncBlock = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PacketHeaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PacketHeaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PipelineAckProto {
    // message fields
    seqno: ::std::option::Option<i64>,
    reply: ::std::vec::Vec<Status>,
    downstreamAckTimeNanos: ::std::option::Option<u64>,
    flag: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PipelineAckProto {
    fn default() -> &'a PipelineAckProto {
        <PipelineAckProto as ::protobuf::Message>::default_instance()
    }
}

impl PipelineAckProto {
    pub fn new() -> PipelineAckProto {
        ::std::default::Default::default()
    }

    // required sint64 seqno = 1;


    pub fn get_seqno(&self) -> i64 {
        self.seqno.unwrap_or(0)
    }
    pub fn clear_seqno(&mut self) {
        self.seqno = ::std::option::Option::None;
    }

    pub fn has_seqno(&self) -> bool {
        self.seqno.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seqno(&mut self, v: i64) {
        self.seqno = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.Status reply = 2;


    pub fn get_reply(&self) -> &[Status] {
        &self.reply
    }
    pub fn clear_reply(&mut self) {
        self.reply.clear();
    }

    // Param is passed by value, moved
    pub fn set_reply(&mut self, v: ::std::vec::Vec<Status>) {
        self.reply = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reply(&mut self) -> &mut ::std::vec::Vec<Status> {
        &mut self.reply
    }

    // Take field
    pub fn take_reply(&mut self) -> ::std::vec::Vec<Status> {
        ::std::mem::replace(&mut self.reply, ::std::vec::Vec::new())
    }

    // optional uint64 downstreamAckTimeNanos = 3;


    pub fn get_downstreamAckTimeNanos(&self) -> u64 {
        self.downstreamAckTimeNanos.unwrap_or(0u64)
    }
    pub fn clear_downstreamAckTimeNanos(&mut self) {
        self.downstreamAckTimeNanos = ::std::option::Option::None;
    }

    pub fn has_downstreamAckTimeNanos(&self) -> bool {
        self.downstreamAckTimeNanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downstreamAckTimeNanos(&mut self, v: u64) {
        self.downstreamAckTimeNanos = ::std::option::Option::Some(v);
    }

    // repeated uint32 flag = 4;


    pub fn get_flag(&self) -> &[u32] {
        &self.flag
    }
    pub fn clear_flag(&mut self) {
        self.flag.clear();
    }

    // Param is passed by value, moved
    pub fn set_flag(&mut self, v: ::std::vec::Vec<u32>) {
        self.flag = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flag(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.flag
    }

    // Take field
    pub fn take_flag(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.flag, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PipelineAckProto {
    fn is_initialized(&self) -> bool {
        if self.seqno.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.seqno = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.reply, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.downstreamAckTimeNanos = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.flag)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seqno {
            my_size += ::protobuf::rt::value_varint_zigzag_size(1, v);
        }
        for value in &self.reply {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if let Some(v) = self.downstreamAckTimeNanos {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.flag.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.flag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seqno {
            os.write_sint64(1, v)?;
        }
        for v in &self.reply {
            os.write_enum(2, v.value())?;
        };
        if let Some(v) = self.downstreamAckTimeNanos {
            os.write_uint64(3, v)?;
        }
        if !self.flag.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.flag))?;
            for v in &self.flag {
                os.write_uint32_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PipelineAckProto {
        PipelineAckProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                    "seqno",
                    |m: &PipelineAckProto| { &m.seqno },
                    |m: &mut PipelineAckProto| { &mut m.seqno },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "reply",
                    |m: &PipelineAckProto| { &m.reply },
                    |m: &mut PipelineAckProto| { &mut m.reply },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "downstreamAckTimeNanos",
                    |m: &PipelineAckProto| { &m.downstreamAckTimeNanos },
                    |m: &mut PipelineAckProto| { &mut m.downstreamAckTimeNanos },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "flag",
                    |m: &PipelineAckProto| { &m.flag },
                    |m: &mut PipelineAckProto| { &mut m.flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PipelineAckProto>(
                    "PipelineAckProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PipelineAckProto {
        static mut instance: ::protobuf::lazy::Lazy<PipelineAckProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PipelineAckProto,
        };
        unsafe {
            instance.get(PipelineAckProto::new)
        }
    }
}

impl ::protobuf::Clear for PipelineAckProto {
    fn clear(&mut self) {
        self.seqno = ::std::option::Option::None;
        self.reply.clear();
        self.downstreamAckTimeNanos = ::std::option::Option::None;
        self.flag.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PipelineAckProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PipelineAckProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReadOpChecksumInfoProto {
    // message fields
    checksum: ::protobuf::SingularPtrField<ChecksumProto>,
    chunkOffset: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReadOpChecksumInfoProto {
    fn default() -> &'a ReadOpChecksumInfoProto {
        <ReadOpChecksumInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ReadOpChecksumInfoProto {
    pub fn new() -> ReadOpChecksumInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ChecksumProto checksum = 1;


    pub fn get_checksum(&self) -> &ChecksumProto {
        self.checksum.as_ref().unwrap_or_else(|| ChecksumProto::default_instance())
    }
    pub fn clear_checksum(&mut self) {
        self.checksum.clear();
    }

    pub fn has_checksum(&self) -> bool {
        self.checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksum(&mut self, v: ChecksumProto) {
        self.checksum = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksum(&mut self) -> &mut ChecksumProto {
        if self.checksum.is_none() {
            self.checksum.set_default();
        }
        self.checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksum(&mut self) -> ChecksumProto {
        self.checksum.take().unwrap_or_else(|| ChecksumProto::new())
    }

    // required uint64 chunkOffset = 2;


    pub fn get_chunkOffset(&self) -> u64 {
        self.chunkOffset.unwrap_or(0)
    }
    pub fn clear_chunkOffset(&mut self) {
        self.chunkOffset = ::std::option::Option::None;
    }

    pub fn has_chunkOffset(&self) -> bool {
        self.chunkOffset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunkOffset(&mut self, v: u64) {
        self.chunkOffset = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReadOpChecksumInfoProto {
    fn is_initialized(&self) -> bool {
        if self.checksum.is_none() {
            return false;
        }
        if self.chunkOffset.is_none() {
            return false;
        }
        for v in &self.checksum {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksum)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chunkOffset = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.checksum.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.chunkOffset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.checksum.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.chunkOffset {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReadOpChecksumInfoProto {
        ReadOpChecksumInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChecksumProto>>(
                    "checksum",
                    |m: &ReadOpChecksumInfoProto| { &m.checksum },
                    |m: &mut ReadOpChecksumInfoProto| { &mut m.checksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chunkOffset",
                    |m: &ReadOpChecksumInfoProto| { &m.chunkOffset },
                    |m: &mut ReadOpChecksumInfoProto| { &mut m.chunkOffset },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReadOpChecksumInfoProto>(
                    "ReadOpChecksumInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReadOpChecksumInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<ReadOpChecksumInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReadOpChecksumInfoProto,
        };
        unsafe {
            instance.get(ReadOpChecksumInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for ReadOpChecksumInfoProto {
    fn clear(&mut self) {
        self.checksum.clear();
        self.chunkOffset = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReadOpChecksumInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadOpChecksumInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockOpResponseProto {
    // message fields
    status: ::std::option::Option<Status>,
    firstBadLink: ::protobuf::SingularField<::std::string::String>,
    checksumResponse: ::protobuf::SingularPtrField<OpBlockChecksumResponseProto>,
    readOpChecksumInfo: ::protobuf::SingularPtrField<ReadOpChecksumInfoProto>,
    message: ::protobuf::SingularField<::std::string::String>,
    shortCircuitAccessVersion: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockOpResponseProto {
    fn default() -> &'a BlockOpResponseProto {
        <BlockOpResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockOpResponseProto {
    pub fn new() -> BlockOpResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional string firstBadLink = 2;


    pub fn get_firstBadLink(&self) -> &str {
        match self.firstBadLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_firstBadLink(&mut self) {
        self.firstBadLink.clear();
    }

    pub fn has_firstBadLink(&self) -> bool {
        self.firstBadLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstBadLink(&mut self, v: ::std::string::String) {
        self.firstBadLink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstBadLink(&mut self) -> &mut ::std::string::String {
        if self.firstBadLink.is_none() {
            self.firstBadLink.set_default();
        }
        self.firstBadLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstBadLink(&mut self) -> ::std::string::String {
        self.firstBadLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.OpBlockChecksumResponseProto checksumResponse = 3;


    pub fn get_checksumResponse(&self) -> &OpBlockChecksumResponseProto {
        self.checksumResponse.as_ref().unwrap_or_else(|| OpBlockChecksumResponseProto::default_instance())
    }
    pub fn clear_checksumResponse(&mut self) {
        self.checksumResponse.clear();
    }

    pub fn has_checksumResponse(&self) -> bool {
        self.checksumResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksumResponse(&mut self, v: OpBlockChecksumResponseProto) {
        self.checksumResponse = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checksumResponse(&mut self) -> &mut OpBlockChecksumResponseProto {
        if self.checksumResponse.is_none() {
            self.checksumResponse.set_default();
        }
        self.checksumResponse.as_mut().unwrap()
    }

    // Take field
    pub fn take_checksumResponse(&mut self) -> OpBlockChecksumResponseProto {
        self.checksumResponse.take().unwrap_or_else(|| OpBlockChecksumResponseProto::new())
    }

    // optional .hadoop.hdfs.ReadOpChecksumInfoProto readOpChecksumInfo = 4;


    pub fn get_readOpChecksumInfo(&self) -> &ReadOpChecksumInfoProto {
        self.readOpChecksumInfo.as_ref().unwrap_or_else(|| ReadOpChecksumInfoProto::default_instance())
    }
    pub fn clear_readOpChecksumInfo(&mut self) {
        self.readOpChecksumInfo.clear();
    }

    pub fn has_readOpChecksumInfo(&self) -> bool {
        self.readOpChecksumInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOpChecksumInfo(&mut self, v: ReadOpChecksumInfoProto) {
        self.readOpChecksumInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readOpChecksumInfo(&mut self) -> &mut ReadOpChecksumInfoProto {
        if self.readOpChecksumInfo.is_none() {
            self.readOpChecksumInfo.set_default();
        }
        self.readOpChecksumInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_readOpChecksumInfo(&mut self) -> ReadOpChecksumInfoProto {
        self.readOpChecksumInfo.take().unwrap_or_else(|| ReadOpChecksumInfoProto::new())
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 shortCircuitAccessVersion = 6;


    pub fn get_shortCircuitAccessVersion(&self) -> u32 {
        self.shortCircuitAccessVersion.unwrap_or(0)
    }
    pub fn clear_shortCircuitAccessVersion(&mut self) {
        self.shortCircuitAccessVersion = ::std::option::Option::None;
    }

    pub fn has_shortCircuitAccessVersion(&self) -> bool {
        self.shortCircuitAccessVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shortCircuitAccessVersion(&mut self, v: u32) {
        self.shortCircuitAccessVersion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockOpResponseProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        for v in &self.checksumResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readOpChecksumInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.firstBadLink)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checksumResponse)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readOpChecksumInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.shortCircuitAccessVersion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.firstBadLink.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.checksumResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readOpChecksumInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.shortCircuitAccessVersion {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.firstBadLink.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.checksumResponse.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readOpChecksumInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.shortCircuitAccessVersion {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockOpResponseProto {
        BlockOpResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &BlockOpResponseProto| { &m.status },
                    |m: &mut BlockOpResponseProto| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "firstBadLink",
                    |m: &BlockOpResponseProto| { &m.firstBadLink },
                    |m: &mut BlockOpResponseProto| { &mut m.firstBadLink },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpBlockChecksumResponseProto>>(
                    "checksumResponse",
                    |m: &BlockOpResponseProto| { &m.checksumResponse },
                    |m: &mut BlockOpResponseProto| { &mut m.checksumResponse },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReadOpChecksumInfoProto>>(
                    "readOpChecksumInfo",
                    |m: &BlockOpResponseProto| { &m.readOpChecksumInfo },
                    |m: &mut BlockOpResponseProto| { &mut m.readOpChecksumInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &BlockOpResponseProto| { &m.message },
                    |m: &mut BlockOpResponseProto| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "shortCircuitAccessVersion",
                    |m: &BlockOpResponseProto| { &m.shortCircuitAccessVersion },
                    |m: &mut BlockOpResponseProto| { &mut m.shortCircuitAccessVersion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockOpResponseProto>(
                    "BlockOpResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockOpResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<BlockOpResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockOpResponseProto,
        };
        unsafe {
            instance.get(BlockOpResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for BlockOpResponseProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.firstBadLink.clear();
        self.checksumResponse.clear();
        self.readOpChecksumInfo.clear();
        self.message.clear();
        self.shortCircuitAccessVersion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockOpResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockOpResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientReadStatusProto {
    // message fields
    status: ::std::option::Option<Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientReadStatusProto {
    fn default() -> &'a ClientReadStatusProto {
        <ClientReadStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl ClientReadStatusProto {
    pub fn new() -> ClientReadStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ClientReadStatusProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientReadStatusProto {
        ClientReadStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &ClientReadStatusProto| { &m.status },
                    |m: &mut ClientReadStatusProto| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClientReadStatusProto>(
                    "ClientReadStatusProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClientReadStatusProto {
        static mut instance: ::protobuf::lazy::Lazy<ClientReadStatusProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClientReadStatusProto,
        };
        unsafe {
            instance.get(ClientReadStatusProto::new)
        }
    }
}

impl ::protobuf::Clear for ClientReadStatusProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientReadStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientReadStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DNTransferAckProto {
    // message fields
    status: ::std::option::Option<Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DNTransferAckProto {
    fn default() -> &'a DNTransferAckProto {
        <DNTransferAckProto as ::protobuf::Message>::default_instance()
    }
}

impl DNTransferAckProto {
    pub fn new() -> DNTransferAckProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.Status status = 1;


    pub fn get_status(&self) -> Status {
        self.status.unwrap_or(Status::SUCCESS)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DNTransferAckProto {
    fn is_initialized(&self) -> bool {
        if self.status.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DNTransferAckProto {
        DNTransferAckProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Status>>(
                    "status",
                    |m: &DNTransferAckProto| { &m.status },
                    |m: &mut DNTransferAckProto| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DNTransferAckProto>(
                    "DNTransferAckProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DNTransferAckProto {
        static mut instance: ::protobuf::lazy::Lazy<DNTransferAckProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DNTransferAckProto,
        };
        unsafe {
            instance.get(DNTransferAckProto::new)
        }
    }
}

impl ::protobuf::Clear for DNTransferAckProto {
    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DNTransferAckProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DNTransferAckProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpBlockChecksumResponseProto {
    // message fields
    bytesPerCrc: ::std::option::Option<u32>,
    crcPerBlock: ::std::option::Option<u64>,
    md5: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    crcType: ::std::option::Option<super::hdfs::ChecksumTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpBlockChecksumResponseProto {
    fn default() -> &'a OpBlockChecksumResponseProto {
        <OpBlockChecksumResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl OpBlockChecksumResponseProto {
    pub fn new() -> OpBlockChecksumResponseProto {
        ::std::default::Default::default()
    }

    // required uint32 bytesPerCrc = 1;


    pub fn get_bytesPerCrc(&self) -> u32 {
        self.bytesPerCrc.unwrap_or(0)
    }
    pub fn clear_bytesPerCrc(&mut self) {
        self.bytesPerCrc = ::std::option::Option::None;
    }

    pub fn has_bytesPerCrc(&self) -> bool {
        self.bytesPerCrc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerCrc(&mut self, v: u32) {
        self.bytesPerCrc = ::std::option::Option::Some(v);
    }

    // required uint64 crcPerBlock = 2;


    pub fn get_crcPerBlock(&self) -> u64 {
        self.crcPerBlock.unwrap_or(0)
    }
    pub fn clear_crcPerBlock(&mut self) {
        self.crcPerBlock = ::std::option::Option::None;
    }

    pub fn has_crcPerBlock(&self) -> bool {
        self.crcPerBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crcPerBlock(&mut self, v: u64) {
        self.crcPerBlock = ::std::option::Option::Some(v);
    }

    // required bytes md5 = 3;


    pub fn get_md5(&self) -> &[u8] {
        match self.md5.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_md5(&mut self) {
        self.md5.clear();
    }

    pub fn has_md5(&self) -> bool {
        self.md5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_md5(&mut self, v: ::std::vec::Vec<u8>) {
        self.md5 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.md5.is_none() {
            self.md5.set_default();
        }
        self.md5.as_mut().unwrap()
    }

    // Take field
    pub fn take_md5(&mut self) -> ::std::vec::Vec<u8> {
        self.md5.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hadoop.hdfs.ChecksumTypeProto crcType = 4;


    pub fn get_crcType(&self) -> super::hdfs::ChecksumTypeProto {
        self.crcType.unwrap_or(super::hdfs::ChecksumTypeProto::CHECKSUM_NULL)
    }
    pub fn clear_crcType(&mut self) {
        self.crcType = ::std::option::Option::None;
    }

    pub fn has_crcType(&self) -> bool {
        self.crcType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crcType(&mut self, v: super::hdfs::ChecksumTypeProto) {
        self.crcType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpBlockChecksumResponseProto {
    fn is_initialized(&self) -> bool {
        if self.bytesPerCrc.is_none() {
            return false;
        }
        if self.crcPerBlock.is_none() {
            return false;
        }
        if self.md5.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerCrc = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.crcPerBlock = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.md5)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.crcType, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bytesPerCrc {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.crcPerBlock {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.md5.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.crcType {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bytesPerCrc {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.crcPerBlock {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.md5.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.crcType {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpBlockChecksumResponseProto {
        OpBlockChecksumResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bytesPerCrc",
                    |m: &OpBlockChecksumResponseProto| { &m.bytesPerCrc },
                    |m: &mut OpBlockChecksumResponseProto| { &mut m.bytesPerCrc },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "crcPerBlock",
                    |m: &OpBlockChecksumResponseProto| { &m.crcPerBlock },
                    |m: &mut OpBlockChecksumResponseProto| { &mut m.crcPerBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "md5",
                    |m: &OpBlockChecksumResponseProto| { &m.md5 },
                    |m: &mut OpBlockChecksumResponseProto| { &mut m.md5 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::hdfs::ChecksumTypeProto>>(
                    "crcType",
                    |m: &OpBlockChecksumResponseProto| { &m.crcType },
                    |m: &mut OpBlockChecksumResponseProto| { &mut m.crcType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OpBlockChecksumResponseProto>(
                    "OpBlockChecksumResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OpBlockChecksumResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<OpBlockChecksumResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OpBlockChecksumResponseProto,
        };
        unsafe {
            instance.get(OpBlockChecksumResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for OpBlockChecksumResponseProto {
    fn clear(&mut self) {
        self.bytesPerCrc = ::std::option::Option::None;
        self.crcPerBlock = ::std::option::Option::None;
        self.md5.clear();
        self.crcType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpBlockChecksumResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpBlockChecksumResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    SUCCESS = 0,
    ERROR = 1,
    ERROR_CHECKSUM = 2,
    ERROR_INVALID = 3,
    ERROR_EXISTS = 4,
    ERROR_ACCESS_TOKEN = 5,
    CHECKSUM_OK = 6,
    ERROR_UNSUPPORTED = 7,
    OOB_RESTART = 8,
    OOB_RESERVED1 = 9,
    OOB_RESERVED2 = 10,
    OOB_RESERVED3 = 11,
    IN_PROGRESS = 12,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            0 => ::std::option::Option::Some(Status::SUCCESS),
            1 => ::std::option::Option::Some(Status::ERROR),
            2 => ::std::option::Option::Some(Status::ERROR_CHECKSUM),
            3 => ::std::option::Option::Some(Status::ERROR_INVALID),
            4 => ::std::option::Option::Some(Status::ERROR_EXISTS),
            5 => ::std::option::Option::Some(Status::ERROR_ACCESS_TOKEN),
            6 => ::std::option::Option::Some(Status::CHECKSUM_OK),
            7 => ::std::option::Option::Some(Status::ERROR_UNSUPPORTED),
            8 => ::std::option::Option::Some(Status::OOB_RESTART),
            9 => ::std::option::Option::Some(Status::OOB_RESERVED1),
            10 => ::std::option::Option::Some(Status::OOB_RESERVED2),
            11 => ::std::option::Option::Some(Status::OOB_RESERVED3),
            12 => ::std::option::Option::Some(Status::IN_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::SUCCESS,
            Status::ERROR,
            Status::ERROR_CHECKSUM,
            Status::ERROR_INVALID,
            Status::ERROR_EXISTS,
            Status::ERROR_ACCESS_TOKEN,
            Status::CHECKSUM_OK,
            Status::ERROR_UNSUPPORTED,
            Status::OOB_RESTART,
            Status::OOB_RESERVED1,
            Status::OOB_RESERVED2,
            Status::OOB_RESERVED3,
            Status::IN_PROGRESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

impl ::std::default::Default for Status {
    fn default() -> Self {
        Status::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ShortCircuitFdResponse {
    DO_NOT_USE_RECEIPT_VERIFICATION = 0,
    USE_RECEIPT_VERIFICATION = 1,
}

impl ::protobuf::ProtobufEnum for ShortCircuitFdResponse {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ShortCircuitFdResponse> {
        match value {
            0 => ::std::option::Option::Some(ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION),
            1 => ::std::option::Option::Some(ShortCircuitFdResponse::USE_RECEIPT_VERIFICATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ShortCircuitFdResponse] = &[
            ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION,
            ShortCircuitFdResponse::USE_RECEIPT_VERIFICATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ShortCircuitFdResponse", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ShortCircuitFdResponse {
}

impl ::std::default::Default for ShortCircuitFdResponse {
    fn default() -> Self {
        ShortCircuitFdResponse::DO_NOT_USE_RECEIPT_VERIFICATION
    }
}

impl ::protobuf::reflect::ProtobufValue for ShortCircuitFdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12datatransfer.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.proto\x1a\nh\
    dfs.proto\"\xa5\x02\n!DataTransferEncryptorMessageProto\x12Z\n\x06status\
    \x18\x01\x20\x02(\x0e2J.hadoop.hdfs.DataTransferEncryptorMessageProto.Da\
    taTransferEncryptorStatus\x12\x0f\n\x07payload\x18\x02\x20\x01(\x0c\x12\
    \x0f\n\x07message\x18\x03\x20\x01(\t\x124\n\x0ccipherOption\x18\x04\x20\
    \x03(\x0b2\x1e.hadoop.hdfs.CipherOptionProto\"L\n\x1bDataTransferEncrypt\
    orStatus\x12\x0b\n\x07SUCCESS\x10\0\x12\x15\n\x11ERROR_UNKNOWN_KEY\x10\
    \x01\x12\t\n\x05ERROR\x10\x02\"\xa7\x01\n\x0fBaseHeaderProto\x12.\n\x05b\
    lock\x18\x01\x20\x02(\x0b2\x1f.hadoop.hdfs.ExtendedBlockProto\x12(\n\x05\
    token\x18\x02\x20\x01(\x0b2\x19.hadoop.common.TokenProto\x12:\n\ttraceIn\
    fo\x18\x03\x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceInfoProto\"?\n\
    \x1aDataTransferTraceInfoProto\x12\x0f\n\x07traceId\x18\x01\x20\x02(\x04\
    \x12\x10\n\x08parentId\x18\x02\x20\x02(\x04\"b\n\x1aClientOperationHeade\
    rProto\x120\n\nbaseHeader\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.BaseHead\
    erProto\x12\x12\n\nclientName\x18\x02\x20\x02(\t\"=\n\x14CachingStrategy\
    Proto\x12\x12\n\ndropBehind\x18\x01\x20\x01(\x08\x12\x11\n\treadahead\
    \x18\x02\x20\x01(\x03\"\xc1\x01\n\x10OpReadBlockProto\x127\n\x06header\
    \x18\x01\x20\x02(\x0b2'.hadoop.hdfs.ClientOperationHeaderProto\x12\x0e\n\
    \x06offset\x18\x02\x20\x02(\x04\x12\x0b\n\x03len\x18\x03\x20\x02(\x04\
    \x12\x1b\n\rsendChecksums\x18\x04\x20\x01(\x08:\x04true\x12:\n\x0fcachin\
    gStrategy\x18\x05\x20\x01(\x0b2!.hadoop.hdfs.CachingStrategyProto\"W\n\r\
    ChecksumProto\x12,\n\x04type\x18\x01\x20\x02(\x0e2\x1e.hadoop.hdfs.Check\
    sumTypeProto\x12\x18\n\x10bytesPerChecksum\x18\x02\x20\x02(\r\"\x98\x07\
    \n\x11OpWriteBlockProto\x127\n\x06header\x18\x01\x20\x02(\x0b2'.hadoop.h\
    dfs.ClientOperationHeaderProto\x12/\n\x07targets\x18\x02\x20\x03(\x0b2\
    \x1e.hadoop.hdfs.DatanodeInfoProto\x12.\n\x06source\x18\x03\x20\x01(\x0b\
    2\x1e.hadoop.hdfs.DatanodeInfoProto\x12D\n\x05stage\x18\x04\x20\x02(\x0e\
    25.hadoop.hdfs.OpWriteBlockProto.BlockConstructionStage\x12\x14\n\x0cpip\
    elineSize\x18\x05\x20\x02(\r\x12\x14\n\x0cminBytesRcvd\x18\x06\x20\x02(\
    \x04\x12\x14\n\x0cmaxBytesRcvd\x18\x07\x20\x02(\x04\x12\x1d\n\x15latestG\
    enerationStamp\x18\x08\x20\x02(\x04\x125\n\x11requestedChecksum\x18\t\
    \x20\x02(\x0b2\x1a.hadoop.hdfs.ChecksumProto\x12:\n\x0fcachingStrategy\
    \x18\n\x20\x01(\x0b2!.hadoop.hdfs.CachingStrategyProto\x128\n\x0bstorage\
    Type\x18\x0b\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageTypeProto:\x04DISK\x12\
    9\n\x12targetStorageTypes\x18\x0c\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageT\
    ypeProto\x12\x1f\n\x10allowLazyPersist\x18\r\x20\x01(\x08:\x05false\x12\
    \x16\n\x07pinning\x18\x0e\x20\x01(\x08:\x05false\x12\x16\n\x0etargetPinn\
    ings\x18\x0f\x20\x03(\x08\"\x88\x02\n\x16BlockConstructionStage\x12\x19\
    \n\x15PIPELINE_SETUP_APPEND\x10\0\x12\"\n\x1ePIPELINE_SETUP_APPEND_RECOV\
    ERY\x10\x01\x12\x12\n\x0eDATA_STREAMING\x10\x02\x12%\n!PIPELINE_SETUP_ST\
    REAMING_RECOVERY\x10\x03\x12\x12\n\x0ePIPELINE_CLOSE\x10\x04\x12\x1b\n\
    \x17PIPELINE_CLOSE_RECOVERY\x10\x05\x12\x19\n\x15PIPELINE_SETUP_CREATE\
    \x10\x06\x12\x10\n\x0cTRANSFER_RBW\x10\x07\x12\x16\n\x12TRANSFER_FINALIZ\
    ED\x10\x08\"\xbb\x01\n\x14OpTransferBlockProto\x127\n\x06header\x18\x01\
    \x20\x02(\x0b2'.hadoop.hdfs.ClientOperationHeaderProto\x12/\n\x07targets\
    \x18\x02\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x129\n\x12targe\
    tStorageTypes\x18\x03\x20\x03(\x0e2\x1d.hadoop.hdfs.StorageTypeProto\"\
    \xbe\x01\n\x13OpReplaceBlockProto\x12,\n\x06header\x18\x01\x20\x02(\x0b2\
    \x1c.hadoop.hdfs.BaseHeaderProto\x12\x0f\n\x07delHint\x18\x02\x20\x02(\t\
    \x12.\n\x06source\x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProt\
    o\x128\n\x0bstorageType\x18\x04\x20\x01(\x0e2\x1d.hadoop.hdfs.StorageTyp\
    eProto:\x04DISK\"@\n\x10OpCopyBlockProto\x12,\n\x06header\x18\x01\x20\
    \x02(\x0b2\x1c.hadoop.hdfs.BaseHeaderProto\"D\n\x14OpBlockChecksumProto\
    \x12,\n\x06header\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.BaseHeaderProto\
    \"0\n\x16ShortCircuitShmIdProto\x12\n\n\x02hi\x18\x01\x20\x02(\x03\x12\n\
    \n\x02lo\x18\x02\x20\x02(\x03\"_\n\x18ShortCircuitShmSlotProto\x122\n\
    \x05shmId\x18\x01\x20\x02(\x0b2#.hadoop.hdfs.ShortCircuitShmIdProto\x12\
    \x0f\n\x07slotIdx\x18\x02\x20\x02(\x05\"\xc7\x01\n\x20OpRequestShortCirc\
    uitAccessProto\x12,\n\x06header\x18\x01\x20\x02(\x0b2\x1c.hadoop.hdfs.Ba\
    seHeaderProto\x12\x12\n\nmaxVersion\x18\x02\x20\x02(\r\x125\n\x06slotId\
    \x18\x03\x20\x01(\x0b2%.hadoop.hdfs.ShortCircuitShmSlotProto\x12*\n\x1bs\
    upportsReceiptVerification\x18\x04\x20\x01(\x08:\x05false\"\x9a\x01\n%Re\
    leaseShortCircuitAccessRequestProto\x125\n\x06slotId\x18\x01\x20\x02(\
    \x0b2%.hadoop.hdfs.ShortCircuitShmSlotProto\x12:\n\ttraceInfo\x18\x02\
    \x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceInfoProto\"\\\n&ReleaseShor\
    tCircuitAccessResponseProto\x12#\n\x06status\x18\x01\x20\x02(\x0e2\x13.h\
    adoop.hdfs.Status\x12\r\n\x05error\x18\x02\x20\x01(\t\"m\n\x1bShortCircu\
    itShmRequestProto\x12\x12\n\nclientName\x18\x01\x20\x02(\t\x12:\n\ttrace\
    Info\x18\x02\x20\x01(\x0b2'.hadoop.hdfs.DataTransferTraceInfoProto\"\x83\
    \x01\n\x1cShortCircuitShmResponseProto\x12#\n\x06status\x18\x01\x20\x02(\
    \x0e2\x13.hadoop.hdfs.Status\x12\r\n\x05error\x18\x02\x20\x01(\t\x12/\n\
    \x02id\x18\x03\x20\x01(\x0b2#.hadoop.hdfs.ShortCircuitShmIdProto\"\x7f\n\
    \x11PacketHeaderProto\x12\x15\n\roffsetInBlock\x18\x01\x20\x02(\x10\x12\
    \r\n\x05seqno\x18\x02\x20\x02(\x10\x12\x19\n\x11lastPacketInBlock\x18\
    \x03\x20\x02(\x08\x12\x0f\n\x07dataLen\x18\x04\x20\x02(\x0f\x12\x18\n\ts\
    yncBlock\x18\x05\x20\x01(\x08:\x05false\"z\n\x10PipelineAckProto\x12\r\n\
    \x05seqno\x18\x01\x20\x02(\x12\x12\"\n\x05reply\x18\x02\x20\x03(\x0e2\
    \x13.hadoop.hdfs.Status\x12!\n\x16downstreamAckTimeNanos\x18\x03\x20\x01\
    (\x04:\x010\x12\x10\n\x04flag\x18\x04\x20\x03(\rB\x02\x10\x01\"\\\n\x17R\
    eadOpChecksumInfoProto\x12,\n\x08checksum\x18\x01\x20\x02(\x0b2\x1a.hado\
    op.hdfs.ChecksumProto\x12\x13\n\x0bchunkOffset\x18\x02\x20\x02(\x04\"\
    \x8c\x02\n\x14BlockOpResponseProto\x12#\n\x06status\x18\x01\x20\x02(\x0e\
    2\x13.hadoop.hdfs.Status\x12\x14\n\x0cfirstBadLink\x18\x02\x20\x01(\t\
    \x12C\n\x10checksumResponse\x18\x03\x20\x01(\x0b2).hadoop.hdfs.OpBlockCh\
    ecksumResponseProto\x12@\n\x12readOpChecksumInfo\x18\x04\x20\x01(\x0b2$.\
    hadoop.hdfs.ReadOpChecksumInfoProto\x12\x0f\n\x07message\x18\x05\x20\x01\
    (\t\x12!\n\x19shortCircuitAccessVersion\x18\x06\x20\x01(\r\"<\n\x15Clien\
    tReadStatusProto\x12#\n\x06status\x18\x01\x20\x02(\x0e2\x13.hadoop.hdfs.\
    Status\"9\n\x12DNTransferAckProto\x12#\n\x06status\x18\x01\x20\x02(\x0e2\
    \x13.hadoop.hdfs.Status\"\x86\x01\n\x1cOpBlockChecksumResponseProto\x12\
    \x13\n\x0bbytesPerCrc\x18\x01\x20\x02(\r\x12\x13\n\x0bcrcPerBlock\x18\
    \x02\x20\x02(\x04\x12\x0b\n\x03md5\x18\x03\x20\x02(\x0c\x12/\n\x07crcTyp\
    e\x18\x04\x20\x01(\x0e2\x1e.hadoop.hdfs.ChecksumTypeProto*\xf4\x01\n\x06\
    Status\x12\x0b\n\x07SUCCESS\x10\0\x12\t\n\x05ERROR\x10\x01\x12\x12\n\x0e\
    ERROR_CHECKSUM\x10\x02\x12\x11\n\rERROR_INVALID\x10\x03\x12\x10\n\x0cERR\
    OR_EXISTS\x10\x04\x12\x16\n\x12ERROR_ACCESS_TOKEN\x10\x05\x12\x0f\n\x0bC\
    HECKSUM_OK\x10\x06\x12\x15\n\x11ERROR_UNSUPPORTED\x10\x07\x12\x0f\n\x0bO\
    OB_RESTART\x10\x08\x12\x11\n\rOOB_RESERVED1\x10\t\x12\x11\n\rOOB_RESERVE\
    D2\x10\n\x12\x11\n\rOOB_RESERVED3\x10\x0b\x12\x0f\n\x0bIN_PROGRESS\x10\
    \x0c*[\n\x16ShortCircuitFdResponse\x12#\n\x1fDO_NOT_USE_RECEIPT_VERIFICA\
    TION\x10\0\x12\x1c\n\x18USE_RECEIPT_VERIFICATION\x10\x01B>\n%org.apache.\
    hadoop.hdfs.protocol.protoB\x12DataTransferProtos\xa0\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
