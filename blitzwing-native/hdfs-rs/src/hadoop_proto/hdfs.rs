// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `hdfs.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct ExtendedBlockProto {
    // message fields
    poolId: ::protobuf::SingularField<::std::string::String>,
    blockId: ::std::option::Option<u64>,
    generationStamp: ::std::option::Option<u64>,
    numBytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtendedBlockProto {
    fn default() -> &'a ExtendedBlockProto {
        <ExtendedBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl ExtendedBlockProto {
    pub fn new() -> ExtendedBlockProto {
        ::std::default::Default::default()
    }

    // required string poolId = 1;


    pub fn get_poolId(&self) -> &str {
        match self.poolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_poolId(&mut self) {
        self.poolId.clear();
    }

    pub fn has_poolId(&self) -> bool {
        self.poolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poolId(&mut self, v: ::std::string::String) {
        self.poolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poolId(&mut self) -> &mut ::std::string::String {
        if self.poolId.is_none() {
            self.poolId.set_default();
        }
        self.poolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_poolId(&mut self) -> ::std::string::String {
        self.poolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 blockId = 2;


    pub fn get_blockId(&self) -> u64 {
        self.blockId.unwrap_or(0)
    }
    pub fn clear_blockId(&mut self) {
        self.blockId = ::std::option::Option::None;
    }

    pub fn has_blockId(&self) -> bool {
        self.blockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockId(&mut self, v: u64) {
        self.blockId = ::std::option::Option::Some(v);
    }

    // required uint64 generationStamp = 3;


    pub fn get_generationStamp(&self) -> u64 {
        self.generationStamp.unwrap_or(0)
    }
    pub fn clear_generationStamp(&mut self) {
        self.generationStamp = ::std::option::Option::None;
    }

    pub fn has_generationStamp(&self) -> bool {
        self.generationStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generationStamp(&mut self, v: u64) {
        self.generationStamp = ::std::option::Option::Some(v);
    }

    // optional uint64 numBytes = 4;


    pub fn get_numBytes(&self) -> u64 {
        self.numBytes.unwrap_or(0u64)
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = ::std::option::Option::None;
    }

    pub fn has_numBytes(&self) -> bool {
        self.numBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: u64) {
        self.numBytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ExtendedBlockProto {
    fn is_initialized(&self) -> bool {
        if self.poolId.is_none() {
            return false;
        }
        if self.blockId.is_none() {
            return false;
        }
        if self.generationStamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.poolId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.generationStamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.poolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.blockId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.generationStamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBytes {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.poolId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.blockId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.generationStamp {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.numBytes {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtendedBlockProto {
        ExtendedBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "poolId",
                    |m: &ExtendedBlockProto| { &m.poolId },
                    |m: &mut ExtendedBlockProto| { &mut m.poolId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockId",
                    |m: &ExtendedBlockProto| { &m.blockId },
                    |m: &mut ExtendedBlockProto| { &mut m.blockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "generationStamp",
                    |m: &ExtendedBlockProto| { &m.generationStamp },
                    |m: &mut ExtendedBlockProto| { &mut m.generationStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "numBytes",
                    |m: &ExtendedBlockProto| { &m.numBytes },
                    |m: &mut ExtendedBlockProto| { &mut m.numBytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtendedBlockProto>(
                    "ExtendedBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtendedBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<ExtendedBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtendedBlockProto,
        };
        unsafe {
            instance.get(ExtendedBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for ExtendedBlockProto {
    fn clear(&mut self) {
        self.poolId.clear();
        self.blockId = ::std::option::Option::None;
        self.generationStamp = ::std::option::Option::None;
        self.numBytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtendedBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendedBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeIDProto {
    // message fields
    ipAddr: ::protobuf::SingularField<::std::string::String>,
    hostName: ::protobuf::SingularField<::std::string::String>,
    datanodeUuid: ::protobuf::SingularField<::std::string::String>,
    xferPort: ::std::option::Option<u32>,
    infoPort: ::std::option::Option<u32>,
    ipcPort: ::std::option::Option<u32>,
    infoSecurePort: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeIDProto {
    fn default() -> &'a DatanodeIDProto {
        <DatanodeIDProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeIDProto {
    pub fn new() -> DatanodeIDProto {
        ::std::default::Default::default()
    }

    // required string ipAddr = 1;


    pub fn get_ipAddr(&self) -> &str {
        match self.ipAddr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipAddr(&mut self) {
        self.ipAddr.clear();
    }

    pub fn has_ipAddr(&self) -> bool {
        self.ipAddr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipAddr(&mut self, v: ::std::string::String) {
        self.ipAddr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipAddr(&mut self) -> &mut ::std::string::String {
        if self.ipAddr.is_none() {
            self.ipAddr.set_default();
        }
        self.ipAddr.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipAddr(&mut self) -> ::std::string::String {
        self.ipAddr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string hostName = 2;


    pub fn get_hostName(&self) -> &str {
        match self.hostName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostName(&mut self) {
        self.hostName.clear();
    }

    pub fn has_hostName(&self) -> bool {
        self.hostName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostName(&mut self, v: ::std::string::String) {
        self.hostName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostName(&mut self) -> &mut ::std::string::String {
        if self.hostName.is_none() {
            self.hostName.set_default();
        }
        self.hostName.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostName(&mut self) -> ::std::string::String {
        self.hostName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string datanodeUuid = 3;


    pub fn get_datanodeUuid(&self) -> &str {
        match self.datanodeUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_datanodeUuid(&mut self) {
        self.datanodeUuid.clear();
    }

    pub fn has_datanodeUuid(&self) -> bool {
        self.datanodeUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datanodeUuid(&mut self, v: ::std::string::String) {
        self.datanodeUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datanodeUuid(&mut self) -> &mut ::std::string::String {
        if self.datanodeUuid.is_none() {
            self.datanodeUuid.set_default();
        }
        self.datanodeUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_datanodeUuid(&mut self) -> ::std::string::String {
        self.datanodeUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 xferPort = 4;


    pub fn get_xferPort(&self) -> u32 {
        self.xferPort.unwrap_or(0)
    }
    pub fn clear_xferPort(&mut self) {
        self.xferPort = ::std::option::Option::None;
    }

    pub fn has_xferPort(&self) -> bool {
        self.xferPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xferPort(&mut self, v: u32) {
        self.xferPort = ::std::option::Option::Some(v);
    }

    // required uint32 infoPort = 5;


    pub fn get_infoPort(&self) -> u32 {
        self.infoPort.unwrap_or(0)
    }
    pub fn clear_infoPort(&mut self) {
        self.infoPort = ::std::option::Option::None;
    }

    pub fn has_infoPort(&self) -> bool {
        self.infoPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoPort(&mut self, v: u32) {
        self.infoPort = ::std::option::Option::Some(v);
    }

    // required uint32 ipcPort = 6;


    pub fn get_ipcPort(&self) -> u32 {
        self.ipcPort.unwrap_or(0)
    }
    pub fn clear_ipcPort(&mut self) {
        self.ipcPort = ::std::option::Option::None;
    }

    pub fn has_ipcPort(&self) -> bool {
        self.ipcPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipcPort(&mut self, v: u32) {
        self.ipcPort = ::std::option::Option::Some(v);
    }

    // optional uint32 infoSecurePort = 7;


    pub fn get_infoSecurePort(&self) -> u32 {
        self.infoSecurePort.unwrap_or(0u32)
    }
    pub fn clear_infoSecurePort(&mut self) {
        self.infoSecurePort = ::std::option::Option::None;
    }

    pub fn has_infoSecurePort(&self) -> bool {
        self.infoSecurePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoSecurePort(&mut self, v: u32) {
        self.infoSecurePort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeIDProto {
    fn is_initialized(&self) -> bool {
        if self.ipAddr.is_none() {
            return false;
        }
        if self.hostName.is_none() {
            return false;
        }
        if self.datanodeUuid.is_none() {
            return false;
        }
        if self.xferPort.is_none() {
            return false;
        }
        if self.infoPort.is_none() {
            return false;
        }
        if self.ipcPort.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipAddr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datanodeUuid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xferPort = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.infoPort = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ipcPort = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.infoSecurePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ipAddr.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.datanodeUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.xferPort {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.infoPort {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ipcPort {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.infoSecurePort {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ipAddr.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.datanodeUuid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.xferPort {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.infoPort {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ipcPort {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.infoSecurePort {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeIDProto {
        DatanodeIDProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ipAddr",
                    |m: &DatanodeIDProto| { &m.ipAddr },
                    |m: &mut DatanodeIDProto| { &mut m.ipAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostName",
                    |m: &DatanodeIDProto| { &m.hostName },
                    |m: &mut DatanodeIDProto| { &mut m.hostName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "datanodeUuid",
                    |m: &DatanodeIDProto| { &m.datanodeUuid },
                    |m: &mut DatanodeIDProto| { &mut m.datanodeUuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xferPort",
                    |m: &DatanodeIDProto| { &m.xferPort },
                    |m: &mut DatanodeIDProto| { &mut m.xferPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "infoPort",
                    |m: &DatanodeIDProto| { &m.infoPort },
                    |m: &mut DatanodeIDProto| { &mut m.infoPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "ipcPort",
                    |m: &DatanodeIDProto| { &m.ipcPort },
                    |m: &mut DatanodeIDProto| { &mut m.ipcPort },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "infoSecurePort",
                    |m: &DatanodeIDProto| { &m.infoSecurePort },
                    |m: &mut DatanodeIDProto| { &mut m.infoSecurePort },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeIDProto>(
                    "DatanodeIDProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeIDProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeIDProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeIDProto,
        };
        unsafe {
            instance.get(DatanodeIDProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeIDProto {
    fn clear(&mut self) {
        self.ipAddr.clear();
        self.hostName.clear();
        self.datanodeUuid.clear();
        self.xferPort = ::std::option::Option::None;
        self.infoPort = ::std::option::Option::None;
        self.ipcPort = ::std::option::Option::None;
        self.infoSecurePort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeIDProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeIDProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeLocalInfoProto {
    // message fields
    softwareVersion: ::protobuf::SingularField<::std::string::String>,
    configVersion: ::protobuf::SingularField<::std::string::String>,
    uptime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeLocalInfoProto {
    fn default() -> &'a DatanodeLocalInfoProto {
        <DatanodeLocalInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeLocalInfoProto {
    pub fn new() -> DatanodeLocalInfoProto {
        ::std::default::Default::default()
    }

    // required string softwareVersion = 1;


    pub fn get_softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion.clear();
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion.set_default();
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string configVersion = 2;


    pub fn get_configVersion(&self) -> &str {
        match self.configVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_configVersion(&mut self) {
        self.configVersion.clear();
    }

    pub fn has_configVersion(&self) -> bool {
        self.configVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configVersion(&mut self, v: ::std::string::String) {
        self.configVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configVersion(&mut self) -> &mut ::std::string::String {
        if self.configVersion.is_none() {
            self.configVersion.set_default();
        }
        self.configVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_configVersion(&mut self) -> ::std::string::String {
        self.configVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 uptime = 3;


    pub fn get_uptime(&self) -> u64 {
        self.uptime.unwrap_or(0)
    }
    pub fn clear_uptime(&mut self) {
        self.uptime = ::std::option::Option::None;
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: u64) {
        self.uptime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeLocalInfoProto {
    fn is_initialized(&self) -> bool {
        if self.softwareVersion.is_none() {
            return false;
        }
        if self.configVersion.is_none() {
            return false;
        }
        if self.uptime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.softwareVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.configVersion)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uptime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.configVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.uptime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.softwareVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.configVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.uptime {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeLocalInfoProto {
        DatanodeLocalInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "softwareVersion",
                    |m: &DatanodeLocalInfoProto| { &m.softwareVersion },
                    |m: &mut DatanodeLocalInfoProto| { &mut m.softwareVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "configVersion",
                    |m: &DatanodeLocalInfoProto| { &m.configVersion },
                    |m: &mut DatanodeLocalInfoProto| { &mut m.configVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "uptime",
                    |m: &DatanodeLocalInfoProto| { &m.uptime },
                    |m: &mut DatanodeLocalInfoProto| { &mut m.uptime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeLocalInfoProto>(
                    "DatanodeLocalInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeLocalInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeLocalInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeLocalInfoProto,
        };
        unsafe {
            instance.get(DatanodeLocalInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeLocalInfoProto {
    fn clear(&mut self) {
        self.softwareVersion.clear();
        self.configVersion.clear();
        self.uptime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeLocalInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeLocalInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeInfosProto {
    // message fields
    datanodes: ::protobuf::RepeatedField<DatanodeInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeInfosProto {
    fn default() -> &'a DatanodeInfosProto {
        <DatanodeInfosProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeInfosProto {
    pub fn new() -> DatanodeInfosProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;


    pub fn get_datanodes(&self) -> &[DatanodeInfoProto] {
        &self.datanodes
    }
    pub fn clear_datanodes(&mut self) {
        self.datanodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodes(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.datanodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodes(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.datanodes
    }

    // Take field
    pub fn take_datanodes(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.datanodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DatanodeInfosProto {
    fn is_initialized(&self) -> bool {
        for v in &self.datanodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.datanodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datanodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datanodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeInfosProto {
        DatanodeInfosProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeInfoProto>>(
                    "datanodes",
                    |m: &DatanodeInfosProto| { &m.datanodes },
                    |m: &mut DatanodeInfosProto| { &mut m.datanodes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeInfosProto>(
                    "DatanodeInfosProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeInfosProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeInfosProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeInfosProto,
        };
        unsafe {
            instance.get(DatanodeInfosProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeInfosProto {
    fn clear(&mut self) {
        self.datanodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeInfosProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfosProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeInfoProto {
    // message fields
    id: ::protobuf::SingularPtrField<DatanodeIDProto>,
    capacity: ::std::option::Option<u64>,
    dfsUsed: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    blockPoolUsed: ::std::option::Option<u64>,
    lastUpdate: ::std::option::Option<u64>,
    xceiverCount: ::std::option::Option<u32>,
    location: ::protobuf::SingularField<::std::string::String>,
    nonDfsUsed: ::std::option::Option<u64>,
    adminState: ::std::option::Option<DatanodeInfoProto_AdminState>,
    cacheCapacity: ::std::option::Option<u64>,
    cacheUsed: ::std::option::Option<u64>,
    lastUpdateMonotonic: ::std::option::Option<u64>,
    lastBlockReportTime: ::std::option::Option<u64>,
    lastBlockReportMonotonic: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeInfoProto {
    fn default() -> &'a DatanodeInfoProto {
        <DatanodeInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeInfoProto {
    pub fn new() -> DatanodeInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.DatanodeIDProto id = 1;


    pub fn get_id(&self) -> &DatanodeIDProto {
        self.id.as_ref().unwrap_or_else(|| DatanodeIDProto::default_instance())
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: DatanodeIDProto) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut DatanodeIDProto {
        if self.id.is_none() {
            self.id.set_default();
        }
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> DatanodeIDProto {
        self.id.take().unwrap_or_else(|| DatanodeIDProto::new())
    }

    // optional uint64 capacity = 2;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0u64)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // optional uint64 dfsUsed = 3;


    pub fn get_dfsUsed(&self) -> u64 {
        self.dfsUsed.unwrap_or(0u64)
    }
    pub fn clear_dfsUsed(&mut self) {
        self.dfsUsed = ::std::option::Option::None;
    }

    pub fn has_dfsUsed(&self) -> bool {
        self.dfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfsUsed(&mut self, v: u64) {
        self.dfsUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 remaining = 4;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0u64)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // optional uint64 blockPoolUsed = 5;


    pub fn get_blockPoolUsed(&self) -> u64 {
        self.blockPoolUsed.unwrap_or(0u64)
    }
    pub fn clear_blockPoolUsed(&mut self) {
        self.blockPoolUsed = ::std::option::Option::None;
    }

    pub fn has_blockPoolUsed(&self) -> bool {
        self.blockPoolUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolUsed(&mut self, v: u64) {
        self.blockPoolUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 lastUpdate = 6;


    pub fn get_lastUpdate(&self) -> u64 {
        self.lastUpdate.unwrap_or(0u64)
    }
    pub fn clear_lastUpdate(&mut self) {
        self.lastUpdate = ::std::option::Option::None;
    }

    pub fn has_lastUpdate(&self) -> bool {
        self.lastUpdate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdate(&mut self, v: u64) {
        self.lastUpdate = ::std::option::Option::Some(v);
    }

    // optional uint32 xceiverCount = 7;


    pub fn get_xceiverCount(&self) -> u32 {
        self.xceiverCount.unwrap_or(0u32)
    }
    pub fn clear_xceiverCount(&mut self) {
        self.xceiverCount = ::std::option::Option::None;
    }

    pub fn has_xceiverCount(&self) -> bool {
        self.xceiverCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xceiverCount(&mut self, v: u32) {
        self.xceiverCount = ::std::option::Option::Some(v);
    }

    // optional string location = 8;


    pub fn get_location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 nonDfsUsed = 9;


    pub fn get_nonDfsUsed(&self) -> u64 {
        self.nonDfsUsed.unwrap_or(0)
    }
    pub fn clear_nonDfsUsed(&mut self) {
        self.nonDfsUsed = ::std::option::Option::None;
    }

    pub fn has_nonDfsUsed(&self) -> bool {
        self.nonDfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonDfsUsed(&mut self, v: u64) {
        self.nonDfsUsed = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10;


    pub fn get_adminState(&self) -> DatanodeInfoProto_AdminState {
        self.adminState.unwrap_or(DatanodeInfoProto_AdminState::NORMAL)
    }
    pub fn clear_adminState(&mut self) {
        self.adminState = ::std::option::Option::None;
    }

    pub fn has_adminState(&self) -> bool {
        self.adminState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminState(&mut self, v: DatanodeInfoProto_AdminState) {
        self.adminState = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheCapacity = 11;


    pub fn get_cacheCapacity(&self) -> u64 {
        self.cacheCapacity.unwrap_or(0u64)
    }
    pub fn clear_cacheCapacity(&mut self) {
        self.cacheCapacity = ::std::option::Option::None;
    }

    pub fn has_cacheCapacity(&self) -> bool {
        self.cacheCapacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheCapacity(&mut self, v: u64) {
        self.cacheCapacity = ::std::option::Option::Some(v);
    }

    // optional uint64 cacheUsed = 12;


    pub fn get_cacheUsed(&self) -> u64 {
        self.cacheUsed.unwrap_or(0u64)
    }
    pub fn clear_cacheUsed(&mut self) {
        self.cacheUsed = ::std::option::Option::None;
    }

    pub fn has_cacheUsed(&self) -> bool {
        self.cacheUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cacheUsed(&mut self, v: u64) {
        self.cacheUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 lastUpdateMonotonic = 13;


    pub fn get_lastUpdateMonotonic(&self) -> u64 {
        self.lastUpdateMonotonic.unwrap_or(0u64)
    }
    pub fn clear_lastUpdateMonotonic(&mut self) {
        self.lastUpdateMonotonic = ::std::option::Option::None;
    }

    pub fn has_lastUpdateMonotonic(&self) -> bool {
        self.lastUpdateMonotonic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastUpdateMonotonic(&mut self, v: u64) {
        self.lastUpdateMonotonic = ::std::option::Option::Some(v);
    }

    // optional uint64 lastBlockReportTime = 15;


    pub fn get_lastBlockReportTime(&self) -> u64 {
        self.lastBlockReportTime.unwrap_or(0u64)
    }
    pub fn clear_lastBlockReportTime(&mut self) {
        self.lastBlockReportTime = ::std::option::Option::None;
    }

    pub fn has_lastBlockReportTime(&self) -> bool {
        self.lastBlockReportTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockReportTime(&mut self, v: u64) {
        self.lastBlockReportTime = ::std::option::Option::Some(v);
    }

    // optional uint64 lastBlockReportMonotonic = 16;


    pub fn get_lastBlockReportMonotonic(&self) -> u64 {
        self.lastBlockReportMonotonic.unwrap_or(0u64)
    }
    pub fn clear_lastBlockReportMonotonic(&mut self) {
        self.lastBlockReportMonotonic = ::std::option::Option::None;
    }

    pub fn has_lastBlockReportMonotonic(&self) -> bool {
        self.lastBlockReportMonotonic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlockReportMonotonic(&mut self, v: u64) {
        self.lastBlockReportMonotonic = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeInfoProto {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        for v in &self.id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dfsUsed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockPoolUsed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastUpdate = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.xceiverCount = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonDfsUsed = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.adminState, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheCapacity = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cacheUsed = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastUpdateMonotonic = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastBlockReportTime = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.lastBlockReportMonotonic = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dfsUsed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockPoolUsed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastUpdate {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.xceiverCount {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.nonDfsUsed {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.adminState {
            my_size += ::protobuf::rt::enum_size(10, v);
        }
        if let Some(v) = self.cacheCapacity {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cacheUsed {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastUpdateMonotonic {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastBlockReportTime {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.lastBlockReportMonotonic {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.capacity {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.dfsUsed {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.blockPoolUsed {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.lastUpdate {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.xceiverCount {
            os.write_uint32(7, v)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.nonDfsUsed {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.adminState {
            os.write_enum(10, v.value())?;
        }
        if let Some(v) = self.cacheCapacity {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.cacheUsed {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.lastUpdateMonotonic {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.lastBlockReportTime {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.lastBlockReportMonotonic {
            os.write_uint64(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeInfoProto {
        DatanodeInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeIDProto>>(
                    "id",
                    |m: &DatanodeInfoProto| { &m.id },
                    |m: &mut DatanodeInfoProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    |m: &DatanodeInfoProto| { &m.capacity },
                    |m: &mut DatanodeInfoProto| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dfsUsed",
                    |m: &DatanodeInfoProto| { &m.dfsUsed },
                    |m: &mut DatanodeInfoProto| { &mut m.dfsUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining",
                    |m: &DatanodeInfoProto| { &m.remaining },
                    |m: &mut DatanodeInfoProto| { &mut m.remaining },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockPoolUsed",
                    |m: &DatanodeInfoProto| { &m.blockPoolUsed },
                    |m: &mut DatanodeInfoProto| { &mut m.blockPoolUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lastUpdate",
                    |m: &DatanodeInfoProto| { &m.lastUpdate },
                    |m: &mut DatanodeInfoProto| { &mut m.lastUpdate },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "xceiverCount",
                    |m: &DatanodeInfoProto| { &m.xceiverCount },
                    |m: &mut DatanodeInfoProto| { &mut m.xceiverCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "location",
                    |m: &DatanodeInfoProto| { &m.location },
                    |m: &mut DatanodeInfoProto| { &mut m.location },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonDfsUsed",
                    |m: &DatanodeInfoProto| { &m.nonDfsUsed },
                    |m: &mut DatanodeInfoProto| { &mut m.nonDfsUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeInfoProto_AdminState>>(
                    "adminState",
                    |m: &DatanodeInfoProto| { &m.adminState },
                    |m: &mut DatanodeInfoProto| { &mut m.adminState },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cacheCapacity",
                    |m: &DatanodeInfoProto| { &m.cacheCapacity },
                    |m: &mut DatanodeInfoProto| { &mut m.cacheCapacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cacheUsed",
                    |m: &DatanodeInfoProto| { &m.cacheUsed },
                    |m: &mut DatanodeInfoProto| { &mut m.cacheUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lastUpdateMonotonic",
                    |m: &DatanodeInfoProto| { &m.lastUpdateMonotonic },
                    |m: &mut DatanodeInfoProto| { &mut m.lastUpdateMonotonic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lastBlockReportTime",
                    |m: &DatanodeInfoProto| { &m.lastBlockReportTime },
                    |m: &mut DatanodeInfoProto| { &mut m.lastBlockReportTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "lastBlockReportMonotonic",
                    |m: &DatanodeInfoProto| { &m.lastBlockReportMonotonic },
                    |m: &mut DatanodeInfoProto| { &mut m.lastBlockReportMonotonic },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeInfoProto>(
                    "DatanodeInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeInfoProto,
        };
        unsafe {
            instance.get(DatanodeInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeInfoProto {
    fn clear(&mut self) {
        self.id.clear();
        self.capacity = ::std::option::Option::None;
        self.dfsUsed = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.blockPoolUsed = ::std::option::Option::None;
        self.lastUpdate = ::std::option::Option::None;
        self.xceiverCount = ::std::option::Option::None;
        self.location.clear();
        self.nonDfsUsed = ::std::option::Option::None;
        self.adminState = ::std::option::Option::None;
        self.cacheCapacity = ::std::option::Option::None;
        self.cacheUsed = ::std::option::Option::None;
        self.lastUpdateMonotonic = ::std::option::Option::None;
        self.lastBlockReportTime = ::std::option::Option::None;
        self.lastBlockReportMonotonic = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeInfoProto_AdminState {
    NORMAL = 0,
    DECOMMISSION_INPROGRESS = 1,
    DECOMMISSIONED = 2,
}

impl ::protobuf::ProtobufEnum for DatanodeInfoProto_AdminState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeInfoProto_AdminState> {
        match value {
            0 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::NORMAL),
            1 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::DECOMMISSION_INPROGRESS),
            2 => ::std::option::Option::Some(DatanodeInfoProto_AdminState::DECOMMISSIONED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeInfoProto_AdminState] = &[
            DatanodeInfoProto_AdminState::NORMAL,
            DatanodeInfoProto_AdminState::DECOMMISSION_INPROGRESS,
            DatanodeInfoProto_AdminState::DECOMMISSIONED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeInfoProto_AdminState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeInfoProto_AdminState {
}

impl ::std::default::Default for DatanodeInfoProto_AdminState {
    fn default() -> Self {
        DatanodeInfoProto_AdminState::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeInfoProto_AdminState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatanodeStorageProto {
    // message fields
    storageUuid: ::protobuf::SingularField<::std::string::String>,
    state: ::std::option::Option<DatanodeStorageProto_StorageState>,
    storageType: ::std::option::Option<StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatanodeStorageProto {
    fn default() -> &'a DatanodeStorageProto {
        <DatanodeStorageProto as ::protobuf::Message>::default_instance()
    }
}

impl DatanodeStorageProto {
    pub fn new() -> DatanodeStorageProto {
        ::std::default::Default::default()
    }

    // required string storageUuid = 1;


    pub fn get_storageUuid(&self) -> &str {
        match self.storageUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageUuid(&mut self) {
        self.storageUuid.clear();
    }

    pub fn has_storageUuid(&self) -> bool {
        self.storageUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageUuid(&mut self, v: ::std::string::String) {
        self.storageUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageUuid(&mut self) -> &mut ::std::string::String {
        if self.storageUuid.is_none() {
            self.storageUuid.set_default();
        }
        self.storageUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageUuid(&mut self) -> ::std::string::String {
        self.storageUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hadoop.hdfs.DatanodeStorageProto.StorageState state = 2;


    pub fn get_state(&self) -> DatanodeStorageProto_StorageState {
        self.state.unwrap_or(DatanodeStorageProto_StorageState::NORMAL)
    }
    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: DatanodeStorageProto_StorageState) {
        self.state = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeProto storageType = 3;


    pub fn get_storageType(&self) -> StorageTypeProto {
        self.storageType.unwrap_or(StorageTypeProto::DISK)
    }
    pub fn clear_storageType(&mut self) {
        self.storageType = ::std::option::Option::None;
    }

    pub fn has_storageType(&self) -> bool {
        self.storageType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageType(&mut self, v: StorageTypeProto) {
        self.storageType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DatanodeStorageProto {
    fn is_initialized(&self) -> bool {
        if self.storageUuid.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageUuid)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.storageType, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.state {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.storageType {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(2, v.value())?;
        }
        if let Some(v) = self.storageType {
            os.write_enum(3, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatanodeStorageProto {
        DatanodeStorageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageUuid",
                    |m: &DatanodeStorageProto| { &m.storageUuid },
                    |m: &mut DatanodeStorageProto| { &mut m.storageUuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatanodeStorageProto_StorageState>>(
                    "state",
                    |m: &DatanodeStorageProto| { &m.state },
                    |m: &mut DatanodeStorageProto| { &mut m.state },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                    "storageType",
                    |m: &DatanodeStorageProto| { &m.storageType },
                    |m: &mut DatanodeStorageProto| { &mut m.storageType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DatanodeStorageProto>(
                    "DatanodeStorageProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DatanodeStorageProto {
        static mut instance: ::protobuf::lazy::Lazy<DatanodeStorageProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DatanodeStorageProto,
        };
        unsafe {
            instance.get(DatanodeStorageProto::new)
        }
    }
}

impl ::protobuf::Clear for DatanodeStorageProto {
    fn clear(&mut self) {
        self.storageUuid.clear();
        self.state = ::std::option::Option::None;
        self.storageType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatanodeStorageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatanodeStorageProto_StorageState {
    NORMAL = 0,
    READ_ONLY_SHARED = 1,
}

impl ::protobuf::ProtobufEnum for DatanodeStorageProto_StorageState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatanodeStorageProto_StorageState> {
        match value {
            0 => ::std::option::Option::Some(DatanodeStorageProto_StorageState::NORMAL),
            1 => ::std::option::Option::Some(DatanodeStorageProto_StorageState::READ_ONLY_SHARED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatanodeStorageProto_StorageState] = &[
            DatanodeStorageProto_StorageState::NORMAL,
            DatanodeStorageProto_StorageState::READ_ONLY_SHARED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DatanodeStorageProto_StorageState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DatanodeStorageProto_StorageState {
}

impl ::std::default::Default for DatanodeStorageProto_StorageState {
    fn default() -> Self {
        DatanodeStorageProto_StorageState::NORMAL
    }
}

impl ::protobuf::reflect::ProtobufValue for DatanodeStorageProto_StorageState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageReportProto {
    // message fields
    storageUuid: ::protobuf::SingularField<::std::string::String>,
    failed: ::std::option::Option<bool>,
    capacity: ::std::option::Option<u64>,
    dfsUsed: ::std::option::Option<u64>,
    remaining: ::std::option::Option<u64>,
    blockPoolUsed: ::std::option::Option<u64>,
    storage: ::protobuf::SingularPtrField<DatanodeStorageProto>,
    nonDfsUsed: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageReportProto {
    fn default() -> &'a StorageReportProto {
        <StorageReportProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageReportProto {
    pub fn new() -> StorageReportProto {
        ::std::default::Default::default()
    }

    // required string storageUuid = 1;


    pub fn get_storageUuid(&self) -> &str {
        match self.storageUuid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageUuid(&mut self) {
        self.storageUuid.clear();
    }

    pub fn has_storageUuid(&self) -> bool {
        self.storageUuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageUuid(&mut self, v: ::std::string::String) {
        self.storageUuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageUuid(&mut self) -> &mut ::std::string::String {
        if self.storageUuid.is_none() {
            self.storageUuid.set_default();
        }
        self.storageUuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageUuid(&mut self) -> ::std::string::String {
        self.storageUuid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool failed = 2;


    pub fn get_failed(&self) -> bool {
        self.failed.unwrap_or(false)
    }
    pub fn clear_failed(&mut self) {
        self.failed = ::std::option::Option::None;
    }

    pub fn has_failed(&self) -> bool {
        self.failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed(&mut self, v: bool) {
        self.failed = ::std::option::Option::Some(v);
    }

    // optional uint64 capacity = 3;


    pub fn get_capacity(&self) -> u64 {
        self.capacity.unwrap_or(0u64)
    }
    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    // optional uint64 dfsUsed = 4;


    pub fn get_dfsUsed(&self) -> u64 {
        self.dfsUsed.unwrap_or(0u64)
    }
    pub fn clear_dfsUsed(&mut self) {
        self.dfsUsed = ::std::option::Option::None;
    }

    pub fn has_dfsUsed(&self) -> bool {
        self.dfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dfsUsed(&mut self, v: u64) {
        self.dfsUsed = ::std::option::Option::Some(v);
    }

    // optional uint64 remaining = 5;


    pub fn get_remaining(&self) -> u64 {
        self.remaining.unwrap_or(0u64)
    }
    pub fn clear_remaining(&mut self) {
        self.remaining = ::std::option::Option::None;
    }

    pub fn has_remaining(&self) -> bool {
        self.remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining(&mut self, v: u64) {
        self.remaining = ::std::option::Option::Some(v);
    }

    // optional uint64 blockPoolUsed = 6;


    pub fn get_blockPoolUsed(&self) -> u64 {
        self.blockPoolUsed.unwrap_or(0u64)
    }
    pub fn clear_blockPoolUsed(&mut self) {
        self.blockPoolUsed = ::std::option::Option::None;
    }

    pub fn has_blockPoolUsed(&self) -> bool {
        self.blockPoolUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolUsed(&mut self, v: u64) {
        self.blockPoolUsed = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.DatanodeStorageProto storage = 7;


    pub fn get_storage(&self) -> &DatanodeStorageProto {
        self.storage.as_ref().unwrap_or_else(|| DatanodeStorageProto::default_instance())
    }
    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    pub fn has_storage(&self) -> bool {
        self.storage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: DatanodeStorageProto) {
        self.storage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut DatanodeStorageProto {
        if self.storage.is_none() {
            self.storage.set_default();
        }
        self.storage.as_mut().unwrap()
    }

    // Take field
    pub fn take_storage(&mut self) -> DatanodeStorageProto {
        self.storage.take().unwrap_or_else(|| DatanodeStorageProto::new())
    }

    // optional uint64 nonDfsUsed = 8;


    pub fn get_nonDfsUsed(&self) -> u64 {
        self.nonDfsUsed.unwrap_or(0)
    }
    pub fn clear_nonDfsUsed(&mut self) {
        self.nonDfsUsed = ::std::option::Option::None;
    }

    pub fn has_nonDfsUsed(&self) -> bool {
        self.nonDfsUsed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonDfsUsed(&mut self, v: u64) {
        self.nonDfsUsed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StorageReportProto {
    fn is_initialized(&self) -> bool {
        if self.storageUuid.is_none() {
            return false;
        }
        for v in &self.storage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageUuid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failed = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.dfsUsed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.remaining = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockPoolUsed = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storage)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nonDfsUsed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.storageUuid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.failed {
            my_size += 2;
        }
        if let Some(v) = self.capacity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dfsUsed {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.remaining {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blockPoolUsed {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.storage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nonDfsUsed {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.storageUuid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.failed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.capacity {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.dfsUsed {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.remaining {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.blockPoolUsed {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.storage.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nonDfsUsed {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageReportProto {
        StorageReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageUuid",
                    |m: &StorageReportProto| { &m.storageUuid },
                    |m: &mut StorageReportProto| { &mut m.storageUuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "failed",
                    |m: &StorageReportProto| { &m.failed },
                    |m: &mut StorageReportProto| { &mut m.failed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capacity",
                    |m: &StorageReportProto| { &m.capacity },
                    |m: &mut StorageReportProto| { &mut m.capacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "dfsUsed",
                    |m: &StorageReportProto| { &m.dfsUsed },
                    |m: &mut StorageReportProto| { &mut m.dfsUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "remaining",
                    |m: &StorageReportProto| { &m.remaining },
                    |m: &mut StorageReportProto| { &mut m.remaining },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockPoolUsed",
                    |m: &StorageReportProto| { &m.blockPoolUsed },
                    |m: &mut StorageReportProto| { &mut m.blockPoolUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeStorageProto>>(
                    "storage",
                    |m: &StorageReportProto| { &m.storage },
                    |m: &mut StorageReportProto| { &mut m.storage },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nonDfsUsed",
                    |m: &StorageReportProto| { &m.nonDfsUsed },
                    |m: &mut StorageReportProto| { &mut m.nonDfsUsed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageReportProto>(
                    "StorageReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageReportProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageReportProto,
        };
        unsafe {
            instance.get(StorageReportProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageReportProto {
    fn clear(&mut self) {
        self.storageUuid.clear();
        self.failed = ::std::option::Option::None;
        self.capacity = ::std::option::Option::None;
        self.dfsUsed = ::std::option::Option::None;
        self.remaining = ::std::option::Option::None;
        self.blockPoolUsed = ::std::option::Option::None;
        self.storage.clear();
        self.nonDfsUsed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContentSummaryProto {
    // message fields
    length: ::std::option::Option<u64>,
    fileCount: ::std::option::Option<u64>,
    directoryCount: ::std::option::Option<u64>,
    quota: ::std::option::Option<u64>,
    spaceConsumed: ::std::option::Option<u64>,
    spaceQuota: ::std::option::Option<u64>,
    typeQuotaInfos: ::protobuf::SingularPtrField<StorageTypeQuotaInfosProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContentSummaryProto {
    fn default() -> &'a ContentSummaryProto {
        <ContentSummaryProto as ::protobuf::Message>::default_instance()
    }
}

impl ContentSummaryProto {
    pub fn new() -> ContentSummaryProto {
        ::std::default::Default::default()
    }

    // required uint64 length = 1;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required uint64 fileCount = 2;


    pub fn get_fileCount(&self) -> u64 {
        self.fileCount.unwrap_or(0)
    }
    pub fn clear_fileCount(&mut self) {
        self.fileCount = ::std::option::Option::None;
    }

    pub fn has_fileCount(&self) -> bool {
        self.fileCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileCount(&mut self, v: u64) {
        self.fileCount = ::std::option::Option::Some(v);
    }

    // required uint64 directoryCount = 3;


    pub fn get_directoryCount(&self) -> u64 {
        self.directoryCount.unwrap_or(0)
    }
    pub fn clear_directoryCount(&mut self) {
        self.directoryCount = ::std::option::Option::None;
    }

    pub fn has_directoryCount(&self) -> bool {
        self.directoryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directoryCount(&mut self, v: u64) {
        self.directoryCount = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 4;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 spaceConsumed = 5;


    pub fn get_spaceConsumed(&self) -> u64 {
        self.spaceConsumed.unwrap_or(0)
    }
    pub fn clear_spaceConsumed(&mut self) {
        self.spaceConsumed = ::std::option::Option::None;
    }

    pub fn has_spaceConsumed(&self) -> bool {
        self.spaceConsumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceConsumed(&mut self, v: u64) {
        self.spaceConsumed = ::std::option::Option::Some(v);
    }

    // required uint64 spaceQuota = 6;


    pub fn get_spaceQuota(&self) -> u64 {
        self.spaceQuota.unwrap_or(0)
    }
    pub fn clear_spaceQuota(&mut self) {
        self.spaceQuota = ::std::option::Option::None;
    }

    pub fn has_spaceQuota(&self) -> bool {
        self.spaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceQuota(&mut self, v: u64) {
        self.spaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeQuotaInfosProto typeQuotaInfos = 7;


    pub fn get_typeQuotaInfos(&self) -> &StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.as_ref().unwrap_or_else(|| StorageTypeQuotaInfosProto::default_instance())
    }
    pub fn clear_typeQuotaInfos(&mut self) {
        self.typeQuotaInfos.clear();
    }

    pub fn has_typeQuotaInfos(&self) -> bool {
        self.typeQuotaInfos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfos(&mut self, v: StorageTypeQuotaInfosProto) {
        self.typeQuotaInfos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeQuotaInfos(&mut self) -> &mut StorageTypeQuotaInfosProto {
        if self.typeQuotaInfos.is_none() {
            self.typeQuotaInfos.set_default();
        }
        self.typeQuotaInfos.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeQuotaInfos(&mut self) -> StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.take().unwrap_or_else(|| StorageTypeQuotaInfosProto::new())
    }
}

impl ::protobuf::Message for ContentSummaryProto {
    fn is_initialized(&self) -> bool {
        if self.length.is_none() {
            return false;
        }
        if self.fileCount.is_none() {
            return false;
        }
        if self.directoryCount.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        if self.spaceConsumed.is_none() {
            return false;
        }
        if self.spaceQuota.is_none() {
            return false;
        }
        for v in &self.typeQuotaInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileCount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.directoryCount = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceConsumed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceQuota = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeQuotaInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fileCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.directoryCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceConsumed {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceQuota {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.length {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.fileCount {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.directoryCount {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.spaceConsumed {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.spaceQuota {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContentSummaryProto {
        ContentSummaryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &ContentSummaryProto| { &m.length },
                    |m: &mut ContentSummaryProto| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileCount",
                    |m: &ContentSummaryProto| { &m.fileCount },
                    |m: &mut ContentSummaryProto| { &mut m.fileCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "directoryCount",
                    |m: &ContentSummaryProto| { &m.directoryCount },
                    |m: &mut ContentSummaryProto| { &mut m.directoryCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quota",
                    |m: &ContentSummaryProto| { &m.quota },
                    |m: &mut ContentSummaryProto| { &mut m.quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "spaceConsumed",
                    |m: &ContentSummaryProto| { &m.spaceConsumed },
                    |m: &mut ContentSummaryProto| { &mut m.spaceConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "spaceQuota",
                    |m: &ContentSummaryProto| { &m.spaceQuota },
                    |m: &mut ContentSummaryProto| { &mut m.spaceQuota },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfosProto>>(
                    "typeQuotaInfos",
                    |m: &ContentSummaryProto| { &m.typeQuotaInfos },
                    |m: &mut ContentSummaryProto| { &mut m.typeQuotaInfos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContentSummaryProto>(
                    "ContentSummaryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContentSummaryProto {
        static mut instance: ::protobuf::lazy::Lazy<ContentSummaryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContentSummaryProto,
        };
        unsafe {
            instance.get(ContentSummaryProto::new)
        }
    }
}

impl ::protobuf::Clear for ContentSummaryProto {
    fn clear(&mut self) {
        self.length = ::std::option::Option::None;
        self.fileCount = ::std::option::Option::None;
        self.directoryCount = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.spaceConsumed = ::std::option::Option::None;
        self.spaceQuota = ::std::option::Option::None;
        self.typeQuotaInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContentSummaryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContentSummaryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuotaUsageProto {
    // message fields
    fileAndDirectoryCount: ::std::option::Option<u64>,
    quota: ::std::option::Option<u64>,
    spaceConsumed: ::std::option::Option<u64>,
    spaceQuota: ::std::option::Option<u64>,
    typeQuotaInfos: ::protobuf::SingularPtrField<StorageTypeQuotaInfosProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuotaUsageProto {
    fn default() -> &'a QuotaUsageProto {
        <QuotaUsageProto as ::protobuf::Message>::default_instance()
    }
}

impl QuotaUsageProto {
    pub fn new() -> QuotaUsageProto {
        ::std::default::Default::default()
    }

    // required uint64 fileAndDirectoryCount = 1;


    pub fn get_fileAndDirectoryCount(&self) -> u64 {
        self.fileAndDirectoryCount.unwrap_or(0)
    }
    pub fn clear_fileAndDirectoryCount(&mut self) {
        self.fileAndDirectoryCount = ::std::option::Option::None;
    }

    pub fn has_fileAndDirectoryCount(&self) -> bool {
        self.fileAndDirectoryCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileAndDirectoryCount(&mut self, v: u64) {
        self.fileAndDirectoryCount = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 2;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 spaceConsumed = 3;


    pub fn get_spaceConsumed(&self) -> u64 {
        self.spaceConsumed.unwrap_or(0)
    }
    pub fn clear_spaceConsumed(&mut self) {
        self.spaceConsumed = ::std::option::Option::None;
    }

    pub fn has_spaceConsumed(&self) -> bool {
        self.spaceConsumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceConsumed(&mut self, v: u64) {
        self.spaceConsumed = ::std::option::Option::Some(v);
    }

    // required uint64 spaceQuota = 4;


    pub fn get_spaceQuota(&self) -> u64 {
        self.spaceQuota.unwrap_or(0)
    }
    pub fn clear_spaceQuota(&mut self) {
        self.spaceQuota = ::std::option::Option::None;
    }

    pub fn has_spaceQuota(&self) -> bool {
        self.spaceQuota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spaceQuota(&mut self, v: u64) {
        self.spaceQuota = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.StorageTypeQuotaInfosProto typeQuotaInfos = 5;


    pub fn get_typeQuotaInfos(&self) -> &StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.as_ref().unwrap_or_else(|| StorageTypeQuotaInfosProto::default_instance())
    }
    pub fn clear_typeQuotaInfos(&mut self) {
        self.typeQuotaInfos.clear();
    }

    pub fn has_typeQuotaInfos(&self) -> bool {
        self.typeQuotaInfos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfos(&mut self, v: StorageTypeQuotaInfosProto) {
        self.typeQuotaInfos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typeQuotaInfos(&mut self) -> &mut StorageTypeQuotaInfosProto {
        if self.typeQuotaInfos.is_none() {
            self.typeQuotaInfos.set_default();
        }
        self.typeQuotaInfos.as_mut().unwrap()
    }

    // Take field
    pub fn take_typeQuotaInfos(&mut self) -> StorageTypeQuotaInfosProto {
        self.typeQuotaInfos.take().unwrap_or_else(|| StorageTypeQuotaInfosProto::new())
    }
}

impl ::protobuf::Message for QuotaUsageProto {
    fn is_initialized(&self) -> bool {
        if self.fileAndDirectoryCount.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        if self.spaceConsumed.is_none() {
            return false;
        }
        if self.spaceQuota.is_none() {
            return false;
        }
        for v in &self.typeQuotaInfos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileAndDirectoryCount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceConsumed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.spaceQuota = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.typeQuotaInfos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileAndDirectoryCount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceConsumed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spaceQuota {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileAndDirectoryCount {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.spaceConsumed {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.spaceQuota {
            os.write_uint64(4, v)?;
        }
        if let Some(ref v) = self.typeQuotaInfos.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuotaUsageProto {
        QuotaUsageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileAndDirectoryCount",
                    |m: &QuotaUsageProto| { &m.fileAndDirectoryCount },
                    |m: &mut QuotaUsageProto| { &mut m.fileAndDirectoryCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quota",
                    |m: &QuotaUsageProto| { &m.quota },
                    |m: &mut QuotaUsageProto| { &mut m.quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "spaceConsumed",
                    |m: &QuotaUsageProto| { &m.spaceConsumed },
                    |m: &mut QuotaUsageProto| { &mut m.spaceConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "spaceQuota",
                    |m: &QuotaUsageProto| { &m.spaceQuota },
                    |m: &mut QuotaUsageProto| { &mut m.spaceQuota },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfosProto>>(
                    "typeQuotaInfos",
                    |m: &QuotaUsageProto| { &m.typeQuotaInfos },
                    |m: &mut QuotaUsageProto| { &mut m.typeQuotaInfos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuotaUsageProto>(
                    "QuotaUsageProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QuotaUsageProto {
        static mut instance: ::protobuf::lazy::Lazy<QuotaUsageProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuotaUsageProto,
        };
        unsafe {
            instance.get(QuotaUsageProto::new)
        }
    }
}

impl ::protobuf::Clear for QuotaUsageProto {
    fn clear(&mut self) {
        self.fileAndDirectoryCount = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.spaceConsumed = ::std::option::Option::None;
        self.spaceQuota = ::std::option::Option::None;
        self.typeQuotaInfos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuotaUsageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuotaUsageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypeQuotaInfosProto {
    // message fields
    typeQuotaInfo: ::protobuf::RepeatedField<StorageTypeQuotaInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypeQuotaInfosProto {
    fn default() -> &'a StorageTypeQuotaInfosProto {
        <StorageTypeQuotaInfosProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypeQuotaInfosProto {
    pub fn new() -> StorageTypeQuotaInfosProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.StorageTypeQuotaInfoProto typeQuotaInfo = 1;


    pub fn get_typeQuotaInfo(&self) -> &[StorageTypeQuotaInfoProto] {
        &self.typeQuotaInfo
    }
    pub fn clear_typeQuotaInfo(&mut self) {
        self.typeQuotaInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_typeQuotaInfo(&mut self, v: ::protobuf::RepeatedField<StorageTypeQuotaInfoProto>) {
        self.typeQuotaInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typeQuotaInfo(&mut self) -> &mut ::protobuf::RepeatedField<StorageTypeQuotaInfoProto> {
        &mut self.typeQuotaInfo
    }

    // Take field
    pub fn take_typeQuotaInfo(&mut self) -> ::protobuf::RepeatedField<StorageTypeQuotaInfoProto> {
        ::std::mem::replace(&mut self.typeQuotaInfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageTypeQuotaInfosProto {
    fn is_initialized(&self) -> bool {
        for v in &self.typeQuotaInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.typeQuotaInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.typeQuotaInfo {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.typeQuotaInfo {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypeQuotaInfosProto {
        StorageTypeQuotaInfosProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypeQuotaInfoProto>>(
                    "typeQuotaInfo",
                    |m: &StorageTypeQuotaInfosProto| { &m.typeQuotaInfo },
                    |m: &mut StorageTypeQuotaInfosProto| { &mut m.typeQuotaInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageTypeQuotaInfosProto>(
                    "StorageTypeQuotaInfosProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageTypeQuotaInfosProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageTypeQuotaInfosProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageTypeQuotaInfosProto,
        };
        unsafe {
            instance.get(StorageTypeQuotaInfosProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageTypeQuotaInfosProto {
    fn clear(&mut self) {
        self.typeQuotaInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypeQuotaInfosProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeQuotaInfosProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypeQuotaInfoProto {
    // message fields
    field_type: ::std::option::Option<StorageTypeProto>,
    quota: ::std::option::Option<u64>,
    consumed: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypeQuotaInfoProto {
    fn default() -> &'a StorageTypeQuotaInfoProto {
        <StorageTypeQuotaInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypeQuotaInfoProto {
    pub fn new() -> StorageTypeQuotaInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.StorageTypeProto type = 1;


    pub fn get_field_type(&self) -> StorageTypeProto {
        self.field_type.unwrap_or(StorageTypeProto::DISK)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: StorageTypeProto) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required uint64 quota = 2;


    pub fn get_quota(&self) -> u64 {
        self.quota.unwrap_or(0)
    }
    pub fn clear_quota(&mut self) {
        self.quota = ::std::option::Option::None;
    }

    pub fn has_quota(&self) -> bool {
        self.quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quota(&mut self, v: u64) {
        self.quota = ::std::option::Option::Some(v);
    }

    // required uint64 consumed = 3;


    pub fn get_consumed(&self) -> u64 {
        self.consumed.unwrap_or(0)
    }
    pub fn clear_consumed(&mut self) {
        self.consumed = ::std::option::Option::None;
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: u64) {
        self.consumed = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StorageTypeQuotaInfoProto {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.quota.is_none() {
            return false;
        }
        if self.consumed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.consumed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.consumed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.quota {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.consumed {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypeQuotaInfoProto {
        StorageTypeQuotaInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                    "type",
                    |m: &StorageTypeQuotaInfoProto| { &m.field_type },
                    |m: &mut StorageTypeQuotaInfoProto| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quota",
                    |m: &StorageTypeQuotaInfoProto| { &m.quota },
                    |m: &mut StorageTypeQuotaInfoProto| { &mut m.quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "consumed",
                    |m: &StorageTypeQuotaInfoProto| { &m.consumed },
                    |m: &mut StorageTypeQuotaInfoProto| { &mut m.consumed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageTypeQuotaInfoProto>(
                    "StorageTypeQuotaInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageTypeQuotaInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageTypeQuotaInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageTypeQuotaInfoProto,
        };
        unsafe {
            instance.get(StorageTypeQuotaInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageTypeQuotaInfoProto {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.quota = ::std::option::Option::None;
        self.consumed = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypeQuotaInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeQuotaInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CorruptFileBlocksProto {
    // message fields
    files: ::protobuf::RepeatedField<::std::string::String>,
    cookie: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorruptFileBlocksProto {
    fn default() -> &'a CorruptFileBlocksProto {
        <CorruptFileBlocksProto as ::protobuf::Message>::default_instance()
    }
}

impl CorruptFileBlocksProto {
    pub fn new() -> CorruptFileBlocksProto {
        ::std::default::Default::default()
    }

    // repeated string files = 1;


    pub fn get_files(&self) -> &[::std::string::String] {
        &self.files
    }
    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    // required string cookie = 2;


    pub fn get_cookie(&self) -> &str {
        match self.cookie.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cookie(&mut self) {
        self.cookie.clear();
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: ::std::string::String) {
        self.cookie = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cookie(&mut self) -> &mut ::std::string::String {
        if self.cookie.is_none() {
            self.cookie.set_default();
        }
        self.cookie.as_mut().unwrap()
    }

    // Take field
    pub fn take_cookie(&mut self) -> ::std::string::String {
        self.cookie.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CorruptFileBlocksProto {
    fn is_initialized(&self) -> bool {
        if self.cookie.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.files)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cookie)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.files {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.cookie.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.files {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.cookie.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorruptFileBlocksProto {
        CorruptFileBlocksProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "files",
                    |m: &CorruptFileBlocksProto| { &m.files },
                    |m: &mut CorruptFileBlocksProto| { &mut m.files },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cookie",
                    |m: &CorruptFileBlocksProto| { &m.cookie },
                    |m: &mut CorruptFileBlocksProto| { &mut m.cookie },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CorruptFileBlocksProto>(
                    "CorruptFileBlocksProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CorruptFileBlocksProto {
        static mut instance: ::protobuf::lazy::Lazy<CorruptFileBlocksProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CorruptFileBlocksProto,
        };
        unsafe {
            instance.get(CorruptFileBlocksProto::new)
        }
    }
}

impl ::protobuf::Clear for CorruptFileBlocksProto {
    fn clear(&mut self) {
        self.files.clear();
        self.cookie.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorruptFileBlocksProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorruptFileBlocksProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsPermissionProto {
    // message fields
    perm: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsPermissionProto {
    fn default() -> &'a FsPermissionProto {
        <FsPermissionProto as ::protobuf::Message>::default_instance()
    }
}

impl FsPermissionProto {
    pub fn new() -> FsPermissionProto {
        ::std::default::Default::default()
    }

    // required uint32 perm = 1;


    pub fn get_perm(&self) -> u32 {
        self.perm.unwrap_or(0)
    }
    pub fn clear_perm(&mut self) {
        self.perm = ::std::option::Option::None;
    }

    pub fn has_perm(&self) -> bool {
        self.perm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: u32) {
        self.perm = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FsPermissionProto {
    fn is_initialized(&self) -> bool {
        if self.perm.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.perm = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.perm {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.perm {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsPermissionProto {
        FsPermissionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "perm",
                    |m: &FsPermissionProto| { &m.perm },
                    |m: &mut FsPermissionProto| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsPermissionProto>(
                    "FsPermissionProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FsPermissionProto {
        static mut instance: ::protobuf::lazy::Lazy<FsPermissionProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsPermissionProto,
        };
        unsafe {
            instance.get(FsPermissionProto::new)
        }
    }
}

impl ::protobuf::Clear for FsPermissionProto {
    fn clear(&mut self) {
        self.perm = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsPermissionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsPermissionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageTypesProto {
    // message fields
    storageTypes: ::std::vec::Vec<StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageTypesProto {
    fn default() -> &'a StorageTypesProto {
        <StorageTypesProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageTypesProto {
    pub fn new() -> StorageTypesProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 1;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StorageTypesProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.storageTypes {
            os.write_enum(1, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageTypesProto {
        StorageTypesProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                    "storageTypes",
                    |m: &StorageTypesProto| { &m.storageTypes },
                    |m: &mut StorageTypesProto| { &mut m.storageTypes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageTypesProto>(
                    "StorageTypesProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageTypesProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageTypesProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageTypesProto,
        };
        unsafe {
            instance.get(StorageTypesProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageTypesProto {
    fn clear(&mut self) {
        self.storageTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageTypesProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypesProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockStoragePolicyProto {
    // message fields
    policyId: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    creationPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    creationFallbackPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    replicationFallbackPolicy: ::protobuf::SingularPtrField<StorageTypesProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockStoragePolicyProto {
    fn default() -> &'a BlockStoragePolicyProto {
        <BlockStoragePolicyProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockStoragePolicyProto {
    pub fn new() -> BlockStoragePolicyProto {
        ::std::default::Default::default()
    }

    // required uint32 policyId = 1;


    pub fn get_policyId(&self) -> u32 {
        self.policyId.unwrap_or(0)
    }
    pub fn clear_policyId(&mut self) {
        self.policyId = ::std::option::Option::None;
    }

    pub fn has_policyId(&self) -> bool {
        self.policyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_policyId(&mut self, v: u32) {
        self.policyId = ::std::option::Option::Some(v);
    }

    // required string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.StorageTypesProto creationPolicy = 3;


    pub fn get_creationPolicy(&self) -> &StorageTypesProto {
        self.creationPolicy.as_ref().unwrap_or_else(|| StorageTypesProto::default_instance())
    }
    pub fn clear_creationPolicy(&mut self) {
        self.creationPolicy.clear();
    }

    pub fn has_creationPolicy(&self) -> bool {
        self.creationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationPolicy(&mut self, v: StorageTypesProto) {
        self.creationPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationPolicy(&mut self) -> &mut StorageTypesProto {
        if self.creationPolicy.is_none() {
            self.creationPolicy.set_default();
        }
        self.creationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationPolicy(&mut self) -> StorageTypesProto {
        self.creationPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }

    // optional .hadoop.hdfs.StorageTypesProto creationFallbackPolicy = 4;


    pub fn get_creationFallbackPolicy(&self) -> &StorageTypesProto {
        self.creationFallbackPolicy.as_ref().unwrap_or_else(|| StorageTypesProto::default_instance())
    }
    pub fn clear_creationFallbackPolicy(&mut self) {
        self.creationFallbackPolicy.clear();
    }

    pub fn has_creationFallbackPolicy(&self) -> bool {
        self.creationFallbackPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationFallbackPolicy(&mut self, v: StorageTypesProto) {
        self.creationFallbackPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationFallbackPolicy(&mut self) -> &mut StorageTypesProto {
        if self.creationFallbackPolicy.is_none() {
            self.creationFallbackPolicy.set_default();
        }
        self.creationFallbackPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationFallbackPolicy(&mut self) -> StorageTypesProto {
        self.creationFallbackPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }

    // optional .hadoop.hdfs.StorageTypesProto replicationFallbackPolicy = 5;


    pub fn get_replicationFallbackPolicy(&self) -> &StorageTypesProto {
        self.replicationFallbackPolicy.as_ref().unwrap_or_else(|| StorageTypesProto::default_instance())
    }
    pub fn clear_replicationFallbackPolicy(&mut self) {
        self.replicationFallbackPolicy.clear();
    }

    pub fn has_replicationFallbackPolicy(&self) -> bool {
        self.replicationFallbackPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicationFallbackPolicy(&mut self, v: StorageTypesProto) {
        self.replicationFallbackPolicy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replicationFallbackPolicy(&mut self) -> &mut StorageTypesProto {
        if self.replicationFallbackPolicy.is_none() {
            self.replicationFallbackPolicy.set_default();
        }
        self.replicationFallbackPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_replicationFallbackPolicy(&mut self) -> StorageTypesProto {
        self.replicationFallbackPolicy.take().unwrap_or_else(|| StorageTypesProto::new())
    }
}

impl ::protobuf::Message for BlockStoragePolicyProto {
    fn is_initialized(&self) -> bool {
        if self.policyId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.creationPolicy.is_none() {
            return false;
        }
        for v in &self.creationPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.creationFallbackPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replicationFallbackPolicy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.policyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationPolicy)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationFallbackPolicy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.replicationFallbackPolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.policyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.creationPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.creationFallbackPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.replicationFallbackPolicy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.policyId {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.creationPolicy.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.creationFallbackPolicy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.replicationFallbackPolicy.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockStoragePolicyProto {
        BlockStoragePolicyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "policyId",
                    |m: &BlockStoragePolicyProto| { &m.policyId },
                    |m: &mut BlockStoragePolicyProto| { &mut m.policyId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &BlockStoragePolicyProto| { &m.name },
                    |m: &mut BlockStoragePolicyProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                    "creationPolicy",
                    |m: &BlockStoragePolicyProto| { &m.creationPolicy },
                    |m: &mut BlockStoragePolicyProto| { &mut m.creationPolicy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                    "creationFallbackPolicy",
                    |m: &BlockStoragePolicyProto| { &m.creationFallbackPolicy },
                    |m: &mut BlockStoragePolicyProto| { &mut m.creationFallbackPolicy },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageTypesProto>>(
                    "replicationFallbackPolicy",
                    |m: &BlockStoragePolicyProto| { &m.replicationFallbackPolicy },
                    |m: &mut BlockStoragePolicyProto| { &mut m.replicationFallbackPolicy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockStoragePolicyProto>(
                    "BlockStoragePolicyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockStoragePolicyProto {
        static mut instance: ::protobuf::lazy::Lazy<BlockStoragePolicyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockStoragePolicyProto,
        };
        unsafe {
            instance.get(BlockStoragePolicyProto::new)
        }
    }
}

impl ::protobuf::Clear for BlockStoragePolicyProto {
    fn clear(&mut self) {
        self.policyId = ::std::option::Option::None;
        self.name.clear();
        self.creationPolicy.clear();
        self.creationFallbackPolicy.clear();
        self.replicationFallbackPolicy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockStoragePolicyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockStoragePolicyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageUuidsProto {
    // message fields
    storageUuids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageUuidsProto {
    fn default() -> &'a StorageUuidsProto {
        <StorageUuidsProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageUuidsProto {
    pub fn new() -> StorageUuidsProto {
        ::std::default::Default::default()
    }

    // repeated string storageUuids = 1;


    pub fn get_storageUuids(&self) -> &[::std::string::String] {
        &self.storageUuids
    }
    pub fn clear_storageUuids(&mut self) {
        self.storageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageUuids
    }

    // Take field
    pub fn take_storageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageUuids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StorageUuidsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageUuids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.storageUuids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.storageUuids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageUuidsProto {
        StorageUuidsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageUuids",
                    |m: &StorageUuidsProto| { &m.storageUuids },
                    |m: &mut StorageUuidsProto| { &mut m.storageUuids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageUuidsProto>(
                    "StorageUuidsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageUuidsProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageUuidsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageUuidsProto,
        };
        unsafe {
            instance.get(StorageUuidsProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageUuidsProto {
    fn clear(&mut self) {
        self.storageUuids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageUuidsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageUuidsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocatedBlockProto {
    // message fields
    b: ::protobuf::SingularPtrField<ExtendedBlockProto>,
    offset: ::std::option::Option<u64>,
    locs: ::protobuf::RepeatedField<DatanodeInfoProto>,
    corrupt: ::std::option::Option<bool>,
    blockToken: ::protobuf::SingularPtrField<super::Security::TokenProto>,
    isCached: ::std::vec::Vec<bool>,
    storageTypes: ::std::vec::Vec<StorageTypeProto>,
    storageIDs: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocatedBlockProto {
    fn default() -> &'a LocatedBlockProto {
        <LocatedBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl LocatedBlockProto {
    pub fn new() -> LocatedBlockProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.ExtendedBlockProto b = 1;


    pub fn get_b(&self) -> &ExtendedBlockProto {
        self.b.as_ref().unwrap_or_else(|| ExtendedBlockProto::default_instance())
    }
    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: ExtendedBlockProto) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut ExtendedBlockProto {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> ExtendedBlockProto {
        self.b.take().unwrap_or_else(|| ExtendedBlockProto::new())
    }

    // required uint64 offset = 2;


    pub fn get_offset(&self) -> u64 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: u64) {
        self.offset = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;


    pub fn get_locs(&self) -> &[DatanodeInfoProto] {
        &self.locs
    }
    pub fn clear_locs(&mut self) {
        self.locs.clear();
    }

    // Param is passed by value, moved
    pub fn set_locs(&mut self, v: ::protobuf::RepeatedField<DatanodeInfoProto>) {
        self.locs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locs(&mut self) -> &mut ::protobuf::RepeatedField<DatanodeInfoProto> {
        &mut self.locs
    }

    // Take field
    pub fn take_locs(&mut self) -> ::protobuf::RepeatedField<DatanodeInfoProto> {
        ::std::mem::replace(&mut self.locs, ::protobuf::RepeatedField::new())
    }

    // required bool corrupt = 4;


    pub fn get_corrupt(&self) -> bool {
        self.corrupt.unwrap_or(false)
    }
    pub fn clear_corrupt(&mut self) {
        self.corrupt = ::std::option::Option::None;
    }

    pub fn has_corrupt(&self) -> bool {
        self.corrupt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_corrupt(&mut self, v: bool) {
        self.corrupt = ::std::option::Option::Some(v);
    }

    // required .hadoop.common.TokenProto blockToken = 5;


    pub fn get_blockToken(&self) -> &super::Security::TokenProto {
        self.blockToken.as_ref().unwrap_or_else(|| super::Security::TokenProto::default_instance())
    }
    pub fn clear_blockToken(&mut self) {
        self.blockToken.clear();
    }

    pub fn has_blockToken(&self) -> bool {
        self.blockToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockToken(&mut self, v: super::Security::TokenProto) {
        self.blockToken = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockToken(&mut self) -> &mut super::Security::TokenProto {
        if self.blockToken.is_none() {
            self.blockToken.set_default();
        }
        self.blockToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockToken(&mut self) -> super::Security::TokenProto {
        self.blockToken.take().unwrap_or_else(|| super::Security::TokenProto::new())
    }

    // repeated bool isCached = 6;


    pub fn get_isCached(&self) -> &[bool] {
        &self.isCached
    }
    pub fn clear_isCached(&mut self) {
        self.isCached.clear();
    }

    // Param is passed by value, moved
    pub fn set_isCached(&mut self, v: ::std::vec::Vec<bool>) {
        self.isCached = v;
    }

    // Mutable pointer to the field.
    pub fn mut_isCached(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.isCached
    }

    // Take field
    pub fn take_isCached(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.isCached, ::std::vec::Vec::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }

    // repeated string storageIDs = 8;


    pub fn get_storageIDs(&self) -> &[::std::string::String] {
        &self.storageIDs
    }
    pub fn clear_storageIDs(&mut self) {
        self.storageIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageIDs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageIDs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageIDs
    }

    // Take field
    pub fn take_storageIDs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageIDs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LocatedBlockProto {
    fn is_initialized(&self) -> bool {
        if self.b.is_none() {
            return false;
        }
        if self.offset.is_none() {
            return false;
        }
        if self.corrupt.is_none() {
            return false;
        }
        if self.blockToken.is_none() {
            return false;
        }
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.blockToken {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locs)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.corrupt = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blockToken)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.isCached)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageIDs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.locs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.corrupt {
            my_size += 2;
        }
        if let Some(ref v) = self.blockToken.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.isCached.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.isCached.len() * 1) as u32) + (self.isCached.len() * 1) as u32;
        }
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        for value in &self.storageIDs {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.offset {
            os.write_uint64(2, v)?;
        }
        for v in &self.locs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.corrupt {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.blockToken.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.isCached.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.isCached.len() * 1) as u32)?;
            for v in &self.isCached {
                os.write_bool_no_tag(*v)?;
            };
        }
        for v in &self.storageTypes {
            os.write_enum(7, v.value())?;
        };
        for v in &self.storageIDs {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocatedBlockProto {
        LocatedBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtendedBlockProto>>(
                    "b",
                    |m: &LocatedBlockProto| { &m.b },
                    |m: &mut LocatedBlockProto| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "offset",
                    |m: &LocatedBlockProto| { &m.offset },
                    |m: &mut LocatedBlockProto| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatanodeInfoProto>>(
                    "locs",
                    |m: &LocatedBlockProto| { &m.locs },
                    |m: &mut LocatedBlockProto| { &mut m.locs },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "corrupt",
                    |m: &LocatedBlockProto| { &m.corrupt },
                    |m: &mut LocatedBlockProto| { &mut m.corrupt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Security::TokenProto>>(
                    "blockToken",
                    |m: &LocatedBlockProto| { &m.blockToken },
                    |m: &mut LocatedBlockProto| { &mut m.blockToken },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isCached",
                    |m: &LocatedBlockProto| { &m.isCached },
                    |m: &mut LocatedBlockProto| { &mut m.isCached },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                    "storageTypes",
                    |m: &LocatedBlockProto| { &m.storageTypes },
                    |m: &mut LocatedBlockProto| { &mut m.storageTypes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageIDs",
                    |m: &LocatedBlockProto| { &m.storageIDs },
                    |m: &mut LocatedBlockProto| { &mut m.storageIDs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocatedBlockProto>(
                    "LocatedBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocatedBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<LocatedBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocatedBlockProto,
        };
        unsafe {
            instance.get(LocatedBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for LocatedBlockProto {
    fn clear(&mut self) {
        self.b.clear();
        self.offset = ::std::option::Option::None;
        self.locs.clear();
        self.corrupt = ::std::option::Option::None;
        self.blockToken.clear();
        self.isCached.clear();
        self.storageTypes.clear();
        self.storageIDs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocatedBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocatedBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataEncryptionKeyProto {
    // message fields
    keyId: ::std::option::Option<u32>,
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    encryptionKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    expiryDate: ::std::option::Option<u64>,
    encryptionAlgorithm: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DataEncryptionKeyProto {
    fn default() -> &'a DataEncryptionKeyProto {
        <DataEncryptionKeyProto as ::protobuf::Message>::default_instance()
    }
}

impl DataEncryptionKeyProto {
    pub fn new() -> DataEncryptionKeyProto {
        ::std::default::Default::default()
    }

    // required uint32 keyId = 1;


    pub fn get_keyId(&self) -> u32 {
        self.keyId.unwrap_or(0)
    }
    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: u32) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // required string blockPoolId = 2;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes nonce = 3;


    pub fn get_nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes encryptionKey = 4;


    pub fn get_encryptionKey(&self) -> &[u8] {
        match self.encryptionKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_encryptionKey(&mut self) {
        self.encryptionKey.clear();
    }

    pub fn has_encryptionKey(&self) -> bool {
        self.encryptionKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptionKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.encryptionKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptionKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.encryptionKey.is_none() {
            self.encryptionKey.set_default();
        }
        self.encryptionKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptionKey(&mut self) -> ::std::vec::Vec<u8> {
        self.encryptionKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 expiryDate = 5;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }

    // optional string encryptionAlgorithm = 6;


    pub fn get_encryptionAlgorithm(&self) -> &str {
        match self.encryptionAlgorithm.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_encryptionAlgorithm(&mut self) {
        self.encryptionAlgorithm.clear();
    }

    pub fn has_encryptionAlgorithm(&self) -> bool {
        self.encryptionAlgorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptionAlgorithm(&mut self, v: ::std::string::String) {
        self.encryptionAlgorithm = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encryptionAlgorithm(&mut self) -> &mut ::std::string::String {
        if self.encryptionAlgorithm.is_none() {
            self.encryptionAlgorithm.set_default();
        }
        self.encryptionAlgorithm.as_mut().unwrap()
    }

    // Take field
    pub fn take_encryptionAlgorithm(&mut self) -> ::std::string::String {
        self.encryptionAlgorithm.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DataEncryptionKeyProto {
    fn is_initialized(&self) -> bool {
        if self.keyId.is_none() {
            return false;
        }
        if self.blockPoolId.is_none() {
            return false;
        }
        if self.nonce.is_none() {
            return false;
        }
        if self.encryptionKey.is_none() {
            return false;
        }
        if self.expiryDate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.encryptionKey)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.encryptionAlgorithm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.keyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.encryptionAlgorithm.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.keyId {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.encryptionKey.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.expiryDate {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.encryptionAlgorithm.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataEncryptionKeyProto {
        DataEncryptionKeyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "keyId",
                    |m: &DataEncryptionKeyProto| { &m.keyId },
                    |m: &mut DataEncryptionKeyProto| { &mut m.keyId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockPoolId",
                    |m: &DataEncryptionKeyProto| { &m.blockPoolId },
                    |m: &mut DataEncryptionKeyProto| { &mut m.blockPoolId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &DataEncryptionKeyProto| { &m.nonce },
                    |m: &mut DataEncryptionKeyProto| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encryptionKey",
                    |m: &DataEncryptionKeyProto| { &m.encryptionKey },
                    |m: &mut DataEncryptionKeyProto| { &mut m.encryptionKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "expiryDate",
                    |m: &DataEncryptionKeyProto| { &m.expiryDate },
                    |m: &mut DataEncryptionKeyProto| { &mut m.expiryDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "encryptionAlgorithm",
                    |m: &DataEncryptionKeyProto| { &m.encryptionAlgorithm },
                    |m: &mut DataEncryptionKeyProto| { &mut m.encryptionAlgorithm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataEncryptionKeyProto>(
                    "DataEncryptionKeyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataEncryptionKeyProto {
        static mut instance: ::protobuf::lazy::Lazy<DataEncryptionKeyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataEncryptionKeyProto,
        };
        unsafe {
            instance.get(DataEncryptionKeyProto::new)
        }
    }
}

impl ::protobuf::Clear for DataEncryptionKeyProto {
    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.blockPoolId.clear();
        self.nonce.clear();
        self.encryptionKey.clear();
        self.expiryDate = ::std::option::Option::None;
        self.encryptionAlgorithm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataEncryptionKeyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataEncryptionKeyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileEncryptionInfoProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    cryptoProtocolVersion: ::std::option::Option<CryptoProtocolVersionProto>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FileEncryptionInfoProto {
    fn default() -> &'a FileEncryptionInfoProto {
        <FileEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl FileEncryptionInfoProto {
    pub fn new() -> FileEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 2;


    pub fn get_cryptoProtocolVersion(&self) -> CryptoProtocolVersionProto {
        self.cryptoProtocolVersion.unwrap_or(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION)
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_cryptoProtocolVersion(&self) -> bool {
        self.cryptoProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: CryptoProtocolVersionProto) {
        self.cryptoProtocolVersion = ::std::option::Option::Some(v);
    }

    // required bytes key = 3;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes iv = 4;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string keyName = 5;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string ezKeyVersionName = 6;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FileEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        if self.cryptoProtocolVersion.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        if self.iv.is_none() {
            return false;
        }
        if self.keyName.is_none() {
            return false;
        }
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.cryptoProtocolVersion {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileEncryptionInfoProto {
        FileEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                    "suite",
                    |m: &FileEncryptionInfoProto| { &m.suite },
                    |m: &mut FileEncryptionInfoProto| { &mut m.suite },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CryptoProtocolVersionProto>>(
                    "cryptoProtocolVersion",
                    |m: &FileEncryptionInfoProto| { &m.cryptoProtocolVersion },
                    |m: &mut FileEncryptionInfoProto| { &mut m.cryptoProtocolVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &FileEncryptionInfoProto| { &m.key },
                    |m: &mut FileEncryptionInfoProto| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iv",
                    |m: &FileEncryptionInfoProto| { &m.iv },
                    |m: &mut FileEncryptionInfoProto| { &mut m.iv },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyName",
                    |m: &FileEncryptionInfoProto| { &m.keyName },
                    |m: &mut FileEncryptionInfoProto| { &mut m.keyName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ezKeyVersionName",
                    |m: &FileEncryptionInfoProto| { &m.ezKeyVersionName },
                    |m: &mut FileEncryptionInfoProto| { &mut m.ezKeyVersionName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileEncryptionInfoProto>(
                    "FileEncryptionInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileEncryptionInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<FileEncryptionInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileEncryptionInfoProto,
        };
        unsafe {
            instance.get(FileEncryptionInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for FileEncryptionInfoProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.cryptoProtocolVersion = ::std::option::Option::None;
        self.key.clear();
        self.iv.clear();
        self.keyName.clear();
        self.ezKeyVersionName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PerFileEncryptionInfoProto {
    // message fields
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ezKeyVersionName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PerFileEncryptionInfoProto {
    fn default() -> &'a PerFileEncryptionInfoProto {
        <PerFileEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl PerFileEncryptionInfoProto {
    pub fn new() -> PerFileEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required bytes key = 1;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes iv = 2;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string ezKeyVersionName = 3;


    pub fn get_ezKeyVersionName(&self) -> &str {
        match self.ezKeyVersionName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ezKeyVersionName(&mut self) {
        self.ezKeyVersionName.clear();
    }

    pub fn has_ezKeyVersionName(&self) -> bool {
        self.ezKeyVersionName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ezKeyVersionName(&mut self, v: ::std::string::String) {
        self.ezKeyVersionName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ezKeyVersionName(&mut self) -> &mut ::std::string::String {
        if self.ezKeyVersionName.is_none() {
            self.ezKeyVersionName.set_default();
        }
        self.ezKeyVersionName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ezKeyVersionName(&mut self) -> ::std::string::String {
        self.ezKeyVersionName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PerFileEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.iv.is_none() {
            return false;
        }
        if self.ezKeyVersionName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ezKeyVersionName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.ezKeyVersionName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PerFileEncryptionInfoProto {
        PerFileEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &PerFileEncryptionInfoProto| { &m.key },
                    |m: &mut PerFileEncryptionInfoProto| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iv",
                    |m: &PerFileEncryptionInfoProto| { &m.iv },
                    |m: &mut PerFileEncryptionInfoProto| { &mut m.iv },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ezKeyVersionName",
                    |m: &PerFileEncryptionInfoProto| { &m.ezKeyVersionName },
                    |m: &mut PerFileEncryptionInfoProto| { &mut m.ezKeyVersionName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerFileEncryptionInfoProto>(
                    "PerFileEncryptionInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PerFileEncryptionInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<PerFileEncryptionInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerFileEncryptionInfoProto,
        };
        unsafe {
            instance.get(PerFileEncryptionInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for PerFileEncryptionInfoProto {
    fn clear(&mut self) {
        self.key.clear();
        self.iv.clear();
        self.ezKeyVersionName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PerFileEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerFileEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ZoneEncryptionInfoProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    cryptoProtocolVersion: ::std::option::Option<CryptoProtocolVersionProto>,
    keyName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ZoneEncryptionInfoProto {
    fn default() -> &'a ZoneEncryptionInfoProto {
        <ZoneEncryptionInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl ZoneEncryptionInfoProto {
    pub fn new() -> ZoneEncryptionInfoProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.CryptoProtocolVersionProto cryptoProtocolVersion = 2;


    pub fn get_cryptoProtocolVersion(&self) -> CryptoProtocolVersionProto {
        self.cryptoProtocolVersion.unwrap_or(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION)
    }
    pub fn clear_cryptoProtocolVersion(&mut self) {
        self.cryptoProtocolVersion = ::std::option::Option::None;
    }

    pub fn has_cryptoProtocolVersion(&self) -> bool {
        self.cryptoProtocolVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cryptoProtocolVersion(&mut self, v: CryptoProtocolVersionProto) {
        self.cryptoProtocolVersion = ::std::option::Option::Some(v);
    }

    // required string keyName = 3;


    pub fn get_keyName(&self) -> &str {
        match self.keyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyName(&mut self) {
        self.keyName.clear();
    }

    pub fn has_keyName(&self) -> bool {
        self.keyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyName(&mut self, v: ::std::string::String) {
        self.keyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyName(&mut self) -> &mut ::std::string::String {
        if self.keyName.is_none() {
            self.keyName.set_default();
        }
        self.keyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyName(&mut self) -> ::std::string::String {
        self.keyName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ZoneEncryptionInfoProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        if self.cryptoProtocolVersion.is_none() {
            return false;
        }
        if self.keyName.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.cryptoProtocolVersion, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(v) = self.cryptoProtocolVersion {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.keyName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, v.value())?;
        }
        if let Some(v) = self.cryptoProtocolVersion {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.keyName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ZoneEncryptionInfoProto {
        ZoneEncryptionInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                    "suite",
                    |m: &ZoneEncryptionInfoProto| { &m.suite },
                    |m: &mut ZoneEncryptionInfoProto| { &mut m.suite },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CryptoProtocolVersionProto>>(
                    "cryptoProtocolVersion",
                    |m: &ZoneEncryptionInfoProto| { &m.cryptoProtocolVersion },
                    |m: &mut ZoneEncryptionInfoProto| { &mut m.cryptoProtocolVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyName",
                    |m: &ZoneEncryptionInfoProto| { &m.keyName },
                    |m: &mut ZoneEncryptionInfoProto| { &mut m.keyName },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ZoneEncryptionInfoProto>(
                    "ZoneEncryptionInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ZoneEncryptionInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<ZoneEncryptionInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ZoneEncryptionInfoProto,
        };
        unsafe {
            instance.get(ZoneEncryptionInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for ZoneEncryptionInfoProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.cryptoProtocolVersion = ::std::option::Option::None;
        self.keyName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ZoneEncryptionInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ZoneEncryptionInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CipherOptionProto {
    // message fields
    suite: ::std::option::Option<CipherSuiteProto>,
    inKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    inIv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    outKey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    outIv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CipherOptionProto {
    fn default() -> &'a CipherOptionProto {
        <CipherOptionProto as ::protobuf::Message>::default_instance()
    }
}

impl CipherOptionProto {
    pub fn new() -> CipherOptionProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CipherSuiteProto suite = 1;


    pub fn get_suite(&self) -> CipherSuiteProto {
        self.suite.unwrap_or(CipherSuiteProto::UNKNOWN)
    }
    pub fn clear_suite(&mut self) {
        self.suite = ::std::option::Option::None;
    }

    pub fn has_suite(&self) -> bool {
        self.suite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suite(&mut self, v: CipherSuiteProto) {
        self.suite = ::std::option::Option::Some(v);
    }

    // optional bytes inKey = 2;


    pub fn get_inKey(&self) -> &[u8] {
        match self.inKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_inKey(&mut self) {
        self.inKey.clear();
    }

    pub fn has_inKey(&self) -> bool {
        self.inKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.inKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inKey.is_none() {
            self.inKey.set_default();
        }
        self.inKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_inKey(&mut self) -> ::std::vec::Vec<u8> {
        self.inKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes inIv = 3;


    pub fn get_inIv(&self) -> &[u8] {
        match self.inIv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_inIv(&mut self) {
        self.inIv.clear();
    }

    pub fn has_inIv(&self) -> bool {
        self.inIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.inIv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inIv.is_none() {
            self.inIv.set_default();
        }
        self.inIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_inIv(&mut self) -> ::std::vec::Vec<u8> {
        self.inIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes outKey = 4;


    pub fn get_outKey(&self) -> &[u8] {
        match self.outKey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_outKey(&mut self) {
        self.outKey.clear();
    }

    pub fn has_outKey(&self) -> bool {
        self.outKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outKey(&mut self, v: ::std::vec::Vec<u8>) {
        self.outKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outKey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.outKey.is_none() {
            self.outKey.set_default();
        }
        self.outKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_outKey(&mut self) -> ::std::vec::Vec<u8> {
        self.outKey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes outIv = 5;


    pub fn get_outIv(&self) -> &[u8] {
        match self.outIv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_outIv(&mut self) {
        self.outIv.clear();
    }

    pub fn has_outIv(&self) -> bool {
        self.outIv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outIv(&mut self, v: ::std::vec::Vec<u8>) {
        self.outIv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outIv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.outIv.is_none() {
            self.outIv.set_default();
        }
        self.outIv.as_mut().unwrap()
    }

    // Take field
    pub fn take_outIv(&mut self) -> ::std::vec::Vec<u8> {
        self.outIv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CipherOptionProto {
    fn is_initialized(&self) -> bool {
        if self.suite.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.suite, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.inKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.inIv)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.outKey)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.outIv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.suite {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.inKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.inIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.outKey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.outIv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.suite {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.inKey.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.inIv.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.outKey.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.outIv.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CipherOptionProto {
        CipherOptionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CipherSuiteProto>>(
                    "suite",
                    |m: &CipherOptionProto| { &m.suite },
                    |m: &mut CipherOptionProto| { &mut m.suite },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "inKey",
                    |m: &CipherOptionProto| { &m.inKey },
                    |m: &mut CipherOptionProto| { &mut m.inKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "inIv",
                    |m: &CipherOptionProto| { &m.inIv },
                    |m: &mut CipherOptionProto| { &mut m.inIv },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "outKey",
                    |m: &CipherOptionProto| { &m.outKey },
                    |m: &mut CipherOptionProto| { &mut m.outKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "outIv",
                    |m: &CipherOptionProto| { &m.outIv },
                    |m: &mut CipherOptionProto| { &mut m.outIv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CipherOptionProto>(
                    "CipherOptionProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CipherOptionProto {
        static mut instance: ::protobuf::lazy::Lazy<CipherOptionProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CipherOptionProto,
        };
        unsafe {
            instance.get(CipherOptionProto::new)
        }
    }
}

impl ::protobuf::Clear for CipherOptionProto {
    fn clear(&mut self) {
        self.suite = ::std::option::Option::None;
        self.inKey.clear();
        self.inIv.clear();
        self.outKey.clear();
        self.outIv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CipherOptionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherOptionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocatedBlocksProto {
    // message fields
    fileLength: ::std::option::Option<u64>,
    blocks: ::protobuf::RepeatedField<LocatedBlockProto>,
    underConstruction: ::std::option::Option<bool>,
    lastBlock: ::protobuf::SingularPtrField<LocatedBlockProto>,
    isLastBlockComplete: ::std::option::Option<bool>,
    fileEncryptionInfo: ::protobuf::SingularPtrField<FileEncryptionInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocatedBlocksProto {
    fn default() -> &'a LocatedBlocksProto {
        <LocatedBlocksProto as ::protobuf::Message>::default_instance()
    }
}

impl LocatedBlocksProto {
    pub fn new() -> LocatedBlocksProto {
        ::std::default::Default::default()
    }

    // required uint64 fileLength = 1;


    pub fn get_fileLength(&self) -> u64 {
        self.fileLength.unwrap_or(0)
    }
    pub fn clear_fileLength(&mut self) {
        self.fileLength = ::std::option::Option::None;
    }

    pub fn has_fileLength(&self) -> bool {
        self.fileLength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileLength(&mut self, v: u64) {
        self.fileLength = ::std::option::Option::Some(v);
    }

    // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;


    pub fn get_blocks(&self) -> &[LocatedBlockProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<LocatedBlockProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<LocatedBlockProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<LocatedBlockProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }

    // required bool underConstruction = 3;


    pub fn get_underConstruction(&self) -> bool {
        self.underConstruction.unwrap_or(false)
    }
    pub fn clear_underConstruction(&mut self) {
        self.underConstruction = ::std::option::Option::None;
    }

    pub fn has_underConstruction(&self) -> bool {
        self.underConstruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_underConstruction(&mut self, v: bool) {
        self.underConstruction = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;


    pub fn get_lastBlock(&self) -> &LocatedBlockProto {
        self.lastBlock.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }
    pub fn clear_lastBlock(&mut self) {
        self.lastBlock.clear();
    }

    pub fn has_lastBlock(&self) -> bool {
        self.lastBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBlock(&mut self, v: LocatedBlockProto) {
        self.lastBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastBlock(&mut self) -> &mut LocatedBlockProto {
        if self.lastBlock.is_none() {
            self.lastBlock.set_default();
        }
        self.lastBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastBlock(&mut self) -> LocatedBlockProto {
        self.lastBlock.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    // required bool isLastBlockComplete = 5;


    pub fn get_isLastBlockComplete(&self) -> bool {
        self.isLastBlockComplete.unwrap_or(false)
    }
    pub fn clear_isLastBlockComplete(&mut self) {
        self.isLastBlockComplete = ::std::option::Option::None;
    }

    pub fn has_isLastBlockComplete(&self) -> bool {
        self.isLastBlockComplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLastBlockComplete(&mut self, v: bool) {
        self.isLastBlockComplete = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.FileEncryptionInfoProto fileEncryptionInfo = 6;


    pub fn get_fileEncryptionInfo(&self) -> &FileEncryptionInfoProto {
        self.fileEncryptionInfo.as_ref().unwrap_or_else(|| FileEncryptionInfoProto::default_instance())
    }
    pub fn clear_fileEncryptionInfo(&mut self) {
        self.fileEncryptionInfo.clear();
    }

    pub fn has_fileEncryptionInfo(&self) -> bool {
        self.fileEncryptionInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncryptionInfo(&mut self, v: FileEncryptionInfoProto) {
        self.fileEncryptionInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncryptionInfo(&mut self) -> &mut FileEncryptionInfoProto {
        if self.fileEncryptionInfo.is_none() {
            self.fileEncryptionInfo.set_default();
        }
        self.fileEncryptionInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncryptionInfo(&mut self) -> FileEncryptionInfoProto {
        self.fileEncryptionInfo.take().unwrap_or_else(|| FileEncryptionInfoProto::new())
    }
}

impl ::protobuf::Message for LocatedBlocksProto {
    fn is_initialized(&self) -> bool {
        if self.fileLength.is_none() {
            return false;
        }
        if self.underConstruction.is_none() {
            return false;
        }
        if self.isLastBlockComplete.is_none() {
            return false;
        }
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileEncryptionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileLength = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.underConstruction = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastBlock)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLastBlockComplete = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fileEncryptionInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileLength {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.underConstruction {
            my_size += 2;
        }
        if let Some(ref v) = self.lastBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isLastBlockComplete {
            my_size += 2;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileLength {
            os.write_uint64(1, v)?;
        }
        for v in &self.blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.underConstruction {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.lastBlock.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isLastBlockComplete {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocatedBlocksProto {
        LocatedBlocksProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileLength",
                    |m: &LocatedBlocksProto| { &m.fileLength },
                    |m: &mut LocatedBlocksProto| { &mut m.fileLength },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlockProto>>(
                    "blocks",
                    |m: &LocatedBlocksProto| { &m.blocks },
                    |m: &mut LocatedBlocksProto| { &mut m.blocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "underConstruction",
                    |m: &LocatedBlocksProto| { &m.underConstruction },
                    |m: &mut LocatedBlocksProto| { &mut m.underConstruction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlockProto>>(
                    "lastBlock",
                    |m: &LocatedBlocksProto| { &m.lastBlock },
                    |m: &mut LocatedBlocksProto| { &mut m.lastBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isLastBlockComplete",
                    |m: &LocatedBlocksProto| { &m.isLastBlockComplete },
                    |m: &mut LocatedBlocksProto| { &mut m.isLastBlockComplete },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileEncryptionInfoProto>>(
                    "fileEncryptionInfo",
                    |m: &LocatedBlocksProto| { &m.fileEncryptionInfo },
                    |m: &mut LocatedBlocksProto| { &mut m.fileEncryptionInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocatedBlocksProto>(
                    "LocatedBlocksProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LocatedBlocksProto {
        static mut instance: ::protobuf::lazy::Lazy<LocatedBlocksProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocatedBlocksProto,
        };
        unsafe {
            instance.get(LocatedBlocksProto::new)
        }
    }
}

impl ::protobuf::Clear for LocatedBlocksProto {
    fn clear(&mut self) {
        self.fileLength = ::std::option::Option::None;
        self.blocks.clear();
        self.underConstruction = ::std::option::Option::None;
        self.lastBlock.clear();
        self.isLastBlockComplete = ::std::option::Option::None;
        self.fileEncryptionInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocatedBlocksProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocatedBlocksProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HdfsFileStatusProto {
    // message fields
    fileType: ::std::option::Option<HdfsFileStatusProto_FileType>,
    path: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    length: ::std::option::Option<u64>,
    permission: ::protobuf::SingularPtrField<FsPermissionProto>,
    owner: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    modification_time: ::std::option::Option<u64>,
    access_time: ::std::option::Option<u64>,
    symlink: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    block_replication: ::std::option::Option<u32>,
    blocksize: ::std::option::Option<u64>,
    locations: ::protobuf::SingularPtrField<LocatedBlocksProto>,
    fileId: ::std::option::Option<u64>,
    childrenNum: ::std::option::Option<i32>,
    fileEncryptionInfo: ::protobuf::SingularPtrField<FileEncryptionInfoProto>,
    storagePolicy: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HdfsFileStatusProto {
    fn default() -> &'a HdfsFileStatusProto {
        <HdfsFileStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl HdfsFileStatusProto {
    pub fn new() -> HdfsFileStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;


    pub fn get_fileType(&self) -> HdfsFileStatusProto_FileType {
        self.fileType.unwrap_or(HdfsFileStatusProto_FileType::IS_DIR)
    }
    pub fn clear_fileType(&mut self) {
        self.fileType = ::std::option::Option::None;
    }

    pub fn has_fileType(&self) -> bool {
        self.fileType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileType(&mut self, v: HdfsFileStatusProto_FileType) {
        self.fileType = ::std::option::Option::Some(v);
    }

    // required bytes path = 2;


    pub fn get_path(&self) -> &[u8] {
        match self.path.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::vec::Vec<u8>) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::vec::Vec<u8> {
        self.path.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint64 length = 3;


    pub fn get_length(&self) -> u64 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u64) {
        self.length = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 4;


    pub fn get_permission(&self) -> &FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> FsPermissionProto {
        self.permission.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    // required string owner = 5;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        self.owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string group = 6;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 modification_time = 7;


    pub fn get_modification_time(&self) -> u64 {
        self.modification_time.unwrap_or(0)
    }
    pub fn clear_modification_time(&mut self) {
        self.modification_time = ::std::option::Option::None;
    }

    pub fn has_modification_time(&self) -> bool {
        self.modification_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_time(&mut self, v: u64) {
        self.modification_time = ::std::option::Option::Some(v);
    }

    // required uint64 access_time = 8;


    pub fn get_access_time(&self) -> u64 {
        self.access_time.unwrap_or(0)
    }
    pub fn clear_access_time(&mut self) {
        self.access_time = ::std::option::Option::None;
    }

    pub fn has_access_time(&self) -> bool {
        self.access_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_time(&mut self, v: u64) {
        self.access_time = ::std::option::Option::Some(v);
    }

    // optional bytes symlink = 9;


    pub fn get_symlink(&self) -> &[u8] {
        match self.symlink.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_symlink(&mut self) {
        self.symlink.clear();
    }

    pub fn has_symlink(&self) -> bool {
        self.symlink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symlink(&mut self, v: ::std::vec::Vec<u8>) {
        self.symlink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.symlink.is_none() {
            self.symlink.set_default();
        }
        self.symlink.as_mut().unwrap()
    }

    // Take field
    pub fn take_symlink(&mut self) -> ::std::vec::Vec<u8> {
        self.symlink.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 block_replication = 10;


    pub fn get_block_replication(&self) -> u32 {
        self.block_replication.unwrap_or(0u32)
    }
    pub fn clear_block_replication(&mut self) {
        self.block_replication = ::std::option::Option::None;
    }

    pub fn has_block_replication(&self) -> bool {
        self.block_replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_replication(&mut self, v: u32) {
        self.block_replication = ::std::option::Option::Some(v);
    }

    // optional uint64 blocksize = 11;


    pub fn get_blocksize(&self) -> u64 {
        self.blocksize.unwrap_or(0u64)
    }
    pub fn clear_blocksize(&mut self) {
        self.blocksize = ::std::option::Option::None;
    }

    pub fn has_blocksize(&self) -> bool {
        self.blocksize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blocksize(&mut self, v: u64) {
        self.blocksize = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;


    pub fn get_locations(&self) -> &LocatedBlocksProto {
        self.locations.as_ref().unwrap_or_else(|| LocatedBlocksProto::default_instance())
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    pub fn has_locations(&self) -> bool {
        self.locations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: LocatedBlocksProto) {
        self.locations = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_locations(&mut self) -> &mut LocatedBlocksProto {
        if self.locations.is_none() {
            self.locations.set_default();
        }
        self.locations.as_mut().unwrap()
    }

    // Take field
    pub fn take_locations(&mut self) -> LocatedBlocksProto {
        self.locations.take().unwrap_or_else(|| LocatedBlocksProto::new())
    }

    // optional uint64 fileId = 13;


    pub fn get_fileId(&self) -> u64 {
        self.fileId.unwrap_or(0u64)
    }
    pub fn clear_fileId(&mut self) {
        self.fileId = ::std::option::Option::None;
    }

    pub fn has_fileId(&self) -> bool {
        self.fileId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileId(&mut self, v: u64) {
        self.fileId = ::std::option::Option::Some(v);
    }

    // optional int32 childrenNum = 14;


    pub fn get_childrenNum(&self) -> i32 {
        self.childrenNum.unwrap_or(-1i32)
    }
    pub fn clear_childrenNum(&mut self) {
        self.childrenNum = ::std::option::Option::None;
    }

    pub fn has_childrenNum(&self) -> bool {
        self.childrenNum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_childrenNum(&mut self, v: i32) {
        self.childrenNum = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.FileEncryptionInfoProto fileEncryptionInfo = 15;


    pub fn get_fileEncryptionInfo(&self) -> &FileEncryptionInfoProto {
        self.fileEncryptionInfo.as_ref().unwrap_or_else(|| FileEncryptionInfoProto::default_instance())
    }
    pub fn clear_fileEncryptionInfo(&mut self) {
        self.fileEncryptionInfo.clear();
    }

    pub fn has_fileEncryptionInfo(&self) -> bool {
        self.fileEncryptionInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileEncryptionInfo(&mut self, v: FileEncryptionInfoProto) {
        self.fileEncryptionInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fileEncryptionInfo(&mut self) -> &mut FileEncryptionInfoProto {
        if self.fileEncryptionInfo.is_none() {
            self.fileEncryptionInfo.set_default();
        }
        self.fileEncryptionInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_fileEncryptionInfo(&mut self) -> FileEncryptionInfoProto {
        self.fileEncryptionInfo.take().unwrap_or_else(|| FileEncryptionInfoProto::new())
    }

    // optional uint32 storagePolicy = 16;


    pub fn get_storagePolicy(&self) -> u32 {
        self.storagePolicy.unwrap_or(0u32)
    }
    pub fn clear_storagePolicy(&mut self) {
        self.storagePolicy = ::std::option::Option::None;
    }

    pub fn has_storagePolicy(&self) -> bool {
        self.storagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicy(&mut self, v: u32) {
        self.storagePolicy = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for HdfsFileStatusProto {
    fn is_initialized(&self) -> bool {
        if self.fileType.is_none() {
            return false;
        }
        if self.path.is_none() {
            return false;
        }
        if self.length.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        if self.owner.is_none() {
            return false;
        }
        if self.group.is_none() {
            return false;
        }
        if self.modification_time.is_none() {
            return false;
        }
        if self.access_time.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fileEncryptionInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.fileType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.modification_time = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.access_time = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.symlink)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.block_replication = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocksize = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.locations)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fileId = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.childrenNum = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fileEncryptionInfo)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.storagePolicy = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.fileType {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.modification_time {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.access_time {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.symlink.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(v) = self.block_replication {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.blocksize {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.locations.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fileId {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.childrenNum {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.storagePolicy {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.fileType {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.length {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.modification_time {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.access_time {
            os.write_uint64(8, v)?;
        }
        if let Some(ref v) = self.symlink.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(v) = self.block_replication {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.blocksize {
            os.write_uint64(11, v)?;
        }
        if let Some(ref v) = self.locations.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fileId {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.childrenNum {
            os.write_int32(14, v)?;
        }
        if let Some(ref v) = self.fileEncryptionInfo.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.storagePolicy {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HdfsFileStatusProto {
        HdfsFileStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HdfsFileStatusProto_FileType>>(
                    "fileType",
                    |m: &HdfsFileStatusProto| { &m.fileType },
                    |m: &mut HdfsFileStatusProto| { &mut m.fileType },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "path",
                    |m: &HdfsFileStatusProto| { &m.path },
                    |m: &mut HdfsFileStatusProto| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "length",
                    |m: &HdfsFileStatusProto| { &m.length },
                    |m: &mut HdfsFileStatusProto| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FsPermissionProto>>(
                    "permission",
                    |m: &HdfsFileStatusProto| { &m.permission },
                    |m: &mut HdfsFileStatusProto| { &mut m.permission },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner",
                    |m: &HdfsFileStatusProto| { &m.owner },
                    |m: &mut HdfsFileStatusProto| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group",
                    |m: &HdfsFileStatusProto| { &m.group },
                    |m: &mut HdfsFileStatusProto| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "modification_time",
                    |m: &HdfsFileStatusProto| { &m.modification_time },
                    |m: &mut HdfsFileStatusProto| { &mut m.modification_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "access_time",
                    |m: &HdfsFileStatusProto| { &m.access_time },
                    |m: &mut HdfsFileStatusProto| { &mut m.access_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "symlink",
                    |m: &HdfsFileStatusProto| { &m.symlink },
                    |m: &mut HdfsFileStatusProto| { &mut m.symlink },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "block_replication",
                    |m: &HdfsFileStatusProto| { &m.block_replication },
                    |m: &mut HdfsFileStatusProto| { &mut m.block_replication },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocksize",
                    |m: &HdfsFileStatusProto| { &m.blocksize },
                    |m: &mut HdfsFileStatusProto| { &mut m.blocksize },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlocksProto>>(
                    "locations",
                    |m: &HdfsFileStatusProto| { &m.locations },
                    |m: &mut HdfsFileStatusProto| { &mut m.locations },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fileId",
                    |m: &HdfsFileStatusProto| { &m.fileId },
                    |m: &mut HdfsFileStatusProto| { &mut m.fileId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "childrenNum",
                    |m: &HdfsFileStatusProto| { &m.childrenNum },
                    |m: &mut HdfsFileStatusProto| { &mut m.childrenNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FileEncryptionInfoProto>>(
                    "fileEncryptionInfo",
                    |m: &HdfsFileStatusProto| { &m.fileEncryptionInfo },
                    |m: &mut HdfsFileStatusProto| { &mut m.fileEncryptionInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "storagePolicy",
                    |m: &HdfsFileStatusProto| { &m.storagePolicy },
                    |m: &mut HdfsFileStatusProto| { &mut m.storagePolicy },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HdfsFileStatusProto>(
                    "HdfsFileStatusProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HdfsFileStatusProto {
        static mut instance: ::protobuf::lazy::Lazy<HdfsFileStatusProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HdfsFileStatusProto,
        };
        unsafe {
            instance.get(HdfsFileStatusProto::new)
        }
    }
}

impl ::protobuf::Clear for HdfsFileStatusProto {
    fn clear(&mut self) {
        self.fileType = ::std::option::Option::None;
        self.path.clear();
        self.length = ::std::option::Option::None;
        self.permission.clear();
        self.owner.clear();
        self.group.clear();
        self.modification_time = ::std::option::Option::None;
        self.access_time = ::std::option::Option::None;
        self.symlink.clear();
        self.block_replication = ::std::option::Option::None;
        self.blocksize = ::std::option::Option::None;
        self.locations.clear();
        self.fileId = ::std::option::Option::None;
        self.childrenNum = ::std::option::Option::None;
        self.fileEncryptionInfo.clear();
        self.storagePolicy = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HdfsFileStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsFileStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HdfsFileStatusProto_FileType {
    IS_DIR = 1,
    IS_FILE = 2,
    IS_SYMLINK = 3,
}

impl ::protobuf::ProtobufEnum for HdfsFileStatusProto_FileType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HdfsFileStatusProto_FileType> {
        match value {
            1 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_DIR),
            2 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_FILE),
            3 => ::std::option::Option::Some(HdfsFileStatusProto_FileType::IS_SYMLINK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HdfsFileStatusProto_FileType] = &[
            HdfsFileStatusProto_FileType::IS_DIR,
            HdfsFileStatusProto_FileType::IS_FILE,
            HdfsFileStatusProto_FileType::IS_SYMLINK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HdfsFileStatusProto_FileType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HdfsFileStatusProto_FileType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for HdfsFileStatusProto_FileType {
    fn default() -> Self {
        HdfsFileStatusProto_FileType::IS_DIR
    }
}

impl ::protobuf::reflect::ProtobufValue for HdfsFileStatusProto_FileType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FsServerDefaultsProto {
    // message fields
    blockSize: ::std::option::Option<u64>,
    bytesPerChecksum: ::std::option::Option<u32>,
    writePacketSize: ::std::option::Option<u32>,
    replication: ::std::option::Option<u32>,
    fileBufferSize: ::std::option::Option<u32>,
    encryptDataTransfer: ::std::option::Option<bool>,
    trashInterval: ::std::option::Option<u64>,
    checksumType: ::std::option::Option<ChecksumTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FsServerDefaultsProto {
    fn default() -> &'a FsServerDefaultsProto {
        <FsServerDefaultsProto as ::protobuf::Message>::default_instance()
    }
}

impl FsServerDefaultsProto {
    pub fn new() -> FsServerDefaultsProto {
        ::std::default::Default::default()
    }

    // required uint64 blockSize = 1;


    pub fn get_blockSize(&self) -> u64 {
        self.blockSize.unwrap_or(0)
    }
    pub fn clear_blockSize(&mut self) {
        self.blockSize = ::std::option::Option::None;
    }

    pub fn has_blockSize(&self) -> bool {
        self.blockSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockSize(&mut self, v: u64) {
        self.blockSize = ::std::option::Option::Some(v);
    }

    // required uint32 bytesPerChecksum = 2;


    pub fn get_bytesPerChecksum(&self) -> u32 {
        self.bytesPerChecksum.unwrap_or(0)
    }
    pub fn clear_bytesPerChecksum(&mut self) {
        self.bytesPerChecksum = ::std::option::Option::None;
    }

    pub fn has_bytesPerChecksum(&self) -> bool {
        self.bytesPerChecksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytesPerChecksum(&mut self, v: u32) {
        self.bytesPerChecksum = ::std::option::Option::Some(v);
    }

    // required uint32 writePacketSize = 3;


    pub fn get_writePacketSize(&self) -> u32 {
        self.writePacketSize.unwrap_or(0)
    }
    pub fn clear_writePacketSize(&mut self) {
        self.writePacketSize = ::std::option::Option::None;
    }

    pub fn has_writePacketSize(&self) -> bool {
        self.writePacketSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_writePacketSize(&mut self, v: u32) {
        self.writePacketSize = ::std::option::Option::Some(v);
    }

    // required uint32 replication = 4;


    pub fn get_replication(&self) -> u32 {
        self.replication.unwrap_or(0)
    }
    pub fn clear_replication(&mut self) {
        self.replication = ::std::option::Option::None;
    }

    pub fn has_replication(&self) -> bool {
        self.replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replication(&mut self, v: u32) {
        self.replication = ::std::option::Option::Some(v);
    }

    // required uint32 fileBufferSize = 5;


    pub fn get_fileBufferSize(&self) -> u32 {
        self.fileBufferSize.unwrap_or(0)
    }
    pub fn clear_fileBufferSize(&mut self) {
        self.fileBufferSize = ::std::option::Option::None;
    }

    pub fn has_fileBufferSize(&self) -> bool {
        self.fileBufferSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fileBufferSize(&mut self, v: u32) {
        self.fileBufferSize = ::std::option::Option::Some(v);
    }

    // optional bool encryptDataTransfer = 6;


    pub fn get_encryptDataTransfer(&self) -> bool {
        self.encryptDataTransfer.unwrap_or(false)
    }
    pub fn clear_encryptDataTransfer(&mut self) {
        self.encryptDataTransfer = ::std::option::Option::None;
    }

    pub fn has_encryptDataTransfer(&self) -> bool {
        self.encryptDataTransfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryptDataTransfer(&mut self, v: bool) {
        self.encryptDataTransfer = ::std::option::Option::Some(v);
    }

    // optional uint64 trashInterval = 7;


    pub fn get_trashInterval(&self) -> u64 {
        self.trashInterval.unwrap_or(0u64)
    }
    pub fn clear_trashInterval(&mut self) {
        self.trashInterval = ::std::option::Option::None;
    }

    pub fn has_trashInterval(&self) -> bool {
        self.trashInterval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trashInterval(&mut self, v: u64) {
        self.trashInterval = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8;


    pub fn get_checksumType(&self) -> ChecksumTypeProto {
        self.checksumType.unwrap_or(ChecksumTypeProto::CHECKSUM_CRC32)
    }
    pub fn clear_checksumType(&mut self) {
        self.checksumType = ::std::option::Option::None;
    }

    pub fn has_checksumType(&self) -> bool {
        self.checksumType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checksumType(&mut self, v: ChecksumTypeProto) {
        self.checksumType = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FsServerDefaultsProto {
    fn is_initialized(&self) -> bool {
        if self.blockSize.is_none() {
            return false;
        }
        if self.bytesPerChecksum.is_none() {
            return false;
        }
        if self.writePacketSize.is_none() {
            return false;
        }
        if self.replication.is_none() {
            return false;
        }
        if self.fileBufferSize.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockSize = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bytesPerChecksum = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.writePacketSize = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.replication = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fileBufferSize = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.encryptDataTransfer = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trashInterval = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.checksumType, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blockSize {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bytesPerChecksum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.writePacketSize {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.replication {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fileBufferSize {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.encryptDataTransfer {
            my_size += 2;
        }
        if let Some(v) = self.trashInterval {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.checksumType {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blockSize {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.bytesPerChecksum {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.writePacketSize {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.replication {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.fileBufferSize {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.encryptDataTransfer {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.trashInterval {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.checksumType {
            os.write_enum(8, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FsServerDefaultsProto {
        FsServerDefaultsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockSize",
                    |m: &FsServerDefaultsProto| { &m.blockSize },
                    |m: &mut FsServerDefaultsProto| { &mut m.blockSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bytesPerChecksum",
                    |m: &FsServerDefaultsProto| { &m.bytesPerChecksum },
                    |m: &mut FsServerDefaultsProto| { &mut m.bytesPerChecksum },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "writePacketSize",
                    |m: &FsServerDefaultsProto| { &m.writePacketSize },
                    |m: &mut FsServerDefaultsProto| { &mut m.writePacketSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "replication",
                    |m: &FsServerDefaultsProto| { &m.replication },
                    |m: &mut FsServerDefaultsProto| { &mut m.replication },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fileBufferSize",
                    |m: &FsServerDefaultsProto| { &m.fileBufferSize },
                    |m: &mut FsServerDefaultsProto| { &mut m.fileBufferSize },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "encryptDataTransfer",
                    |m: &FsServerDefaultsProto| { &m.encryptDataTransfer },
                    |m: &mut FsServerDefaultsProto| { &mut m.encryptDataTransfer },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "trashInterval",
                    |m: &FsServerDefaultsProto| { &m.trashInterval },
                    |m: &mut FsServerDefaultsProto| { &mut m.trashInterval },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChecksumTypeProto>>(
                    "checksumType",
                    |m: &FsServerDefaultsProto| { &m.checksumType },
                    |m: &mut FsServerDefaultsProto| { &mut m.checksumType },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FsServerDefaultsProto>(
                    "FsServerDefaultsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FsServerDefaultsProto {
        static mut instance: ::protobuf::lazy::Lazy<FsServerDefaultsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FsServerDefaultsProto,
        };
        unsafe {
            instance.get(FsServerDefaultsProto::new)
        }
    }
}

impl ::protobuf::Clear for FsServerDefaultsProto {
    fn clear(&mut self) {
        self.blockSize = ::std::option::Option::None;
        self.bytesPerChecksum = ::std::option::Option::None;
        self.writePacketSize = ::std::option::Option::None;
        self.replication = ::std::option::Option::None;
        self.fileBufferSize = ::std::option::Option::None;
        self.encryptDataTransfer = ::std::option::Option::None;
        self.trashInterval = ::std::option::Option::None;
        self.checksumType = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FsServerDefaultsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FsServerDefaultsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectoryListingProto {
    // message fields
    partialListing: ::protobuf::RepeatedField<HdfsFileStatusProto>,
    remainingEntries: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectoryListingProto {
    fn default() -> &'a DirectoryListingProto {
        <DirectoryListingProto as ::protobuf::Message>::default_instance()
    }
}

impl DirectoryListingProto {
    pub fn new() -> DirectoryListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;


    pub fn get_partialListing(&self) -> &[HdfsFileStatusProto] {
        &self.partialListing
    }
    pub fn clear_partialListing(&mut self) {
        self.partialListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_partialListing(&mut self, v: ::protobuf::RepeatedField<HdfsFileStatusProto>) {
        self.partialListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partialListing(&mut self) -> &mut ::protobuf::RepeatedField<HdfsFileStatusProto> {
        &mut self.partialListing
    }

    // Take field
    pub fn take_partialListing(&mut self) -> ::protobuf::RepeatedField<HdfsFileStatusProto> {
        ::std::mem::replace(&mut self.partialListing, ::protobuf::RepeatedField::new())
    }

    // required uint32 remainingEntries = 2;


    pub fn get_remainingEntries(&self) -> u32 {
        self.remainingEntries.unwrap_or(0)
    }
    pub fn clear_remainingEntries(&mut self) {
        self.remainingEntries = ::std::option::Option::None;
    }

    pub fn has_remainingEntries(&self) -> bool {
        self.remainingEntries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainingEntries(&mut self, v: u32) {
        self.remainingEntries = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DirectoryListingProto {
    fn is_initialized(&self) -> bool {
        if self.remainingEntries.is_none() {
            return false;
        }
        for v in &self.partialListing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partialListing)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remainingEntries = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.partialListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.remainingEntries {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.partialListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.remainingEntries {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectoryListingProto {
        DirectoryListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                    "partialListing",
                    |m: &DirectoryListingProto| { &m.partialListing },
                    |m: &mut DirectoryListingProto| { &mut m.partialListing },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remainingEntries",
                    |m: &DirectoryListingProto| { &m.remainingEntries },
                    |m: &mut DirectoryListingProto| { &mut m.remainingEntries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DirectoryListingProto>(
                    "DirectoryListingProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DirectoryListingProto {
        static mut instance: ::protobuf::lazy::Lazy<DirectoryListingProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DirectoryListingProto,
        };
        unsafe {
            instance.get(DirectoryListingProto::new)
        }
    }
}

impl ::protobuf::Clear for DirectoryListingProto {
    fn clear(&mut self) {
        self.partialListing.clear();
        self.remainingEntries = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectoryListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectoryListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshottableDirectoryStatusProto {
    // message fields
    dirStatus: ::protobuf::SingularPtrField<HdfsFileStatusProto>,
    snapshot_quota: ::std::option::Option<u32>,
    snapshot_number: ::std::option::Option<u32>,
    parent_fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshottableDirectoryStatusProto {
    fn default() -> &'a SnapshottableDirectoryStatusProto {
        <SnapshottableDirectoryStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshottableDirectoryStatusProto {
    pub fn new() -> SnapshottableDirectoryStatusProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;


    pub fn get_dirStatus(&self) -> &HdfsFileStatusProto {
        self.dirStatus.as_ref().unwrap_or_else(|| HdfsFileStatusProto::default_instance())
    }
    pub fn clear_dirStatus(&mut self) {
        self.dirStatus.clear();
    }

    pub fn has_dirStatus(&self) -> bool {
        self.dirStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dirStatus(&mut self, v: HdfsFileStatusProto) {
        self.dirStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dirStatus(&mut self) -> &mut HdfsFileStatusProto {
        if self.dirStatus.is_none() {
            self.dirStatus.set_default();
        }
        self.dirStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_dirStatus(&mut self) -> HdfsFileStatusProto {
        self.dirStatus.take().unwrap_or_else(|| HdfsFileStatusProto::new())
    }

    // required uint32 snapshot_quota = 2;


    pub fn get_snapshot_quota(&self) -> u32 {
        self.snapshot_quota.unwrap_or(0)
    }
    pub fn clear_snapshot_quota(&mut self) {
        self.snapshot_quota = ::std::option::Option::None;
    }

    pub fn has_snapshot_quota(&self) -> bool {
        self.snapshot_quota.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_quota(&mut self, v: u32) {
        self.snapshot_quota = ::std::option::Option::Some(v);
    }

    // required uint32 snapshot_number = 3;


    pub fn get_snapshot_number(&self) -> u32 {
        self.snapshot_number.unwrap_or(0)
    }
    pub fn clear_snapshot_number(&mut self) {
        self.snapshot_number = ::std::option::Option::None;
    }

    pub fn has_snapshot_number(&self) -> bool {
        self.snapshot_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_number(&mut self, v: u32) {
        self.snapshot_number = ::std::option::Option::Some(v);
    }

    // required bytes parent_fullpath = 4;


    pub fn get_parent_fullpath(&self) -> &[u8] {
        match self.parent_fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_parent_fullpath(&mut self) {
        self.parent_fullpath.clear();
    }

    pub fn has_parent_fullpath(&self) -> bool {
        self.parent_fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parent_fullpath.is_none() {
            self.parent_fullpath.set_default();
        }
        self.parent_fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.parent_fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshottableDirectoryStatusProto {
    fn is_initialized(&self) -> bool {
        if self.dirStatus.is_none() {
            return false;
        }
        if self.snapshot_quota.is_none() {
            return false;
        }
        if self.snapshot_number.is_none() {
            return false;
        }
        if self.parent_fullpath.is_none() {
            return false;
        }
        for v in &self.dirStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dirStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshot_quota = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.snapshot_number = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parent_fullpath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dirStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.snapshot_quota {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.snapshot_number {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dirStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.snapshot_quota {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.snapshot_number {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.parent_fullpath.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshottableDirectoryStatusProto {
        SnapshottableDirectoryStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HdfsFileStatusProto>>(
                    "dirStatus",
                    |m: &SnapshottableDirectoryStatusProto| { &m.dirStatus },
                    |m: &mut SnapshottableDirectoryStatusProto| { &mut m.dirStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "snapshot_quota",
                    |m: &SnapshottableDirectoryStatusProto| { &m.snapshot_quota },
                    |m: &mut SnapshottableDirectoryStatusProto| { &mut m.snapshot_quota },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "snapshot_number",
                    |m: &SnapshottableDirectoryStatusProto| { &m.snapshot_number },
                    |m: &mut SnapshottableDirectoryStatusProto| { &mut m.snapshot_number },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parent_fullpath",
                    |m: &SnapshottableDirectoryStatusProto| { &m.parent_fullpath },
                    |m: &mut SnapshottableDirectoryStatusProto| { &mut m.parent_fullpath },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshottableDirectoryStatusProto>(
                    "SnapshottableDirectoryStatusProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshottableDirectoryStatusProto {
        static mut instance: ::protobuf::lazy::Lazy<SnapshottableDirectoryStatusProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshottableDirectoryStatusProto,
        };
        unsafe {
            instance.get(SnapshottableDirectoryStatusProto::new)
        }
    }
}

impl ::protobuf::Clear for SnapshottableDirectoryStatusProto {
    fn clear(&mut self) {
        self.dirStatus.clear();
        self.snapshot_quota = ::std::option::Option::None;
        self.snapshot_number = ::std::option::Option::None;
        self.parent_fullpath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshottableDirectoryStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshottableDirectoryStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshottableDirectoryListingProto {
    // message fields
    snapshottableDirListing: ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshottableDirectoryListingProto {
    fn default() -> &'a SnapshottableDirectoryListingProto {
        <SnapshottableDirectoryListingProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshottableDirectoryListingProto {
    pub fn new() -> SnapshottableDirectoryListingProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;


    pub fn get_snapshottableDirListing(&self) -> &[SnapshottableDirectoryStatusProto] {
        &self.snapshottableDirListing
    }
    pub fn clear_snapshottableDirListing(&mut self) {
        self.snapshottableDirListing.clear();
    }

    // Param is passed by value, moved
    pub fn set_snapshottableDirListing(&mut self, v: ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto>) {
        self.snapshottableDirListing = v;
    }

    // Mutable pointer to the field.
    pub fn mut_snapshottableDirListing(&mut self) -> &mut ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto> {
        &mut self.snapshottableDirListing
    }

    // Take field
    pub fn take_snapshottableDirListing(&mut self) -> ::protobuf::RepeatedField<SnapshottableDirectoryStatusProto> {
        ::std::mem::replace(&mut self.snapshottableDirListing, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshottableDirectoryListingProto {
    fn is_initialized(&self) -> bool {
        for v in &self.snapshottableDirListing {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.snapshottableDirListing)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.snapshottableDirListing {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.snapshottableDirListing {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshottableDirectoryListingProto {
        SnapshottableDirectoryListingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshottableDirectoryStatusProto>>(
                    "snapshottableDirListing",
                    |m: &SnapshottableDirectoryListingProto| { &m.snapshottableDirListing },
                    |m: &mut SnapshottableDirectoryListingProto| { &mut m.snapshottableDirListing },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshottableDirectoryListingProto>(
                    "SnapshottableDirectoryListingProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshottableDirectoryListingProto {
        static mut instance: ::protobuf::lazy::Lazy<SnapshottableDirectoryListingProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshottableDirectoryListingProto,
        };
        unsafe {
            instance.get(SnapshottableDirectoryListingProto::new)
        }
    }
}

impl ::protobuf::Clear for SnapshottableDirectoryListingProto {
    fn clear(&mut self) {
        self.snapshottableDirListing.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshottableDirectoryListingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshottableDirectoryListingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportEntryProto {
    // message fields
    fullpath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    modificationLabel: ::protobuf::SingularField<::std::string::String>,
    targetPath: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportEntryProto {
    fn default() -> &'a SnapshotDiffReportEntryProto {
        <SnapshotDiffReportEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportEntryProto {
    pub fn new() -> SnapshotDiffReportEntryProto {
        ::std::default::Default::default()
    }

    // required bytes fullpath = 1;


    pub fn get_fullpath(&self) -> &[u8] {
        match self.fullpath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_fullpath(&mut self) {
        self.fullpath.clear();
    }

    pub fn has_fullpath(&self) -> bool {
        self.fullpath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullpath(&mut self, v: ::std::vec::Vec<u8>) {
        self.fullpath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fullpath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.fullpath.is_none() {
            self.fullpath.set_default();
        }
        self.fullpath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fullpath(&mut self) -> ::std::vec::Vec<u8> {
        self.fullpath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required string modificationLabel = 2;


    pub fn get_modificationLabel(&self) -> &str {
        match self.modificationLabel.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_modificationLabel(&mut self) {
        self.modificationLabel.clear();
    }

    pub fn has_modificationLabel(&self) -> bool {
        self.modificationLabel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modificationLabel(&mut self, v: ::std::string::String) {
        self.modificationLabel = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modificationLabel(&mut self) -> &mut ::std::string::String {
        if self.modificationLabel.is_none() {
            self.modificationLabel.set_default();
        }
        self.modificationLabel.as_mut().unwrap()
    }

    // Take field
    pub fn take_modificationLabel(&mut self) -> ::std::string::String {
        self.modificationLabel.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes targetPath = 3;


    pub fn get_targetPath(&self) -> &[u8] {
        match self.targetPath.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_targetPath(&mut self) {
        self.targetPath.clear();
    }

    pub fn has_targetPath(&self) -> bool {
        self.targetPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPath(&mut self, v: ::std::vec::Vec<u8>) {
        self.targetPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPath(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.targetPath.is_none() {
            self.targetPath.set_default();
        }
        self.targetPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPath(&mut self) -> ::std::vec::Vec<u8> {
        self.targetPath.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SnapshotDiffReportEntryProto {
    fn is_initialized(&self) -> bool {
        if self.fullpath.is_none() {
            return false;
        }
        if self.modificationLabel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.fullpath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.modificationLabel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.targetPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fullpath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.modificationLabel.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fullpath.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.modificationLabel.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.targetPath.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportEntryProto {
        SnapshotDiffReportEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "fullpath",
                    |m: &SnapshotDiffReportEntryProto| { &m.fullpath },
                    |m: &mut SnapshotDiffReportEntryProto| { &mut m.fullpath },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "modificationLabel",
                    |m: &SnapshotDiffReportEntryProto| { &m.modificationLabel },
                    |m: &mut SnapshotDiffReportEntryProto| { &mut m.modificationLabel },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "targetPath",
                    |m: &SnapshotDiffReportEntryProto| { &m.targetPath },
                    |m: &mut SnapshotDiffReportEntryProto| { &mut m.targetPath },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshotDiffReportEntryProto>(
                    "SnapshotDiffReportEntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshotDiffReportEntryProto {
        static mut instance: ::protobuf::lazy::Lazy<SnapshotDiffReportEntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshotDiffReportEntryProto,
        };
        unsafe {
            instance.get(SnapshotDiffReportEntryProto::new)
        }
    }
}

impl ::protobuf::Clear for SnapshotDiffReportEntryProto {
    fn clear(&mut self) {
        self.fullpath.clear();
        self.modificationLabel.clear();
        self.targetPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotDiffReportProto {
    // message fields
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    fromSnapshot: ::protobuf::SingularField<::std::string::String>,
    toSnapshot: ::protobuf::SingularField<::std::string::String>,
    diffReportEntries: ::protobuf::RepeatedField<SnapshotDiffReportEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotDiffReportProto {
    fn default() -> &'a SnapshotDiffReportProto {
        <SnapshotDiffReportProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotDiffReportProto {
    pub fn new() -> SnapshotDiffReportProto {
        ::std::default::Default::default()
    }

    // required string snapshotRoot = 1;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string fromSnapshot = 2;


    pub fn get_fromSnapshot(&self) -> &str {
        match self.fromSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fromSnapshot(&mut self) {
        self.fromSnapshot.clear();
    }

    pub fn has_fromSnapshot(&self) -> bool {
        self.fromSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromSnapshot(&mut self, v: ::std::string::String) {
        self.fromSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fromSnapshot(&mut self) -> &mut ::std::string::String {
        if self.fromSnapshot.is_none() {
            self.fromSnapshot.set_default();
        }
        self.fromSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_fromSnapshot(&mut self) -> ::std::string::String {
        self.fromSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string toSnapshot = 3;


    pub fn get_toSnapshot(&self) -> &str {
        match self.toSnapshot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_toSnapshot(&mut self) {
        self.toSnapshot.clear();
    }

    pub fn has_toSnapshot(&self) -> bool {
        self.toSnapshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toSnapshot(&mut self, v: ::std::string::String) {
        self.toSnapshot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toSnapshot(&mut self) -> &mut ::std::string::String {
        if self.toSnapshot.is_none() {
            self.toSnapshot.set_default();
        }
        self.toSnapshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_toSnapshot(&mut self) -> ::std::string::String {
        self.toSnapshot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;


    pub fn get_diffReportEntries(&self) -> &[SnapshotDiffReportEntryProto] {
        &self.diffReportEntries
    }
    pub fn clear_diffReportEntries(&mut self) {
        self.diffReportEntries.clear();
    }

    // Param is passed by value, moved
    pub fn set_diffReportEntries(&mut self, v: ::protobuf::RepeatedField<SnapshotDiffReportEntryProto>) {
        self.diffReportEntries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_diffReportEntries(&mut self) -> &mut ::protobuf::RepeatedField<SnapshotDiffReportEntryProto> {
        &mut self.diffReportEntries
    }

    // Take field
    pub fn take_diffReportEntries(&mut self) -> ::protobuf::RepeatedField<SnapshotDiffReportEntryProto> {
        ::std::mem::replace(&mut self.diffReportEntries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SnapshotDiffReportProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.fromSnapshot.is_none() {
            return false;
        }
        if self.toSnapshot.is_none() {
            return false;
        }
        for v in &self.diffReportEntries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fromSnapshot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.toSnapshot)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.diffReportEntries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.diffReportEntries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fromSnapshot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.toSnapshot.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.diffReportEntries {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotDiffReportProto {
        SnapshotDiffReportProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &SnapshotDiffReportProto| { &m.snapshotRoot },
                    |m: &mut SnapshotDiffReportProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fromSnapshot",
                    |m: &SnapshotDiffReportProto| { &m.fromSnapshot },
                    |m: &mut SnapshotDiffReportProto| { &mut m.fromSnapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "toSnapshot",
                    |m: &SnapshotDiffReportProto| { &m.toSnapshot },
                    |m: &mut SnapshotDiffReportProto| { &mut m.toSnapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SnapshotDiffReportEntryProto>>(
                    "diffReportEntries",
                    |m: &SnapshotDiffReportProto| { &m.diffReportEntries },
                    |m: &mut SnapshotDiffReportProto| { &mut m.diffReportEntries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshotDiffReportProto>(
                    "SnapshotDiffReportProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshotDiffReportProto {
        static mut instance: ::protobuf::lazy::Lazy<SnapshotDiffReportProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshotDiffReportProto,
        };
        unsafe {
            instance.get(SnapshotDiffReportProto::new)
        }
    }
}

impl ::protobuf::Clear for SnapshotDiffReportProto {
    fn clear(&mut self) {
        self.snapshotRoot.clear();
        self.fromSnapshot.clear();
        self.toSnapshot.clear();
        self.diffReportEntries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotDiffReportProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotDiffReportProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageInfoProto {
    // message fields
    layoutVersion: ::std::option::Option<u32>,
    namespceID: ::std::option::Option<u32>,
    clusterID: ::protobuf::SingularField<::std::string::String>,
    cTime: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageInfoProto {
    fn default() -> &'a StorageInfoProto {
        <StorageInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl StorageInfoProto {
    pub fn new() -> StorageInfoProto {
        ::std::default::Default::default()
    }

    // required uint32 layoutVersion = 1;


    pub fn get_layoutVersion(&self) -> u32 {
        self.layoutVersion.unwrap_or(0)
    }
    pub fn clear_layoutVersion(&mut self) {
        self.layoutVersion = ::std::option::Option::None;
    }

    pub fn has_layoutVersion(&self) -> bool {
        self.layoutVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layoutVersion(&mut self, v: u32) {
        self.layoutVersion = ::std::option::Option::Some(v);
    }

    // required uint32 namespceID = 2;


    pub fn get_namespceID(&self) -> u32 {
        self.namespceID.unwrap_or(0)
    }
    pub fn clear_namespceID(&mut self) {
        self.namespceID = ::std::option::Option::None;
    }

    pub fn has_namespceID(&self) -> bool {
        self.namespceID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespceID(&mut self, v: u32) {
        self.namespceID = ::std::option::Option::Some(v);
    }

    // required string clusterID = 3;


    pub fn get_clusterID(&self) -> &str {
        match self.clusterID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clusterID(&mut self) {
        self.clusterID.clear();
    }

    pub fn has_clusterID(&self) -> bool {
        self.clusterID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterID(&mut self, v: ::std::string::String) {
        self.clusterID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterID(&mut self) -> &mut ::std::string::String {
        if self.clusterID.is_none() {
            self.clusterID.set_default();
        }
        self.clusterID.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterID(&mut self) -> ::std::string::String {
        self.clusterID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 cTime = 4;


    pub fn get_cTime(&self) -> u64 {
        self.cTime.unwrap_or(0)
    }
    pub fn clear_cTime(&mut self) {
        self.cTime = ::std::option::Option::None;
    }

    pub fn has_cTime(&self) -> bool {
        self.cTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cTime(&mut self, v: u64) {
        self.cTime = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StorageInfoProto {
    fn is_initialized(&self) -> bool {
        if self.layoutVersion.is_none() {
            return false;
        }
        if self.namespceID.is_none() {
            return false;
        }
        if self.clusterID.is_none() {
            return false;
        }
        if self.cTime.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.layoutVersion = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.namespceID = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clusterID)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cTime = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.layoutVersion {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.namespceID {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.clusterID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.cTime {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.layoutVersion {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.namespceID {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.clusterID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.cTime {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageInfoProto {
        StorageInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "layoutVersion",
                    |m: &StorageInfoProto| { &m.layoutVersion },
                    |m: &mut StorageInfoProto| { &mut m.layoutVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "namespceID",
                    |m: &StorageInfoProto| { &m.namespceID },
                    |m: &mut StorageInfoProto| { &mut m.namespceID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clusterID",
                    |m: &StorageInfoProto| { &m.clusterID },
                    |m: &mut StorageInfoProto| { &mut m.clusterID },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cTime",
                    |m: &StorageInfoProto| { &m.cTime },
                    |m: &mut StorageInfoProto| { &mut m.cTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageInfoProto>(
                    "StorageInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StorageInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<StorageInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageInfoProto,
        };
        unsafe {
            instance.get(StorageInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for StorageInfoProto {
    fn clear(&mut self) {
        self.layoutVersion = ::std::option::Option::None;
        self.namespceID = ::std::option::Option::None;
        self.clusterID.clear();
        self.cTime = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamenodeRegistrationProto {
    // message fields
    rpcAddress: ::protobuf::SingularField<::std::string::String>,
    httpAddress: ::protobuf::SingularField<::std::string::String>,
    storageInfo: ::protobuf::SingularPtrField<StorageInfoProto>,
    role: ::std::option::Option<NamenodeRegistrationProto_NamenodeRoleProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamenodeRegistrationProto {
    fn default() -> &'a NamenodeRegistrationProto {
        <NamenodeRegistrationProto as ::protobuf::Message>::default_instance()
    }
}

impl NamenodeRegistrationProto {
    pub fn new() -> NamenodeRegistrationProto {
        ::std::default::Default::default()
    }

    // required string rpcAddress = 1;


    pub fn get_rpcAddress(&self) -> &str {
        match self.rpcAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rpcAddress(&mut self) {
        self.rpcAddress.clear();
    }

    pub fn has_rpcAddress(&self) -> bool {
        self.rpcAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpcAddress(&mut self, v: ::std::string::String) {
        self.rpcAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpcAddress(&mut self) -> &mut ::std::string::String {
        if self.rpcAddress.is_none() {
            self.rpcAddress.set_default();
        }
        self.rpcAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_rpcAddress(&mut self) -> ::std::string::String {
        self.rpcAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string httpAddress = 2;


    pub fn get_httpAddress(&self) -> &str {
        match self.httpAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_httpAddress(&mut self) {
        self.httpAddress.clear();
    }

    pub fn has_httpAddress(&self) -> bool {
        self.httpAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpAddress(&mut self, v: ::std::string::String) {
        self.httpAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_httpAddress(&mut self) -> &mut ::std::string::String {
        if self.httpAddress.is_none() {
            self.httpAddress.set_default();
        }
        self.httpAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_httpAddress(&mut self) -> ::std::string::String {
        self.httpAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 3;


    pub fn get_storageInfo(&self) -> &StorageInfoProto {
        self.storageInfo.as_ref().unwrap_or_else(|| StorageInfoProto::default_instance())
    }
    pub fn clear_storageInfo(&mut self) {
        self.storageInfo.clear();
    }

    pub fn has_storageInfo(&self) -> bool {
        self.storageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageInfo(&mut self, v: StorageInfoProto) {
        self.storageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageInfo(&mut self) -> &mut StorageInfoProto {
        if self.storageInfo.is_none() {
            self.storageInfo.set_default();
        }
        self.storageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageInfo(&mut self) -> StorageInfoProto {
        self.storageInfo.take().unwrap_or_else(|| StorageInfoProto::new())
    }

    // optional .hadoop.hdfs.NamenodeRegistrationProto.NamenodeRoleProto role = 4;


    pub fn get_role(&self) -> NamenodeRegistrationProto_NamenodeRoleProto {
        self.role.unwrap_or(NamenodeRegistrationProto_NamenodeRoleProto::NAMENODE)
    }
    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: NamenodeRegistrationProto_NamenodeRoleProto) {
        self.role = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NamenodeRegistrationProto {
    fn is_initialized(&self) -> bool {
        if self.rpcAddress.is_none() {
            return false;
        }
        if self.httpAddress.is_none() {
            return false;
        }
        if self.storageInfo.is_none() {
            return false;
        }
        for v in &self.storageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rpcAddress)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.httpAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageInfo)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.role, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rpcAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.httpAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rpcAddress.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.httpAddress.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.role {
            os.write_enum(4, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamenodeRegistrationProto {
        NamenodeRegistrationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rpcAddress",
                    |m: &NamenodeRegistrationProto| { &m.rpcAddress },
                    |m: &mut NamenodeRegistrationProto| { &mut m.rpcAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "httpAddress",
                    |m: &NamenodeRegistrationProto| { &m.httpAddress },
                    |m: &mut NamenodeRegistrationProto| { &mut m.httpAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageInfoProto>>(
                    "storageInfo",
                    |m: &NamenodeRegistrationProto| { &m.storageInfo },
                    |m: &mut NamenodeRegistrationProto| { &mut m.storageInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamenodeRegistrationProto_NamenodeRoleProto>>(
                    "role",
                    |m: &NamenodeRegistrationProto| { &m.role },
                    |m: &mut NamenodeRegistrationProto| { &mut m.role },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamenodeRegistrationProto>(
                    "NamenodeRegistrationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamenodeRegistrationProto {
        static mut instance: ::protobuf::lazy::Lazy<NamenodeRegistrationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamenodeRegistrationProto,
        };
        unsafe {
            instance.get(NamenodeRegistrationProto::new)
        }
    }
}

impl ::protobuf::Clear for NamenodeRegistrationProto {
    fn clear(&mut self) {
        self.rpcAddress.clear();
        self.httpAddress.clear();
        self.storageInfo.clear();
        self.role = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamenodeRegistrationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamenodeRegistrationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NamenodeRegistrationProto_NamenodeRoleProto {
    NAMENODE = 1,
    BACKUP = 2,
    CHECKPOINT = 3,
}

impl ::protobuf::ProtobufEnum for NamenodeRegistrationProto_NamenodeRoleProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NamenodeRegistrationProto_NamenodeRoleProto> {
        match value {
            1 => ::std::option::Option::Some(NamenodeRegistrationProto_NamenodeRoleProto::NAMENODE),
            2 => ::std::option::Option::Some(NamenodeRegistrationProto_NamenodeRoleProto::BACKUP),
            3 => ::std::option::Option::Some(NamenodeRegistrationProto_NamenodeRoleProto::CHECKPOINT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NamenodeRegistrationProto_NamenodeRoleProto] = &[
            NamenodeRegistrationProto_NamenodeRoleProto::NAMENODE,
            NamenodeRegistrationProto_NamenodeRoleProto::BACKUP,
            NamenodeRegistrationProto_NamenodeRoleProto::CHECKPOINT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NamenodeRegistrationProto_NamenodeRoleProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NamenodeRegistrationProto_NamenodeRoleProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NamenodeRegistrationProto_NamenodeRoleProto {
    fn default() -> Self {
        NamenodeRegistrationProto_NamenodeRoleProto::NAMENODE
    }
}

impl ::protobuf::reflect::ProtobufValue for NamenodeRegistrationProto_NamenodeRoleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckpointSignatureProto {
    // message fields
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    mostRecentCheckpointTxId: ::std::option::Option<u64>,
    curSegmentTxId: ::std::option::Option<u64>,
    storageInfo: ::protobuf::SingularPtrField<StorageInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckpointSignatureProto {
    fn default() -> &'a CheckpointSignatureProto {
        <CheckpointSignatureProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckpointSignatureProto {
    pub fn new() -> CheckpointSignatureProto {
        ::std::default::Default::default()
    }

    // required string blockPoolId = 1;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint64 mostRecentCheckpointTxId = 2;


    pub fn get_mostRecentCheckpointTxId(&self) -> u64 {
        self.mostRecentCheckpointTxId.unwrap_or(0)
    }
    pub fn clear_mostRecentCheckpointTxId(&mut self) {
        self.mostRecentCheckpointTxId = ::std::option::Option::None;
    }

    pub fn has_mostRecentCheckpointTxId(&self) -> bool {
        self.mostRecentCheckpointTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mostRecentCheckpointTxId(&mut self, v: u64) {
        self.mostRecentCheckpointTxId = ::std::option::Option::Some(v);
    }

    // required uint64 curSegmentTxId = 3;


    pub fn get_curSegmentTxId(&self) -> u64 {
        self.curSegmentTxId.unwrap_or(0)
    }
    pub fn clear_curSegmentTxId(&mut self) {
        self.curSegmentTxId = ::std::option::Option::None;
    }

    pub fn has_curSegmentTxId(&self) -> bool {
        self.curSegmentTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curSegmentTxId(&mut self, v: u64) {
        self.curSegmentTxId = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;


    pub fn get_storageInfo(&self) -> &StorageInfoProto {
        self.storageInfo.as_ref().unwrap_or_else(|| StorageInfoProto::default_instance())
    }
    pub fn clear_storageInfo(&mut self) {
        self.storageInfo.clear();
    }

    pub fn has_storageInfo(&self) -> bool {
        self.storageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageInfo(&mut self, v: StorageInfoProto) {
        self.storageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageInfo(&mut self) -> &mut StorageInfoProto {
        if self.storageInfo.is_none() {
            self.storageInfo.set_default();
        }
        self.storageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageInfo(&mut self) -> StorageInfoProto {
        self.storageInfo.take().unwrap_or_else(|| StorageInfoProto::new())
    }
}

impl ::protobuf::Message for CheckpointSignatureProto {
    fn is_initialized(&self) -> bool {
        if self.blockPoolId.is_none() {
            return false;
        }
        if self.mostRecentCheckpointTxId.is_none() {
            return false;
        }
        if self.curSegmentTxId.is_none() {
            return false;
        }
        if self.storageInfo.is_none() {
            return false;
        }
        for v in &self.storageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.mostRecentCheckpointTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.curSegmentTxId = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mostRecentCheckpointTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.curSegmentTxId {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mostRecentCheckpointTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.curSegmentTxId {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckpointSignatureProto {
        CheckpointSignatureProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockPoolId",
                    |m: &CheckpointSignatureProto| { &m.blockPoolId },
                    |m: &mut CheckpointSignatureProto| { &mut m.blockPoolId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "mostRecentCheckpointTxId",
                    |m: &CheckpointSignatureProto| { &m.mostRecentCheckpointTxId },
                    |m: &mut CheckpointSignatureProto| { &mut m.mostRecentCheckpointTxId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "curSegmentTxId",
                    |m: &CheckpointSignatureProto| { &m.curSegmentTxId },
                    |m: &mut CheckpointSignatureProto| { &mut m.curSegmentTxId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageInfoProto>>(
                    "storageInfo",
                    |m: &CheckpointSignatureProto| { &m.storageInfo },
                    |m: &mut CheckpointSignatureProto| { &mut m.storageInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckpointSignatureProto>(
                    "CheckpointSignatureProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CheckpointSignatureProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckpointSignatureProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckpointSignatureProto,
        };
        unsafe {
            instance.get(CheckpointSignatureProto::new)
        }
    }
}

impl ::protobuf::Clear for CheckpointSignatureProto {
    fn clear(&mut self) {
        self.blockPoolId.clear();
        self.mostRecentCheckpointTxId = ::std::option::Option::None;
        self.curSegmentTxId = ::std::option::Option::None;
        self.storageInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckpointSignatureProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckpointSignatureProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamenodeCommandProto {
    // message fields
    action: ::std::option::Option<u32>,
    field_type: ::std::option::Option<NamenodeCommandProto_Type>,
    checkpointCmd: ::protobuf::SingularPtrField<CheckpointCommandProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamenodeCommandProto {
    fn default() -> &'a NamenodeCommandProto {
        <NamenodeCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl NamenodeCommandProto {
    pub fn new() -> NamenodeCommandProto {
        ::std::default::Default::default()
    }

    // required uint32 action = 1;


    pub fn get_action(&self) -> u32 {
        self.action.unwrap_or(0)
    }
    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: u32) {
        self.action = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.NamenodeCommandProto.Type type = 2;


    pub fn get_field_type(&self) -> NamenodeCommandProto_Type {
        self.field_type.unwrap_or(NamenodeCommandProto_Type::NamenodeCommand)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: NamenodeCommandProto_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .hadoop.hdfs.CheckpointCommandProto checkpointCmd = 3;


    pub fn get_checkpointCmd(&self) -> &CheckpointCommandProto {
        self.checkpointCmd.as_ref().unwrap_or_else(|| CheckpointCommandProto::default_instance())
    }
    pub fn clear_checkpointCmd(&mut self) {
        self.checkpointCmd.clear();
    }

    pub fn has_checkpointCmd(&self) -> bool {
        self.checkpointCmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpointCmd(&mut self, v: CheckpointCommandProto) {
        self.checkpointCmd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkpointCmd(&mut self) -> &mut CheckpointCommandProto {
        if self.checkpointCmd.is_none() {
            self.checkpointCmd.set_default();
        }
        self.checkpointCmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_checkpointCmd(&mut self) -> CheckpointCommandProto {
        self.checkpointCmd.take().unwrap_or_else(|| CheckpointCommandProto::new())
    }
}

impl ::protobuf::Message for NamenodeCommandProto {
    fn is_initialized(&self) -> bool {
        if self.action.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        for v in &self.checkpointCmd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.action = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkpointCmd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(ref v) = self.checkpointCmd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, v.value())?;
        }
        if let Some(ref v) = self.checkpointCmd.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamenodeCommandProto {
        NamenodeCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "action",
                    |m: &NamenodeCommandProto| { &m.action },
                    |m: &mut NamenodeCommandProto| { &mut m.action },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NamenodeCommandProto_Type>>(
                    "type",
                    |m: &NamenodeCommandProto| { &m.field_type },
                    |m: &mut NamenodeCommandProto| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckpointCommandProto>>(
                    "checkpointCmd",
                    |m: &NamenodeCommandProto| { &m.checkpointCmd },
                    |m: &mut NamenodeCommandProto| { &mut m.checkpointCmd },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamenodeCommandProto>(
                    "NamenodeCommandProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamenodeCommandProto {
        static mut instance: ::protobuf::lazy::Lazy<NamenodeCommandProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamenodeCommandProto,
        };
        unsafe {
            instance.get(NamenodeCommandProto::new)
        }
    }
}

impl ::protobuf::Clear for NamenodeCommandProto {
    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.checkpointCmd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamenodeCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamenodeCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NamenodeCommandProto_Type {
    NamenodeCommand = 0,
    CheckPointCommand = 1,
}

impl ::protobuf::ProtobufEnum for NamenodeCommandProto_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NamenodeCommandProto_Type> {
        match value {
            0 => ::std::option::Option::Some(NamenodeCommandProto_Type::NamenodeCommand),
            1 => ::std::option::Option::Some(NamenodeCommandProto_Type::CheckPointCommand),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NamenodeCommandProto_Type] = &[
            NamenodeCommandProto_Type::NamenodeCommand,
            NamenodeCommandProto_Type::CheckPointCommand,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NamenodeCommandProto_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NamenodeCommandProto_Type {
}

impl ::std::default::Default for NamenodeCommandProto_Type {
    fn default() -> Self {
        NamenodeCommandProto_Type::NamenodeCommand
    }
}

impl ::protobuf::reflect::ProtobufValue for NamenodeCommandProto_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckpointCommandProto {
    // message fields
    signature: ::protobuf::SingularPtrField<CheckpointSignatureProto>,
    needToReturnImage: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckpointCommandProto {
    fn default() -> &'a CheckpointCommandProto {
        <CheckpointCommandProto as ::protobuf::Message>::default_instance()
    }
}

impl CheckpointCommandProto {
    pub fn new() -> CheckpointCommandProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;


    pub fn get_signature(&self) -> &CheckpointSignatureProto {
        self.signature.as_ref().unwrap_or_else(|| CheckpointSignatureProto::default_instance())
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: CheckpointSignatureProto) {
        self.signature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut CheckpointSignatureProto {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> CheckpointSignatureProto {
        self.signature.take().unwrap_or_else(|| CheckpointSignatureProto::new())
    }

    // required bool needToReturnImage = 2;


    pub fn get_needToReturnImage(&self) -> bool {
        self.needToReturnImage.unwrap_or(false)
    }
    pub fn clear_needToReturnImage(&mut self) {
        self.needToReturnImage = ::std::option::Option::None;
    }

    pub fn has_needToReturnImage(&self) -> bool {
        self.needToReturnImage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needToReturnImage(&mut self, v: bool) {
        self.needToReturnImage = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CheckpointCommandProto {
    fn is_initialized(&self) -> bool {
        if self.signature.is_none() {
            return false;
        }
        if self.needToReturnImage.is_none() {
            return false;
        }
        for v in &self.signature {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needToReturnImage = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.needToReturnImage {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.needToReturnImage {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckpointCommandProto {
        CheckpointCommandProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CheckpointSignatureProto>>(
                    "signature",
                    |m: &CheckpointCommandProto| { &m.signature },
                    |m: &mut CheckpointCommandProto| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needToReturnImage",
                    |m: &CheckpointCommandProto| { &m.needToReturnImage },
                    |m: &mut CheckpointCommandProto| { &mut m.needToReturnImage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CheckpointCommandProto>(
                    "CheckpointCommandProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CheckpointCommandProto {
        static mut instance: ::protobuf::lazy::Lazy<CheckpointCommandProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CheckpointCommandProto,
        };
        unsafe {
            instance.get(CheckpointCommandProto::new)
        }
    }
}

impl ::protobuf::Clear for CheckpointCommandProto {
    fn clear(&mut self) {
        self.signature.clear();
        self.needToReturnImage = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckpointCommandProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckpointCommandProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockProto {
    // message fields
    blockId: ::std::option::Option<u64>,
    genStamp: ::std::option::Option<u64>,
    numBytes: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockProto {
    fn default() -> &'a BlockProto {
        <BlockProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockProto {
    pub fn new() -> BlockProto {
        ::std::default::Default::default()
    }

    // required uint64 blockId = 1;


    pub fn get_blockId(&self) -> u64 {
        self.blockId.unwrap_or(0)
    }
    pub fn clear_blockId(&mut self) {
        self.blockId = ::std::option::Option::None;
    }

    pub fn has_blockId(&self) -> bool {
        self.blockId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockId(&mut self, v: u64) {
        self.blockId = ::std::option::Option::Some(v);
    }

    // required uint64 genStamp = 2;


    pub fn get_genStamp(&self) -> u64 {
        self.genStamp.unwrap_or(0)
    }
    pub fn clear_genStamp(&mut self) {
        self.genStamp = ::std::option::Option::None;
    }

    pub fn has_genStamp(&self) -> bool {
        self.genStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_genStamp(&mut self, v: u64) {
        self.genStamp = ::std::option::Option::Some(v);
    }

    // optional uint64 numBytes = 3;


    pub fn get_numBytes(&self) -> u64 {
        self.numBytes.unwrap_or(0u64)
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = ::std::option::Option::None;
    }

    pub fn has_numBytes(&self) -> bool {
        self.numBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: u64) {
        self.numBytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlockProto {
    fn is_initialized(&self) -> bool {
        if self.blockId.is_none() {
            return false;
        }
        if self.genStamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.genStamp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.numBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.blockId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.genStamp {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.numBytes {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.blockId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.genStamp {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.numBytes {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockProto {
        BlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockId",
                    |m: &BlockProto| { &m.blockId },
                    |m: &mut BlockProto| { &mut m.blockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "genStamp",
                    |m: &BlockProto| { &m.genStamp },
                    |m: &mut BlockProto| { &mut m.genStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "numBytes",
                    |m: &BlockProto| { &m.numBytes },
                    |m: &mut BlockProto| { &mut m.numBytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockProto>(
                    "BlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockProto {
        static mut instance: ::protobuf::lazy::Lazy<BlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockProto,
        };
        unsafe {
            instance.get(BlockProto::new)
        }
    }
}

impl ::protobuf::Clear for BlockProto {
    fn clear(&mut self) {
        self.blockId = ::std::option::Option::None;
        self.genStamp = ::std::option::Option::None;
        self.numBytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockWithLocationsProto {
    // message fields
    block: ::protobuf::SingularPtrField<BlockProto>,
    datanodeUuids: ::protobuf::RepeatedField<::std::string::String>,
    storageUuids: ::protobuf::RepeatedField<::std::string::String>,
    storageTypes: ::std::vec::Vec<StorageTypeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockWithLocationsProto {
    fn default() -> &'a BlockWithLocationsProto {
        <BlockWithLocationsProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockWithLocationsProto {
    pub fn new() -> BlockWithLocationsProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.BlockProto block = 1;


    pub fn get_block(&self) -> &BlockProto {
        self.block.as_ref().unwrap_or_else(|| BlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: BlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut BlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> BlockProto {
        self.block.take().unwrap_or_else(|| BlockProto::new())
    }

    // repeated string datanodeUuids = 2;


    pub fn get_datanodeUuids(&self) -> &[::std::string::String] {
        &self.datanodeUuids
    }
    pub fn clear_datanodeUuids(&mut self) {
        self.datanodeUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_datanodeUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.datanodeUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datanodeUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.datanodeUuids
    }

    // Take field
    pub fn take_datanodeUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.datanodeUuids, ::protobuf::RepeatedField::new())
    }

    // repeated string storageUuids = 3;


    pub fn get_storageUuids(&self) -> &[::std::string::String] {
        &self.storageUuids
    }
    pub fn clear_storageUuids(&mut self) {
        self.storageUuids.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageUuids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.storageUuids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageUuids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.storageUuids
    }

    // Take field
    pub fn take_storageUuids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.storageUuids, ::protobuf::RepeatedField::new())
    }

    // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 4;


    pub fn get_storageTypes(&self) -> &[StorageTypeProto] {
        &self.storageTypes
    }
    pub fn clear_storageTypes(&mut self) {
        self.storageTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_storageTypes(&mut self, v: ::std::vec::Vec<StorageTypeProto>) {
        self.storageTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_storageTypes(&mut self) -> &mut ::std::vec::Vec<StorageTypeProto> {
        &mut self.storageTypes
    }

    // Take field
    pub fn take_storageTypes(&mut self) -> ::std::vec::Vec<StorageTypeProto> {
        ::std::mem::replace(&mut self.storageTypes, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockWithLocationsProto {
    fn is_initialized(&self) -> bool {
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.datanodeUuids)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.storageUuids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.storageTypes, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.datanodeUuids {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.storageUuids {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.storageTypes {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.datanodeUuids {
            os.write_string(2, &v)?;
        };
        for v in &self.storageUuids {
            os.write_string(3, &v)?;
        };
        for v in &self.storageTypes {
            os.write_enum(4, v.value())?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockWithLocationsProto {
        BlockWithLocationsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockProto>>(
                    "block",
                    |m: &BlockWithLocationsProto| { &m.block },
                    |m: &mut BlockWithLocationsProto| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "datanodeUuids",
                    |m: &BlockWithLocationsProto| { &m.datanodeUuids },
                    |m: &mut BlockWithLocationsProto| { &mut m.datanodeUuids },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageUuids",
                    |m: &BlockWithLocationsProto| { &m.storageUuids },
                    |m: &mut BlockWithLocationsProto| { &mut m.storageUuids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StorageTypeProto>>(
                    "storageTypes",
                    |m: &BlockWithLocationsProto| { &m.storageTypes },
                    |m: &mut BlockWithLocationsProto| { &mut m.storageTypes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockWithLocationsProto>(
                    "BlockWithLocationsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockWithLocationsProto {
        static mut instance: ::protobuf::lazy::Lazy<BlockWithLocationsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockWithLocationsProto,
        };
        unsafe {
            instance.get(BlockWithLocationsProto::new)
        }
    }
}

impl ::protobuf::Clear for BlockWithLocationsProto {
    fn clear(&mut self) {
        self.block.clear();
        self.datanodeUuids.clear();
        self.storageUuids.clear();
        self.storageTypes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockWithLocationsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockWithLocationsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlocksWithLocationsProto {
    // message fields
    blocks: ::protobuf::RepeatedField<BlockWithLocationsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlocksWithLocationsProto {
    fn default() -> &'a BlocksWithLocationsProto {
        <BlocksWithLocationsProto as ::protobuf::Message>::default_instance()
    }
}

impl BlocksWithLocationsProto {
    pub fn new() -> BlocksWithLocationsProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.BlockWithLocationsProto blocks = 1;


    pub fn get_blocks(&self) -> &[BlockWithLocationsProto] {
        &self.blocks
    }
    pub fn clear_blocks(&mut self) {
        self.blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blocks(&mut self, v: ::protobuf::RepeatedField<BlockWithLocationsProto>) {
        self.blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blocks(&mut self) -> &mut ::protobuf::RepeatedField<BlockWithLocationsProto> {
        &mut self.blocks
    }

    // Take field
    pub fn take_blocks(&mut self) -> ::protobuf::RepeatedField<BlockWithLocationsProto> {
        ::std::mem::replace(&mut self.blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlocksWithLocationsProto {
    fn is_initialized(&self) -> bool {
        for v in &self.blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blocks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlocksWithLocationsProto {
        BlocksWithLocationsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockWithLocationsProto>>(
                    "blocks",
                    |m: &BlocksWithLocationsProto| { &m.blocks },
                    |m: &mut BlocksWithLocationsProto| { &mut m.blocks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlocksWithLocationsProto>(
                    "BlocksWithLocationsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlocksWithLocationsProto {
        static mut instance: ::protobuf::lazy::Lazy<BlocksWithLocationsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlocksWithLocationsProto,
        };
        unsafe {
            instance.get(BlocksWithLocationsProto::new)
        }
    }
}

impl ::protobuf::Clear for BlocksWithLocationsProto {
    fn clear(&mut self) {
        self.blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlocksWithLocationsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlocksWithLocationsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoteEditLogProto {
    // message fields
    startTxId: ::std::option::Option<u64>,
    endTxId: ::std::option::Option<u64>,
    isInProgress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteEditLogProto {
    fn default() -> &'a RemoteEditLogProto {
        <RemoteEditLogProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoteEditLogProto {
    pub fn new() -> RemoteEditLogProto {
        ::std::default::Default::default()
    }

    // required uint64 startTxId = 1;


    pub fn get_startTxId(&self) -> u64 {
        self.startTxId.unwrap_or(0)
    }
    pub fn clear_startTxId(&mut self) {
        self.startTxId = ::std::option::Option::None;
    }

    pub fn has_startTxId(&self) -> bool {
        self.startTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTxId(&mut self, v: u64) {
        self.startTxId = ::std::option::Option::Some(v);
    }

    // required uint64 endTxId = 2;


    pub fn get_endTxId(&self) -> u64 {
        self.endTxId.unwrap_or(0)
    }
    pub fn clear_endTxId(&mut self) {
        self.endTxId = ::std::option::Option::None;
    }

    pub fn has_endTxId(&self) -> bool {
        self.endTxId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endTxId(&mut self, v: u64) {
        self.endTxId = ::std::option::Option::Some(v);
    }

    // optional bool isInProgress = 3;


    pub fn get_isInProgress(&self) -> bool {
        self.isInProgress.unwrap_or(false)
    }
    pub fn clear_isInProgress(&mut self) {
        self.isInProgress = ::std::option::Option::None;
    }

    pub fn has_isInProgress(&self) -> bool {
        self.isInProgress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isInProgress(&mut self, v: bool) {
        self.isInProgress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RemoteEditLogProto {
    fn is_initialized(&self) -> bool {
        if self.startTxId.is_none() {
            return false;
        }
        if self.endTxId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startTxId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.endTxId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isInProgress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.startTxId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endTxId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.isInProgress {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.startTxId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.endTxId {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.isInProgress {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteEditLogProto {
        RemoteEditLogProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startTxId",
                    |m: &RemoteEditLogProto| { &m.startTxId },
                    |m: &mut RemoteEditLogProto| { &mut m.startTxId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "endTxId",
                    |m: &RemoteEditLogProto| { &m.endTxId },
                    |m: &mut RemoteEditLogProto| { &mut m.endTxId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isInProgress",
                    |m: &RemoteEditLogProto| { &m.isInProgress },
                    |m: &mut RemoteEditLogProto| { &mut m.isInProgress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoteEditLogProto>(
                    "RemoteEditLogProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoteEditLogProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoteEditLogProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoteEditLogProto,
        };
        unsafe {
            instance.get(RemoteEditLogProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoteEditLogProto {
    fn clear(&mut self) {
        self.startTxId = ::std::option::Option::None;
        self.endTxId = ::std::option::Option::None;
        self.isInProgress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteEditLogProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteEditLogProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoteEditLogManifestProto {
    // message fields
    logs: ::protobuf::RepeatedField<RemoteEditLogProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteEditLogManifestProto {
    fn default() -> &'a RemoteEditLogManifestProto {
        <RemoteEditLogManifestProto as ::protobuf::Message>::default_instance()
    }
}

impl RemoteEditLogManifestProto {
    pub fn new() -> RemoteEditLogManifestProto {
        ::std::default::Default::default()
    }

    // repeated .hadoop.hdfs.RemoteEditLogProto logs = 1;


    pub fn get_logs(&self) -> &[RemoteEditLogProto] {
        &self.logs
    }
    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<RemoteEditLogProto>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<RemoteEditLogProto> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<RemoteEditLogProto> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RemoteEditLogManifestProto {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.logs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteEditLogManifestProto {
        RemoteEditLogManifestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteEditLogProto>>(
                    "logs",
                    |m: &RemoteEditLogManifestProto| { &m.logs },
                    |m: &mut RemoteEditLogManifestProto| { &mut m.logs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoteEditLogManifestProto>(
                    "RemoteEditLogManifestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoteEditLogManifestProto {
        static mut instance: ::protobuf::lazy::Lazy<RemoteEditLogManifestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoteEditLogManifestProto,
        };
        unsafe {
            instance.get(RemoteEditLogManifestProto::new)
        }
    }
}

impl ::protobuf::Clear for RemoteEditLogManifestProto {
    fn clear(&mut self) {
        self.logs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteEditLogManifestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteEditLogManifestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceInfoProto {
    // message fields
    buildVersion: ::protobuf::SingularField<::std::string::String>,
    unused: ::std::option::Option<u32>,
    blockPoolID: ::protobuf::SingularField<::std::string::String>,
    storageInfo: ::protobuf::SingularPtrField<StorageInfoProto>,
    softwareVersion: ::protobuf::SingularField<::std::string::String>,
    capabilities: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceInfoProto {
    fn default() -> &'a NamespaceInfoProto {
        <NamespaceInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceInfoProto {
    pub fn new() -> NamespaceInfoProto {
        ::std::default::Default::default()
    }

    // required string buildVersion = 1;


    pub fn get_buildVersion(&self) -> &str {
        match self.buildVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_buildVersion(&mut self) {
        self.buildVersion.clear();
    }

    pub fn has_buildVersion(&self) -> bool {
        self.buildVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buildVersion(&mut self, v: ::std::string::String) {
        self.buildVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buildVersion(&mut self) -> &mut ::std::string::String {
        if self.buildVersion.is_none() {
            self.buildVersion.set_default();
        }
        self.buildVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_buildVersion(&mut self) -> ::std::string::String {
        self.buildVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required uint32 unused = 2;


    pub fn get_unused(&self) -> u32 {
        self.unused.unwrap_or(0)
    }
    pub fn clear_unused(&mut self) {
        self.unused = ::std::option::Option::None;
    }

    pub fn has_unused(&self) -> bool {
        self.unused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused(&mut self, v: u32) {
        self.unused = ::std::option::Option::Some(v);
    }

    // required string blockPoolID = 3;


    pub fn get_blockPoolID(&self) -> &str {
        match self.blockPoolID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolID(&mut self) {
        self.blockPoolID.clear();
    }

    pub fn has_blockPoolID(&self) -> bool {
        self.blockPoolID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolID(&mut self, v: ::std::string::String) {
        self.blockPoolID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolID(&mut self) -> &mut ::std::string::String {
        if self.blockPoolID.is_none() {
            self.blockPoolID.set_default();
        }
        self.blockPoolID.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolID(&mut self) -> ::std::string::String {
        self.blockPoolID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;


    pub fn get_storageInfo(&self) -> &StorageInfoProto {
        self.storageInfo.as_ref().unwrap_or_else(|| StorageInfoProto::default_instance())
    }
    pub fn clear_storageInfo(&mut self) {
        self.storageInfo.clear();
    }

    pub fn has_storageInfo(&self) -> bool {
        self.storageInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageInfo(&mut self, v: StorageInfoProto) {
        self.storageInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageInfo(&mut self) -> &mut StorageInfoProto {
        if self.storageInfo.is_none() {
            self.storageInfo.set_default();
        }
        self.storageInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageInfo(&mut self) -> StorageInfoProto {
        self.storageInfo.take().unwrap_or_else(|| StorageInfoProto::new())
    }

    // required string softwareVersion = 5;


    pub fn get_softwareVersion(&self) -> &str {
        match self.softwareVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_softwareVersion(&mut self) {
        self.softwareVersion.clear();
    }

    pub fn has_softwareVersion(&self) -> bool {
        self.softwareVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_softwareVersion(&mut self, v: ::std::string::String) {
        self.softwareVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_softwareVersion(&mut self) -> &mut ::std::string::String {
        if self.softwareVersion.is_none() {
            self.softwareVersion.set_default();
        }
        self.softwareVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_softwareVersion(&mut self) -> ::std::string::String {
        self.softwareVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 capabilities = 6;


    pub fn get_capabilities(&self) -> u64 {
        self.capabilities.unwrap_or(0u64)
    }
    pub fn clear_capabilities(&mut self) {
        self.capabilities = ::std::option::Option::None;
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: u64) {
        self.capabilities = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NamespaceInfoProto {
    fn is_initialized(&self) -> bool {
        if self.buildVersion.is_none() {
            return false;
        }
        if self.unused.is_none() {
            return false;
        }
        if self.blockPoolID.is_none() {
            return false;
        }
        if self.storageInfo.is_none() {
            return false;
        }
        if self.softwareVersion.is_none() {
            return false;
        }
        for v in &self.storageInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.buildVersion)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.unused = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageInfo)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.softwareVersion)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.capabilities = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.buildVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.unused {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.blockPoolID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.capabilities {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.buildVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.unused {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.blockPoolID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.storageInfo.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.softwareVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.capabilities {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceInfoProto {
        NamespaceInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "buildVersion",
                    |m: &NamespaceInfoProto| { &m.buildVersion },
                    |m: &mut NamespaceInfoProto| { &mut m.buildVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "unused",
                    |m: &NamespaceInfoProto| { &m.unused },
                    |m: &mut NamespaceInfoProto| { &mut m.unused },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockPoolID",
                    |m: &NamespaceInfoProto| { &m.blockPoolID },
                    |m: &mut NamespaceInfoProto| { &mut m.blockPoolID },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageInfoProto>>(
                    "storageInfo",
                    |m: &NamespaceInfoProto| { &m.storageInfo },
                    |m: &mut NamespaceInfoProto| { &mut m.storageInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "softwareVersion",
                    |m: &NamespaceInfoProto| { &m.softwareVersion },
                    |m: &mut NamespaceInfoProto| { &mut m.softwareVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "capabilities",
                    |m: &NamespaceInfoProto| { &m.capabilities },
                    |m: &mut NamespaceInfoProto| { &mut m.capabilities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamespaceInfoProto>(
                    "NamespaceInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NamespaceInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<NamespaceInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamespaceInfoProto,
        };
        unsafe {
            instance.get(NamespaceInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for NamespaceInfoProto {
    fn clear(&mut self) {
        self.buildVersion.clear();
        self.unused = ::std::option::Option::None;
        self.blockPoolID.clear();
        self.storageInfo.clear();
        self.softwareVersion.clear();
        self.capabilities = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlockKeyProto {
    // message fields
    keyId: ::std::option::Option<u32>,
    expiryDate: ::std::option::Option<u64>,
    keyBytes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockKeyProto {
    fn default() -> &'a BlockKeyProto {
        <BlockKeyProto as ::protobuf::Message>::default_instance()
    }
}

impl BlockKeyProto {
    pub fn new() -> BlockKeyProto {
        ::std::default::Default::default()
    }

    // required uint32 keyId = 1;


    pub fn get_keyId(&self) -> u32 {
        self.keyId.unwrap_or(0)
    }
    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: u32) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // required uint64 expiryDate = 2;


    pub fn get_expiryDate(&self) -> u64 {
        self.expiryDate.unwrap_or(0)
    }
    pub fn clear_expiryDate(&mut self) {
        self.expiryDate = ::std::option::Option::None;
    }

    pub fn has_expiryDate(&self) -> bool {
        self.expiryDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiryDate(&mut self, v: u64) {
        self.expiryDate = ::std::option::Option::Some(v);
    }

    // optional bytes keyBytes = 3;


    pub fn get_keyBytes(&self) -> &[u8] {
        match self.keyBytes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_keyBytes(&mut self) {
        self.keyBytes.clear();
    }

    pub fn has_keyBytes(&self) -> bool {
        self.keyBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyBytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.keyBytes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyBytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.keyBytes.is_none() {
            self.keyBytes.set_default();
        }
        self.keyBytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyBytes(&mut self) -> ::std::vec::Vec<u8> {
        self.keyBytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for BlockKeyProto {
    fn is_initialized(&self) -> bool {
        if self.keyId.is_none() {
            return false;
        }
        if self.expiryDate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.keyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expiryDate = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.keyBytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.keyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.expiryDate {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.keyBytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.keyId {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiryDate {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.keyBytes.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockKeyProto {
        BlockKeyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "keyId",
                    |m: &BlockKeyProto| { &m.keyId },
                    |m: &mut BlockKeyProto| { &mut m.keyId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "expiryDate",
                    |m: &BlockKeyProto| { &m.expiryDate },
                    |m: &mut BlockKeyProto| { &mut m.expiryDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "keyBytes",
                    |m: &BlockKeyProto| { &m.keyBytes },
                    |m: &mut BlockKeyProto| { &mut m.keyBytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BlockKeyProto>(
                    "BlockKeyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockKeyProto {
        static mut instance: ::protobuf::lazy::Lazy<BlockKeyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BlockKeyProto,
        };
        unsafe {
            instance.get(BlockKeyProto::new)
        }
    }
}

impl ::protobuf::Clear for BlockKeyProto {
    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.expiryDate = ::std::option::Option::None;
        self.keyBytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockKeyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockKeyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportedBlockKeysProto {
    // message fields
    isBlockTokenEnabled: ::std::option::Option<bool>,
    keyUpdateInterval: ::std::option::Option<u64>,
    tokenLifeTime: ::std::option::Option<u64>,
    currentKey: ::protobuf::SingularPtrField<BlockKeyProto>,
    allKeys: ::protobuf::RepeatedField<BlockKeyProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportedBlockKeysProto {
    fn default() -> &'a ExportedBlockKeysProto {
        <ExportedBlockKeysProto as ::protobuf::Message>::default_instance()
    }
}

impl ExportedBlockKeysProto {
    pub fn new() -> ExportedBlockKeysProto {
        ::std::default::Default::default()
    }

    // required bool isBlockTokenEnabled = 1;


    pub fn get_isBlockTokenEnabled(&self) -> bool {
        self.isBlockTokenEnabled.unwrap_or(false)
    }
    pub fn clear_isBlockTokenEnabled(&mut self) {
        self.isBlockTokenEnabled = ::std::option::Option::None;
    }

    pub fn has_isBlockTokenEnabled(&self) -> bool {
        self.isBlockTokenEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isBlockTokenEnabled(&mut self, v: bool) {
        self.isBlockTokenEnabled = ::std::option::Option::Some(v);
    }

    // required uint64 keyUpdateInterval = 2;


    pub fn get_keyUpdateInterval(&self) -> u64 {
        self.keyUpdateInterval.unwrap_or(0)
    }
    pub fn clear_keyUpdateInterval(&mut self) {
        self.keyUpdateInterval = ::std::option::Option::None;
    }

    pub fn has_keyUpdateInterval(&self) -> bool {
        self.keyUpdateInterval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyUpdateInterval(&mut self, v: u64) {
        self.keyUpdateInterval = ::std::option::Option::Some(v);
    }

    // required uint64 tokenLifeTime = 3;


    pub fn get_tokenLifeTime(&self) -> u64 {
        self.tokenLifeTime.unwrap_or(0)
    }
    pub fn clear_tokenLifeTime(&mut self) {
        self.tokenLifeTime = ::std::option::Option::None;
    }

    pub fn has_tokenLifeTime(&self) -> bool {
        self.tokenLifeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokenLifeTime(&mut self, v: u64) {
        self.tokenLifeTime = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.BlockKeyProto currentKey = 4;


    pub fn get_currentKey(&self) -> &BlockKeyProto {
        self.currentKey.as_ref().unwrap_or_else(|| BlockKeyProto::default_instance())
    }
    pub fn clear_currentKey(&mut self) {
        self.currentKey.clear();
    }

    pub fn has_currentKey(&self) -> bool {
        self.currentKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currentKey(&mut self, v: BlockKeyProto) {
        self.currentKey = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currentKey(&mut self) -> &mut BlockKeyProto {
        if self.currentKey.is_none() {
            self.currentKey.set_default();
        }
        self.currentKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_currentKey(&mut self) -> BlockKeyProto {
        self.currentKey.take().unwrap_or_else(|| BlockKeyProto::new())
    }

    // repeated .hadoop.hdfs.BlockKeyProto allKeys = 5;


    pub fn get_allKeys(&self) -> &[BlockKeyProto] {
        &self.allKeys
    }
    pub fn clear_allKeys(&mut self) {
        self.allKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_allKeys(&mut self, v: ::protobuf::RepeatedField<BlockKeyProto>) {
        self.allKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allKeys(&mut self) -> &mut ::protobuf::RepeatedField<BlockKeyProto> {
        &mut self.allKeys
    }

    // Take field
    pub fn take_allKeys(&mut self) -> ::protobuf::RepeatedField<BlockKeyProto> {
        ::std::mem::replace(&mut self.allKeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExportedBlockKeysProto {
    fn is_initialized(&self) -> bool {
        if self.isBlockTokenEnabled.is_none() {
            return false;
        }
        if self.keyUpdateInterval.is_none() {
            return false;
        }
        if self.tokenLifeTime.is_none() {
            return false;
        }
        if self.currentKey.is_none() {
            return false;
        }
        for v in &self.currentKey {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allKeys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isBlockTokenEnabled = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.keyUpdateInterval = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.tokenLifeTime = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.currentKey)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allKeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.isBlockTokenEnabled {
            my_size += 2;
        }
        if let Some(v) = self.keyUpdateInterval {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.tokenLifeTime {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.currentKey.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.allKeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.isBlockTokenEnabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.keyUpdateInterval {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tokenLifeTime {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.currentKey.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.allKeys {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportedBlockKeysProto {
        ExportedBlockKeysProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isBlockTokenEnabled",
                    |m: &ExportedBlockKeysProto| { &m.isBlockTokenEnabled },
                    |m: &mut ExportedBlockKeysProto| { &mut m.isBlockTokenEnabled },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "keyUpdateInterval",
                    |m: &ExportedBlockKeysProto| { &m.keyUpdateInterval },
                    |m: &mut ExportedBlockKeysProto| { &mut m.keyUpdateInterval },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "tokenLifeTime",
                    |m: &ExportedBlockKeysProto| { &m.tokenLifeTime },
                    |m: &mut ExportedBlockKeysProto| { &mut m.tokenLifeTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockKeyProto>>(
                    "currentKey",
                    |m: &ExportedBlockKeysProto| { &m.currentKey },
                    |m: &mut ExportedBlockKeysProto| { &mut m.currentKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockKeyProto>>(
                    "allKeys",
                    |m: &ExportedBlockKeysProto| { &m.allKeys },
                    |m: &mut ExportedBlockKeysProto| { &mut m.allKeys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExportedBlockKeysProto>(
                    "ExportedBlockKeysProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExportedBlockKeysProto {
        static mut instance: ::protobuf::lazy::Lazy<ExportedBlockKeysProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExportedBlockKeysProto,
        };
        unsafe {
            instance.get(ExportedBlockKeysProto::new)
        }
    }
}

impl ::protobuf::Clear for ExportedBlockKeysProto {
    fn clear(&mut self) {
        self.isBlockTokenEnabled = ::std::option::Option::None;
        self.keyUpdateInterval = ::std::option::Option::None;
        self.tokenLifeTime = ::std::option::Option::None;
        self.currentKey.clear();
        self.allKeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportedBlockKeysProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportedBlockKeysProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecoveringBlockProto {
    // message fields
    newGenStamp: ::std::option::Option<u64>,
    block: ::protobuf::SingularPtrField<LocatedBlockProto>,
    truncateBlock: ::protobuf::SingularPtrField<BlockProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecoveringBlockProto {
    fn default() -> &'a RecoveringBlockProto {
        <RecoveringBlockProto as ::protobuf::Message>::default_instance()
    }
}

impl RecoveringBlockProto {
    pub fn new() -> RecoveringBlockProto {
        ::std::default::Default::default()
    }

    // required uint64 newGenStamp = 1;


    pub fn get_newGenStamp(&self) -> u64 {
        self.newGenStamp.unwrap_or(0)
    }
    pub fn clear_newGenStamp(&mut self) {
        self.newGenStamp = ::std::option::Option::None;
    }

    pub fn has_newGenStamp(&self) -> bool {
        self.newGenStamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_newGenStamp(&mut self, v: u64) {
        self.newGenStamp = ::std::option::Option::Some(v);
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 2;


    pub fn get_block(&self) -> &LocatedBlockProto {
        self.block.as_ref().unwrap_or_else(|| LocatedBlockProto::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: LocatedBlockProto) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut LocatedBlockProto {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> LocatedBlockProto {
        self.block.take().unwrap_or_else(|| LocatedBlockProto::new())
    }

    // optional .hadoop.hdfs.BlockProto truncateBlock = 3;


    pub fn get_truncateBlock(&self) -> &BlockProto {
        self.truncateBlock.as_ref().unwrap_or_else(|| BlockProto::default_instance())
    }
    pub fn clear_truncateBlock(&mut self) {
        self.truncateBlock.clear();
    }

    pub fn has_truncateBlock(&self) -> bool {
        self.truncateBlock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_truncateBlock(&mut self, v: BlockProto) {
        self.truncateBlock = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_truncateBlock(&mut self) -> &mut BlockProto {
        if self.truncateBlock.is_none() {
            self.truncateBlock.set_default();
        }
        self.truncateBlock.as_mut().unwrap()
    }

    // Take field
    pub fn take_truncateBlock(&mut self) -> BlockProto {
        self.truncateBlock.take().unwrap_or_else(|| BlockProto::new())
    }
}

impl ::protobuf::Message for RecoveringBlockProto {
    fn is_initialized(&self) -> bool {
        if self.newGenStamp.is_none() {
            return false;
        }
        if self.block.is_none() {
            return false;
        }
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.truncateBlock {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.newGenStamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.truncateBlock)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.newGenStamp {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.truncateBlock.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.newGenStamp {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.truncateBlock.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecoveringBlockProto {
        RecoveringBlockProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "newGenStamp",
                    |m: &RecoveringBlockProto| { &m.newGenStamp },
                    |m: &mut RecoveringBlockProto| { &mut m.newGenStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocatedBlockProto>>(
                    "block",
                    |m: &RecoveringBlockProto| { &m.block },
                    |m: &mut RecoveringBlockProto| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlockProto>>(
                    "truncateBlock",
                    |m: &RecoveringBlockProto| { &m.truncateBlock },
                    |m: &mut RecoveringBlockProto| { &mut m.truncateBlock },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RecoveringBlockProto>(
                    "RecoveringBlockProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RecoveringBlockProto {
        static mut instance: ::protobuf::lazy::Lazy<RecoveringBlockProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RecoveringBlockProto,
        };
        unsafe {
            instance.get(RecoveringBlockProto::new)
        }
    }
}

impl ::protobuf::Clear for RecoveringBlockProto {
    fn clear(&mut self) {
        self.newGenStamp = ::std::option::Option::None;
        self.block.clear();
        self.truncateBlock.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecoveringBlockProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecoveringBlockProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionRequestProto {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionRequestProto {
    fn default() -> &'a VersionRequestProto {
        <VersionRequestProto as ::protobuf::Message>::default_instance()
    }
}

impl VersionRequestProto {
    pub fn new() -> VersionRequestProto {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VersionRequestProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionRequestProto {
        VersionRequestProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<VersionRequestProto>(
                    "VersionRequestProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VersionRequestProto {
        static mut instance: ::protobuf::lazy::Lazy<VersionRequestProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VersionRequestProto,
        };
        unsafe {
            instance.get(VersionRequestProto::new)
        }
    }
}

impl ::protobuf::Clear for VersionRequestProto {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionRequestProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionRequestProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionResponseProto {
    // message fields
    info: ::protobuf::SingularPtrField<NamespaceInfoProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionResponseProto {
    fn default() -> &'a VersionResponseProto {
        <VersionResponseProto as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponseProto {
    pub fn new() -> VersionResponseProto {
        ::std::default::Default::default()
    }

    // required .hadoop.hdfs.NamespaceInfoProto info = 1;


    pub fn get_info(&self) -> &NamespaceInfoProto {
        self.info.as_ref().unwrap_or_else(|| NamespaceInfoProto::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: NamespaceInfoProto) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut NamespaceInfoProto {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> NamespaceInfoProto {
        self.info.take().unwrap_or_else(|| NamespaceInfoProto::new())
    }
}

impl ::protobuf::Message for VersionResponseProto {
    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionResponseProto {
        VersionResponseProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceInfoProto>>(
                    "info",
                    |m: &VersionResponseProto| { &m.info },
                    |m: &mut VersionResponseProto| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VersionResponseProto>(
                    "VersionResponseProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VersionResponseProto {
        static mut instance: ::protobuf::lazy::Lazy<VersionResponseProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VersionResponseProto,
        };
        unsafe {
            instance.get(VersionResponseProto::new)
        }
    }
}

impl ::protobuf::Clear for VersionResponseProto {
    fn clear(&mut self) {
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionResponseProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponseProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SnapshotInfoProto {
    // message fields
    snapshotName: ::protobuf::SingularField<::std::string::String>,
    snapshotRoot: ::protobuf::SingularField<::std::string::String>,
    permission: ::protobuf::SingularPtrField<FsPermissionProto>,
    owner: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    createTime: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SnapshotInfoProto {
    fn default() -> &'a SnapshotInfoProto {
        <SnapshotInfoProto as ::protobuf::Message>::default_instance()
    }
}

impl SnapshotInfoProto {
    pub fn new() -> SnapshotInfoProto {
        ::std::default::Default::default()
    }

    // required string snapshotName = 1;


    pub fn get_snapshotName(&self) -> &str {
        match self.snapshotName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotName(&mut self) {
        self.snapshotName.clear();
    }

    pub fn has_snapshotName(&self) -> bool {
        self.snapshotName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotName(&mut self, v: ::std::string::String) {
        self.snapshotName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotName(&mut self) -> &mut ::std::string::String {
        if self.snapshotName.is_none() {
            self.snapshotName.set_default();
        }
        self.snapshotName.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotName(&mut self) -> ::std::string::String {
        self.snapshotName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string snapshotRoot = 2;


    pub fn get_snapshotRoot(&self) -> &str {
        match self.snapshotRoot.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_snapshotRoot(&mut self) {
        self.snapshotRoot.clear();
    }

    pub fn has_snapshotRoot(&self) -> bool {
        self.snapshotRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshotRoot(&mut self, v: ::std::string::String) {
        self.snapshotRoot = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snapshotRoot(&mut self) -> &mut ::std::string::String {
        if self.snapshotRoot.is_none() {
            self.snapshotRoot.set_default();
        }
        self.snapshotRoot.as_mut().unwrap()
    }

    // Take field
    pub fn take_snapshotRoot(&mut self) -> ::std::string::String {
        self.snapshotRoot.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 3;


    pub fn get_permission(&self) -> &FsPermissionProto {
        self.permission.as_ref().unwrap_or_else(|| FsPermissionProto::default_instance())
    }
    pub fn clear_permission(&mut self) {
        self.permission.clear();
    }

    pub fn has_permission(&self) -> bool {
        self.permission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission(&mut self, v: FsPermissionProto) {
        self.permission = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_permission(&mut self) -> &mut FsPermissionProto {
        if self.permission.is_none() {
            self.permission.set_default();
        }
        self.permission.as_mut().unwrap()
    }

    // Take field
    pub fn take_permission(&mut self) -> FsPermissionProto {
        self.permission.take().unwrap_or_else(|| FsPermissionProto::new())
    }

    // required string owner = 4;


    pub fn get_owner(&self) -> &str {
        match self.owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    pub fn has_owner(&self) -> bool {
        self.owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        if self.owner.is_none() {
            self.owner.set_default();
        }
        self.owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        self.owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string group = 5;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string createTime = 6;


    pub fn get_createTime(&self) -> &str {
        match self.createTime.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_createTime(&mut self) {
        self.createTime.clear();
    }

    pub fn has_createTime(&self) -> bool {
        self.createTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createTime(&mut self, v: ::std::string::String) {
        self.createTime = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_createTime(&mut self) -> &mut ::std::string::String {
        if self.createTime.is_none() {
            self.createTime.set_default();
        }
        self.createTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_createTime(&mut self) -> ::std::string::String {
        self.createTime.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SnapshotInfoProto {
    fn is_initialized(&self) -> bool {
        if self.snapshotName.is_none() {
            return false;
        }
        if self.snapshotRoot.is_none() {
            return false;
        }
        if self.permission.is_none() {
            return false;
        }
        if self.owner.is_none() {
            return false;
        }
        if self.group.is_none() {
            return false;
        }
        if self.createTime.is_none() {
            return false;
        }
        for v in &self.permission {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.snapshotRoot)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.permission)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.owner)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.createTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.snapshotName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.permission.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.owner.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.createTime.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.snapshotName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.snapshotRoot.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.permission.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.owner.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.createTime.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SnapshotInfoProto {
        SnapshotInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotName",
                    |m: &SnapshotInfoProto| { &m.snapshotName },
                    |m: &mut SnapshotInfoProto| { &mut m.snapshotName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "snapshotRoot",
                    |m: &SnapshotInfoProto| { &m.snapshotRoot },
                    |m: &mut SnapshotInfoProto| { &mut m.snapshotRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FsPermissionProto>>(
                    "permission",
                    |m: &SnapshotInfoProto| { &m.permission },
                    |m: &mut SnapshotInfoProto| { &mut m.permission },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "owner",
                    |m: &SnapshotInfoProto| { &m.owner },
                    |m: &mut SnapshotInfoProto| { &mut m.owner },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group",
                    |m: &SnapshotInfoProto| { &m.group },
                    |m: &mut SnapshotInfoProto| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "createTime",
                    |m: &SnapshotInfoProto| { &m.createTime },
                    |m: &mut SnapshotInfoProto| { &mut m.createTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SnapshotInfoProto>(
                    "SnapshotInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SnapshotInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<SnapshotInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SnapshotInfoProto,
        };
        unsafe {
            instance.get(SnapshotInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for SnapshotInfoProto {
    fn clear(&mut self) {
        self.snapshotName.clear();
        self.snapshotRoot.clear();
        self.permission.clear();
        self.owner.clear();
        self.group.clear();
        self.createTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SnapshotInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SnapshotInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollingUpgradeStatusProto {
    // message fields
    blockPoolId: ::protobuf::SingularField<::std::string::String>,
    finalized: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollingUpgradeStatusProto {
    fn default() -> &'a RollingUpgradeStatusProto {
        <RollingUpgradeStatusProto as ::protobuf::Message>::default_instance()
    }
}

impl RollingUpgradeStatusProto {
    pub fn new() -> RollingUpgradeStatusProto {
        ::std::default::Default::default()
    }

    // required string blockPoolId = 1;


    pub fn get_blockPoolId(&self) -> &str {
        match self.blockPoolId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blockPoolId(&mut self) {
        self.blockPoolId.clear();
    }

    pub fn has_blockPoolId(&self) -> bool {
        self.blockPoolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockPoolId(&mut self, v: ::std::string::String) {
        self.blockPoolId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockPoolId(&mut self) -> &mut ::std::string::String {
        if self.blockPoolId.is_none() {
            self.blockPoolId.set_default();
        }
        self.blockPoolId.as_mut().unwrap()
    }

    // Take field
    pub fn take_blockPoolId(&mut self) -> ::std::string::String {
        self.blockPoolId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool finalized = 2;


    pub fn get_finalized(&self) -> bool {
        self.finalized.unwrap_or(false)
    }
    pub fn clear_finalized(&mut self) {
        self.finalized = ::std::option::Option::None;
    }

    pub fn has_finalized(&self) -> bool {
        self.finalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finalized(&mut self, v: bool) {
        self.finalized = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RollingUpgradeStatusProto {
    fn is_initialized(&self) -> bool {
        if self.blockPoolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blockPoolId)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.finalized = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blockPoolId.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.finalized {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blockPoolId.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.finalized {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollingUpgradeStatusProto {
        RollingUpgradeStatusProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockPoolId",
                    |m: &RollingUpgradeStatusProto| { &m.blockPoolId },
                    |m: &mut RollingUpgradeStatusProto| { &mut m.blockPoolId },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "finalized",
                    |m: &RollingUpgradeStatusProto| { &m.finalized },
                    |m: &mut RollingUpgradeStatusProto| { &mut m.finalized },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollingUpgradeStatusProto>(
                    "RollingUpgradeStatusProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollingUpgradeStatusProto {
        static mut instance: ::protobuf::lazy::Lazy<RollingUpgradeStatusProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollingUpgradeStatusProto,
        };
        unsafe {
            instance.get(RollingUpgradeStatusProto::new)
        }
    }
}

impl ::protobuf::Clear for RollingUpgradeStatusProto {
    fn clear(&mut self) {
        self.blockPoolId.clear();
        self.finalized = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollingUpgradeStatusProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollingUpgradeStatusProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StorageTypeProto {
    DISK = 1,
    SSD = 2,
    ARCHIVE = 3,
    RAM_DISK = 4,
}

impl ::protobuf::ProtobufEnum for StorageTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StorageTypeProto> {
        match value {
            1 => ::std::option::Option::Some(StorageTypeProto::DISK),
            2 => ::std::option::Option::Some(StorageTypeProto::SSD),
            3 => ::std::option::Option::Some(StorageTypeProto::ARCHIVE),
            4 => ::std::option::Option::Some(StorageTypeProto::RAM_DISK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StorageTypeProto] = &[
            StorageTypeProto::DISK,
            StorageTypeProto::SSD,
            StorageTypeProto::ARCHIVE,
            StorageTypeProto::RAM_DISK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StorageTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StorageTypeProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for StorageTypeProto {
    fn default() -> Self {
        StorageTypeProto::DISK
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CipherSuiteProto {
    UNKNOWN = 1,
    AES_CTR_NOPADDING = 2,
}

impl ::protobuf::ProtobufEnum for CipherSuiteProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CipherSuiteProto> {
        match value {
            1 => ::std::option::Option::Some(CipherSuiteProto::UNKNOWN),
            2 => ::std::option::Option::Some(CipherSuiteProto::AES_CTR_NOPADDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CipherSuiteProto] = &[
            CipherSuiteProto::UNKNOWN,
            CipherSuiteProto::AES_CTR_NOPADDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CipherSuiteProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CipherSuiteProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CipherSuiteProto {
    fn default() -> Self {
        CipherSuiteProto::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for CipherSuiteProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CryptoProtocolVersionProto {
    UNKNOWN_PROTOCOL_VERSION = 1,
    ENCRYPTION_ZONES = 2,
}

impl ::protobuf::ProtobufEnum for CryptoProtocolVersionProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CryptoProtocolVersionProto> {
        match value {
            1 => ::std::option::Option::Some(CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION),
            2 => ::std::option::Option::Some(CryptoProtocolVersionProto::ENCRYPTION_ZONES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CryptoProtocolVersionProto] = &[
            CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION,
            CryptoProtocolVersionProto::ENCRYPTION_ZONES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CryptoProtocolVersionProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CryptoProtocolVersionProto {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CryptoProtocolVersionProto {
    fn default() -> Self {
        CryptoProtocolVersionProto::UNKNOWN_PROTOCOL_VERSION
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptoProtocolVersionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChecksumTypeProto {
    CHECKSUM_NULL = 0,
    CHECKSUM_CRC32 = 1,
    CHECKSUM_CRC32C = 2,
}

impl ::protobuf::ProtobufEnum for ChecksumTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChecksumTypeProto> {
        match value {
            0 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_NULL),
            1 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_CRC32),
            2 => ::std::option::Option::Some(ChecksumTypeProto::CHECKSUM_CRC32C),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChecksumTypeProto] = &[
            ChecksumTypeProto::CHECKSUM_NULL,
            ChecksumTypeProto::CHECKSUM_CRC32,
            ChecksumTypeProto::CHECKSUM_CRC32C,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ChecksumTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ChecksumTypeProto {
}

impl ::std::default::Default for ChecksumTypeProto {
    fn default() -> Self {
        ChecksumTypeProto::CHECKSUM_NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for ChecksumTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReplicaStateProto {
    FINALIZED = 0,
    RBW = 1,
    RWR = 2,
    RUR = 3,
    TEMPORARY = 4,
}

impl ::protobuf::ProtobufEnum for ReplicaStateProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplicaStateProto> {
        match value {
            0 => ::std::option::Option::Some(ReplicaStateProto::FINALIZED),
            1 => ::std::option::Option::Some(ReplicaStateProto::RBW),
            2 => ::std::option::Option::Some(ReplicaStateProto::RWR),
            3 => ::std::option::Option::Some(ReplicaStateProto::RUR),
            4 => ::std::option::Option::Some(ReplicaStateProto::TEMPORARY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReplicaStateProto] = &[
            ReplicaStateProto::FINALIZED,
            ReplicaStateProto::RBW,
            ReplicaStateProto::RWR,
            ReplicaStateProto::RUR,
            ReplicaStateProto::TEMPORARY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ReplicaStateProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ReplicaStateProto {
}

impl ::std::default::Default for ReplicaStateProto {
    fn default() -> Self {
        ReplicaStateProto::FINALIZED
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaStateProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nhdfs.proto\x12\x0bhadoop.hdfs\x1a\x0eSecurity.proto\"c\n\x12Extended\
    BlockProto\x12\x0e\n\x06poolId\x18\x01\x20\x02(\t\x12\x0f\n\x07blockId\
    \x18\x02\x20\x02(\x04\x12\x17\n\x0fgenerationStamp\x18\x03\x20\x02(\x04\
    \x12\x13\n\x08numBytes\x18\x04\x20\x01(\x04:\x010\"\x99\x01\n\x0fDatanod\
    eIDProto\x12\x0e\n\x06ipAddr\x18\x01\x20\x02(\t\x12\x10\n\x08hostName\
    \x18\x02\x20\x02(\t\x12\x14\n\x0cdatanodeUuid\x18\x03\x20\x02(\t\x12\x10\
    \n\x08xferPort\x18\x04\x20\x02(\r\x12\x10\n\x08infoPort\x18\x05\x20\x02(\
    \r\x12\x0f\n\x07ipcPort\x18\x06\x20\x02(\r\x12\x19\n\x0einfoSecurePort\
    \x18\x07\x20\x01(\r:\x010\"X\n\x16DatanodeLocalInfoProto\x12\x17\n\x0fso\
    ftwareVersion\x18\x01\x20\x02(\t\x12\x15\n\rconfigVersion\x18\x02\x20\
    \x02(\t\x12\x0e\n\x06uptime\x18\x03\x20\x02(\x04\"G\n\x12DatanodeInfosPr\
    oto\x121\n\tdatanodes\x18\x01\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfo\
    Proto\"\x93\x04\n\x11DatanodeInfoProto\x12(\n\x02id\x18\x01\x20\x02(\x0b\
    2\x1c.hadoop.hdfs.DatanodeIDProto\x12\x13\n\x08capacity\x18\x02\x20\x01(\
    \x04:\x010\x12\x12\n\x07dfsUsed\x18\x03\x20\x01(\x04:\x010\x12\x14\n\tre\
    maining\x18\x04\x20\x01(\x04:\x010\x12\x18\n\rblockPoolUsed\x18\x05\x20\
    \x01(\x04:\x010\x12\x15\n\nlastUpdate\x18\x06\x20\x01(\x04:\x010\x12\x17\
    \n\x0cxceiverCount\x18\x07\x20\x01(\r:\x010\x12\x10\n\x08location\x18\
    \x08\x20\x01(\t\x12\x12\n\nnonDfsUsed\x18\t\x20\x01(\x04\x12E\n\nadminSt\
    ate\x18\n\x20\x01(\x0e2).hadoop.hdfs.DatanodeInfoProto.AdminState:\x06NO\
    RMAL\x12\x18\n\rcacheCapacity\x18\x0b\x20\x01(\x04:\x010\x12\x14\n\tcach\
    eUsed\x18\x0c\x20\x01(\x04:\x010\x12\x1e\n\x13lastUpdateMonotonic\x18\r\
    \x20\x01(\x04:\x010\x12\x1e\n\x13lastBlockReportTime\x18\x0f\x20\x01(\
    \x04:\x010\x12#\n\x18lastBlockReportMonotonic\x18\x10\x20\x01(\x04:\x010\
    \"I\n\nAdminState\x12\n\n\x06NORMAL\x10\0\x12\x1b\n\x17DECOMMISSION_INPR\
    OGRESS\x10\x01\x12\x12\n\x0eDECOMMISSIONED\x10\x02\"\xde\x01\n\x14Datano\
    deStorageProto\x12\x13\n\x0bstorageUuid\x18\x01\x20\x02(\t\x12E\n\x05sta\
    te\x18\x02\x20\x01(\x0e2..hadoop.hdfs.DatanodeStorageProto.StorageState:\
    \x06NORMAL\x128\n\x0bstorageType\x18\x03\x20\x01(\x0e2\x1d.hadoop.hdfs.S\
    torageTypeProto:\x04DISK\"0\n\x0cStorageState\x12\n\n\x06NORMAL\x10\0\
    \x12\x14\n\x10READ_ONLY_SHARED\x10\x01\"\xe5\x01\n\x12StorageReportProto\
    \x12\x17\n\x0bstorageUuid\x18\x01\x20\x02(\tB\x02\x18\x01\x12\x15\n\x06f\
    ailed\x18\x02\x20\x01(\x08:\x05false\x12\x13\n\x08capacity\x18\x03\x20\
    \x01(\x04:\x010\x12\x12\n\x07dfsUsed\x18\x04\x20\x01(\x04:\x010\x12\x14\
    \n\tremaining\x18\x05\x20\x01(\x04:\x010\x12\x18\n\rblockPoolUsed\x18\
    \x06\x20\x01(\x04:\x010\x122\n\x07storage\x18\x07\x20\x01(\x0b2!.hadoop.\
    hdfs.DatanodeStorageProto\x12\x12\n\nnonDfsUsed\x18\x08\x20\x01(\x04\"\
    \xcb\x01\n\x13ContentSummaryProto\x12\x0e\n\x06length\x18\x01\x20\x02(\
    \x04\x12\x11\n\tfileCount\x18\x02\x20\x02(\x04\x12\x16\n\x0edirectoryCou\
    nt\x18\x03\x20\x02(\x04\x12\r\n\x05quota\x18\x04\x20\x02(\x04\x12\x15\n\
    \rspaceConsumed\x18\x05\x20\x02(\x04\x12\x12\n\nspaceQuota\x18\x06\x20\
    \x02(\x04\x12?\n\x0etypeQuotaInfos\x18\x07\x20\x01(\x0b2'.hadoop.hdfs.St\
    orageTypeQuotaInfosProto\"\xab\x01\n\x0fQuotaUsageProto\x12\x1d\n\x15fil\
    eAndDirectoryCount\x18\x01\x20\x02(\x04\x12\r\n\x05quota\x18\x02\x20\x02\
    (\x04\x12\x15\n\rspaceConsumed\x18\x03\x20\x02(\x04\x12\x12\n\nspaceQuot\
    a\x18\x04\x20\x02(\x04\x12?\n\x0etypeQuotaInfos\x18\x05\x20\x01(\x0b2'.h\
    adoop.hdfs.StorageTypeQuotaInfosProto\"[\n\x1aStorageTypeQuotaInfosProto\
    \x12=\n\rtypeQuotaInfo\x18\x01\x20\x03(\x0b2&.hadoop.hdfs.StorageTypeQuo\
    taInfoProto\"i\n\x19StorageTypeQuotaInfoProto\x12+\n\x04type\x18\x01\x20\
    \x02(\x0e2\x1d.hadoop.hdfs.StorageTypeProto\x12\r\n\x05quota\x18\x02\x20\
    \x02(\x04\x12\x10\n\x08consumed\x18\x03\x20\x02(\x04\"7\n\x16CorruptFile\
    BlocksProto\x12\r\n\x05files\x18\x01\x20\x03(\t\x12\x0e\n\x06cookie\x18\
    \x02\x20\x02(\t\"!\n\x11FsPermissionProto\x12\x0c\n\x04perm\x18\x01\x20\
    \x02(\r\"H\n\x11StorageTypesProto\x123\n\x0cstorageTypes\x18\x01\x20\x03\
    (\x0e2\x1d.hadoop.hdfs.StorageTypeProto\"\xf4\x01\n\x17BlockStoragePolic\
    yProto\x12\x10\n\x08policyId\x18\x01\x20\x02(\r\x12\x0c\n\x04name\x18\
    \x02\x20\x02(\t\x126\n\x0ecreationPolicy\x18\x03\x20\x02(\x0b2\x1e.hadoo\
    p.hdfs.StorageTypesProto\x12>\n\x16creationFallbackPolicy\x18\x04\x20\
    \x01(\x0b2\x1e.hadoop.hdfs.StorageTypesProto\x12A\n\x19replicationFallba\
    ckPolicy\x18\x05\x20\x01(\x0b2\x1e.hadoop.hdfs.StorageTypesProto\")\n\
    \x11StorageUuidsProto\x12\x14\n\x0cstorageUuids\x18\x01\x20\x03(\t\"\x9c\
    \x02\n\x11LocatedBlockProto\x12*\n\x01b\x18\x01\x20\x02(\x0b2\x1f.hadoop\
    .hdfs.ExtendedBlockProto\x12\x0e\n\x06offset\x18\x02\x20\x02(\x04\x12,\n\
    \x04locs\x18\x03\x20\x03(\x0b2\x1e.hadoop.hdfs.DatanodeInfoProto\x12\x0f\
    \n\x07corrupt\x18\x04\x20\x02(\x08\x12-\n\nblockToken\x18\x05\x20\x02(\
    \x0b2\x19.hadoop.common.TokenProto\x12\x14\n\x08isCached\x18\x06\x20\x03\
    (\x08B\x02\x10\x01\x123\n\x0cstorageTypes\x18\x07\x20\x03(\x0e2\x1d.hado\
    op.hdfs.StorageTypeProto\x12\x12\n\nstorageIDs\x18\x08\x20\x03(\t\"\x93\
    \x01\n\x16DataEncryptionKeyProto\x12\r\n\x05keyId\x18\x01\x20\x02(\r\x12\
    \x13\n\x0bblockPoolId\x18\x02\x20\x02(\t\x12\r\n\x05nonce\x18\x03\x20\
    \x02(\x0c\x12\x15\n\rencryptionKey\x18\x04\x20\x02(\x0c\x12\x12\n\nexpir\
    yDate\x18\x05\x20\x02(\x04\x12\x1b\n\x13encryptionAlgorithm\x18\x06\x20\
    \x01(\t\"\xd3\x01\n\x17FileEncryptionInfoProto\x12,\n\x05suite\x18\x01\
    \x20\x02(\x0e2\x1d.hadoop.hdfs.CipherSuiteProto\x12F\n\x15cryptoProtocol\
    Version\x18\x02\x20\x02(\x0e2'.hadoop.hdfs.CryptoProtocolVersionProto\
    \x12\x0b\n\x03key\x18\x03\x20\x02(\x0c\x12\n\n\x02iv\x18\x04\x20\x02(\
    \x0c\x12\x0f\n\x07keyName\x18\x05\x20\x02(\t\x12\x18\n\x10ezKeyVersionNa\
    me\x18\x06\x20\x02(\t\"O\n\x1aPerFileEncryptionInfoProto\x12\x0b\n\x03ke\
    y\x18\x01\x20\x02(\x0c\x12\n\n\x02iv\x18\x02\x20\x02(\x0c\x12\x18\n\x10e\
    zKeyVersionName\x18\x03\x20\x02(\t\"\xa0\x01\n\x17ZoneEncryptionInfoProt\
    o\x12,\n\x05suite\x18\x01\x20\x02(\x0e2\x1d.hadoop.hdfs.CipherSuiteProto\
    \x12F\n\x15cryptoProtocolVersion\x18\x02\x20\x02(\x0e2'.hadoop.hdfs.Cryp\
    toProtocolVersionProto\x12\x0f\n\x07keyName\x18\x03\x20\x02(\t\"}\n\x11C\
    ipherOptionProto\x12,\n\x05suite\x18\x01\x20\x02(\x0e2\x1d.hadoop.hdfs.C\
    ipherSuiteProto\x12\r\n\x05inKey\x18\x02\x20\x01(\x0c\x12\x0c\n\x04inIv\
    \x18\x03\x20\x01(\x0c\x12\x0e\n\x06outKey\x18\x04\x20\x01(\x0c\x12\r\n\
    \x05outIv\x18\x05\x20\x01(\x0c\"\x85\x02\n\x12LocatedBlocksProto\x12\x12\
    \n\nfileLength\x18\x01\x20\x02(\x04\x12.\n\x06blocks\x18\x02\x20\x03(\
    \x0b2\x1e.hadoop.hdfs.LocatedBlockProto\x12\x19\n\x11underConstruction\
    \x18\x03\x20\x02(\x08\x121\n\tlastBlock\x18\x04\x20\x01(\x0b2\x1e.hadoop\
    .hdfs.LocatedBlockProto\x12\x1b\n\x13isLastBlockComplete\x18\x05\x20\x02\
    (\x08\x12@\n\x12fileEncryptionInfo\x18\x06\x20\x01(\x0b2$.hadoop.hdfs.Fi\
    leEncryptionInfoProto\"\xa8\x04\n\x13HdfsFileStatusProto\x12;\n\x08fileT\
    ype\x18\x01\x20\x02(\x0e2).hadoop.hdfs.HdfsFileStatusProto.FileType\x12\
    \x0c\n\x04path\x18\x02\x20\x02(\x0c\x12\x0e\n\x06length\x18\x03\x20\x02(\
    \x04\x122\n\npermission\x18\x04\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissi\
    onProto\x12\r\n\x05owner\x18\x05\x20\x02(\t\x12\r\n\x05group\x18\x06\x20\
    \x02(\t\x12\x19\n\x11modification_time\x18\x07\x20\x02(\x04\x12\x13\n\
    \x0baccess_time\x18\x08\x20\x02(\x04\x12\x0f\n\x07symlink\x18\t\x20\x01(\
    \x0c\x12\x1c\n\x11block_replication\x18\n\x20\x01(\r:\x010\x12\x14\n\tbl\
    ocksize\x18\x0b\x20\x01(\x04:\x010\x122\n\tlocations\x18\x0c\x20\x01(\
    \x0b2\x1f.hadoop.hdfs.LocatedBlocksProto\x12\x11\n\x06fileId\x18\r\x20\
    \x01(\x04:\x010\x12\x17\n\x0bchildrenNum\x18\x0e\x20\x01(\x05:\x02-1\x12\
    @\n\x12fileEncryptionInfo\x18\x0f\x20\x01(\x0b2$.hadoop.hdfs.FileEncrypt\
    ionInfoProto\x12\x18\n\rstoragePolicy\x18\x10\x20\x01(\r:\x010\"3\n\x08F\
    ileType\x12\n\n\x06IS_DIR\x10\x01\x12\x0b\n\x07IS_FILE\x10\x02\x12\x0e\n\
    \nIS_SYMLINK\x10\x03\"\x8e\x02\n\x15FsServerDefaultsProto\x12\x11\n\tblo\
    ckSize\x18\x01\x20\x02(\x04\x12\x18\n\x10bytesPerChecksum\x18\x02\x20\
    \x02(\r\x12\x17\n\x0fwritePacketSize\x18\x03\x20\x02(\r\x12\x13\n\x0brep\
    lication\x18\x04\x20\x02(\r\x12\x16\n\x0efileBufferSize\x18\x05\x20\x02(\
    \r\x12\"\n\x13encryptDataTransfer\x18\x06\x20\x01(\x08:\x05false\x12\x18\
    \n\rtrashInterval\x18\x07\x20\x01(\x04:\x010\x12D\n\x0cchecksumType\x18\
    \x08\x20\x01(\x0e2\x1e.hadoop.hdfs.ChecksumTypeProto:\x0eCHECKSUM_CRC32\
    \"k\n\x15DirectoryListingProto\x128\n\x0epartialListing\x18\x01\x20\x03(\
    \x0b2\x20.hadoop.hdfs.HdfsFileStatusProto\x12\x18\n\x10remainingEntries\
    \x18\x02\x20\x02(\r\"\xa2\x01\n!SnapshottableDirectoryStatusProto\x123\n\
    \tdirStatus\x18\x01\x20\x02(\x0b2\x20.hadoop.hdfs.HdfsFileStatusProto\
    \x12\x16\n\x0esnapshot_quota\x18\x02\x20\x02(\r\x12\x17\n\x0fsnapshot_nu\
    mber\x18\x03\x20\x02(\r\x12\x17\n\x0fparent_fullpath\x18\x04\x20\x02(\
    \x0c\"u\n\"SnapshottableDirectoryListingProto\x12O\n\x17snapshottableDir\
    Listing\x18\x01\x20\x03(\x0b2..hadoop.hdfs.SnapshottableDirectoryStatusP\
    roto\"_\n\x1cSnapshotDiffReportEntryProto\x12\x10\n\x08fullpath\x18\x01\
    \x20\x02(\x0c\x12\x19\n\x11modificationLabel\x18\x02\x20\x02(\t\x12\x12\
    \n\ntargetPath\x18\x03\x20\x01(\x0c\"\x9f\x01\n\x17SnapshotDiffReportPro\
    to\x12\x14\n\x0csnapshotRoot\x18\x01\x20\x02(\t\x12\x14\n\x0cfromSnapsho\
    t\x18\x02\x20\x02(\t\x12\x12\n\ntoSnapshot\x18\x03\x20\x02(\t\x12D\n\x11\
    diffReportEntries\x18\x04\x20\x03(\x0b2).hadoop.hdfs.SnapshotDiffReportE\
    ntryProto\"_\n\x10StorageInfoProto\x12\x15\n\rlayoutVersion\x18\x01\x20\
    \x02(\r\x12\x12\n\nnamespceID\x18\x02\x20\x02(\r\x12\x11\n\tclusterID\
    \x18\x03\x20\x02(\t\x12\r\n\x05cTime\x18\x04\x20\x02(\x04\"\x89\x02\n\
    \x19NamenodeRegistrationProto\x12\x12\n\nrpcAddress\x18\x01\x20\x02(\t\
    \x12\x13\n\x0bhttpAddress\x18\x02\x20\x02(\t\x122\n\x0bstorageInfo\x18\
    \x03\x20\x02(\x0b2\x1d.hadoop.hdfs.StorageInfoProto\x12P\n\x04role\x18\
    \x04\x20\x01(\x0e28.hadoop.hdfs.NamenodeRegistrationProto.NamenodeRolePr\
    oto:\x08NAMENODE\"=\n\x11NamenodeRoleProto\x12\x0c\n\x08NAMENODE\x10\x01\
    \x12\n\n\x06BACKUP\x10\x02\x12\x0e\n\nCHECKPOINT\x10\x03\"\x9d\x01\n\x18\
    CheckpointSignatureProto\x12\x13\n\x0bblockPoolId\x18\x01\x20\x02(\t\x12\
    \x20\n\x18mostRecentCheckpointTxId\x18\x02\x20\x02(\x04\x12\x16\n\x0ecur\
    SegmentTxId\x18\x03\x20\x02(\x04\x122\n\x0bstorageInfo\x18\x04\x20\x02(\
    \x0b2\x1d.hadoop.hdfs.StorageInfoProto\"\xcc\x01\n\x14NamenodeCommandPro\
    to\x12\x0e\n\x06action\x18\x01\x20\x02(\r\x124\n\x04type\x18\x02\x20\x02\
    (\x0e2&.hadoop.hdfs.NamenodeCommandProto.Type\x12:\n\rcheckpointCmd\x18\
    \x03\x20\x01(\x0b2#.hadoop.hdfs.CheckpointCommandProto\"2\n\x04Type\x12\
    \x13\n\x0fNamenodeCommand\x10\0\x12\x15\n\x11CheckPointCommand\x10\x01\"\
    m\n\x16CheckpointCommandProto\x128\n\tsignature\x18\x01\x20\x02(\x0b2%.h\
    adoop.hdfs.CheckpointSignatureProto\x12\x19\n\x11needToReturnImage\x18\
    \x02\x20\x02(\x08\"D\n\nBlockProto\x12\x0f\n\x07blockId\x18\x01\x20\x02(\
    \x04\x12\x10\n\x08genStamp\x18\x02\x20\x02(\x04\x12\x13\n\x08numBytes\
    \x18\x03\x20\x01(\x04:\x010\"\xa3\x01\n\x17BlockWithLocationsProto\x12&\
    \n\x05block\x18\x01\x20\x02(\x0b2\x17.hadoop.hdfs.BlockProto\x12\x15\n\r\
    datanodeUuids\x18\x02\x20\x03(\t\x12\x14\n\x0cstorageUuids\x18\x03\x20\
    \x03(\t\x123\n\x0cstorageTypes\x18\x04\x20\x03(\x0e2\x1d.hadoop.hdfs.Sto\
    rageTypeProto\"P\n\x18BlocksWithLocationsProto\x124\n\x06blocks\x18\x01\
    \x20\x03(\x0b2$.hadoop.hdfs.BlockWithLocationsProto\"U\n\x12RemoteEditLo\
    gProto\x12\x11\n\tstartTxId\x18\x01\x20\x02(\x04\x12\x0f\n\x07endTxId\
    \x18\x02\x20\x02(\x04\x12\x1b\n\x0cisInProgress\x18\x03\x20\x01(\x08:\
    \x05false\"K\n\x1aRemoteEditLogManifestProto\x12-\n\x04logs\x18\x01\x20\
    \x03(\x0b2\x1f.hadoop.hdfs.RemoteEditLogProto\"\xb5\x01\n\x12NamespaceIn\
    foProto\x12\x14\n\x0cbuildVersion\x18\x01\x20\x02(\t\x12\x0e\n\x06unused\
    \x18\x02\x20\x02(\r\x12\x13\n\x0bblockPoolID\x18\x03\x20\x02(\t\x122\n\
    \x0bstorageInfo\x18\x04\x20\x02(\x0b2\x1d.hadoop.hdfs.StorageInfoProto\
    \x12\x17\n\x0fsoftwareVersion\x18\x05\x20\x02(\t\x12\x17\n\x0ccapabiliti\
    es\x18\x06\x20\x01(\x04:\x010\"D\n\rBlockKeyProto\x12\r\n\x05keyId\x18\
    \x01\x20\x02(\r\x12\x12\n\nexpiryDate\x18\x02\x20\x02(\x04\x12\x10\n\x08\
    keyBytes\x18\x03\x20\x01(\x0c\"\xc4\x01\n\x16ExportedBlockKeysProto\x12\
    \x1b\n\x13isBlockTokenEnabled\x18\x01\x20\x02(\x08\x12\x19\n\x11keyUpdat\
    eInterval\x18\x02\x20\x02(\x04\x12\x15\n\rtokenLifeTime\x18\x03\x20\x02(\
    \x04\x12.\n\ncurrentKey\x18\x04\x20\x02(\x0b2\x1a.hadoop.hdfs.BlockKeyPr\
    oto\x12+\n\x07allKeys\x18\x05\x20\x03(\x0b2\x1a.hadoop.hdfs.BlockKeyProt\
    o\"\x8a\x01\n\x14RecoveringBlockProto\x12\x13\n\x0bnewGenStamp\x18\x01\
    \x20\x02(\x04\x12-\n\x05block\x18\x02\x20\x02(\x0b2\x1e.hadoop.hdfs.Loca\
    tedBlockProto\x12.\n\rtruncateBlock\x18\x03\x20\x01(\x0b2\x17.hadoop.hdf\
    s.BlockProto\"\x15\n\x13VersionRequestProto\"E\n\x14VersionResponseProto\
    \x12-\n\x04info\x18\x01\x20\x02(\x0b2\x1f.hadoop.hdfs.NamespaceInfoProto\
    \"\xa5\x01\n\x11SnapshotInfoProto\x12\x14\n\x0csnapshotName\x18\x01\x20\
    \x02(\t\x12\x14\n\x0csnapshotRoot\x18\x02\x20\x02(\t\x122\n\npermission\
    \x18\x03\x20\x02(\x0b2\x1e.hadoop.hdfs.FsPermissionProto\x12\r\n\x05owne\
    r\x18\x04\x20\x02(\t\x12\r\n\x05group\x18\x05\x20\x02(\t\x12\x12\n\ncrea\
    teTime\x18\x06\x20\x02(\t\"J\n\x19RollingUpgradeStatusProto\x12\x13\n\
    \x0bblockPoolId\x18\x01\x20\x02(\t\x12\x18\n\tfinalized\x18\x02\x20\x01(\
    \x08:\x05false*@\n\x10StorageTypeProto\x12\x08\n\x04DISK\x10\x01\x12\x07\
    \n\x03SSD\x10\x02\x12\x0b\n\x07ARCHIVE\x10\x03\x12\x0c\n\x08RAM_DISK\x10\
    \x04*6\n\x10CipherSuiteProto\x12\x0b\n\x07UNKNOWN\x10\x01\x12\x15\n\x11A\
    ES_CTR_NOPADDING\x10\x02*P\n\x1aCryptoProtocolVersionProto\x12\x1c\n\x18\
    UNKNOWN_PROTOCOL_VERSION\x10\x01\x12\x14\n\x10ENCRYPTION_ZONES\x10\x02*O\
    \n\x11ChecksumTypeProto\x12\x11\n\rCHECKSUM_NULL\x10\0\x12\x12\n\x0eCHEC\
    KSUM_CRC32\x10\x01\x12\x13\n\x0fCHECKSUM_CRC32C\x10\x02*L\n\x11ReplicaSt\
    ateProto\x12\r\n\tFINALIZED\x10\0\x12\x07\n\x03RBW\x10\x01\x12\x07\n\x03\
    RWR\x10\x02\x12\x07\n\x03RUR\x10\x03\x12\r\n\tTEMPORARY\x10\x04B6\n%org.\
    apache.hadoop.hdfs.protocol.protoB\nHdfsProtos\xa0\x01\x01\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
